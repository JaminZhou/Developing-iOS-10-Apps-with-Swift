1
00:00:00,401 --> 00:00:04,536
[MUSIC]

2
00:00:04,605 --> 00:00:10,876
斯坦福大学。欢迎来到斯坦福CS193P，

3
00:00:10,945 --> 00:00:14,279
这是开发iOS应用程序，

4
00:00:14,347 --> 00:00:18,984
这是2017年的冬天。这是本学期唯一的讲座

5
00:00:19,052 --> 00:00:23,122
在那里我不会做演示，所以这是幻灯片，

6
00:00:23,190 --> 00:00:27,025
那是因为我很想去尝试

7
00:00:27,094 --> 00:00:31,329
让你完全能够快速的在Swift成长。我一切都是

8
00:00:31,398 --> 00:00:34,233
今天要谈论的是在你的阅读中

9
00:00:34,301 --> 00:00:37,236
任务一，今天到期，所以希望你是

10
00:00:37,304 --> 00:00:39,904
做到这一点，还是在阅读作业二，

11
00:00:39,973 --> 00:00:43,942
这是今天出来，将在下周三。所以，

12
00:00:44,010 --> 00:00:47,011
为什么我甚至覆盖这个？因为我知道读书

13
00:00:47,080 --> 00:00:50,115
通过阅读作业可能是一个很大的麻烦

14
00:00:50,184 --> 00:00:53,384
通过很多信息，我想让你明白

15
00:00:53,453 --> 00:00:56,822
那里的东西真的很重要。当我走

16
00:00:56,890 --> 00:00:59,358
通过幻灯片今天，如果你看到的东西和

17
00:00:59,426 --> 00:01:03,094
我解释一下，你就像，我的天哪，我没有得到，

18
00:01:03,163 --> 00:01:06,131
只是记下我的主题

19
00:01:06,200 --> 00:01:07,532
谈论，然后你可以回去

20
00:01:07,601 --> 00:01:09,667
在阅读作业中再次阅读并尝试

21
00:01:09,736 --> 00:01:11,770
明白它。如果你还不明白，

22
00:01:11,839 --> 00:01:15,440
你当然可以在课堂上问问题。

23
00:01:15,509 --> 00:01:18,443
你可以把它看作是拳头的亮点

24
00:01:18,512 --> 00:01:21,613
两个阅读作业。其中一些也是亮点

25
00:01:21,682 --> 00:01:24,283
在演示的前两个讲座中，

26
00:01:24,351 --> 00:01:25,817
所以有一点点在那里。

27
00:01:25,886 --> 00:01:28,787
但是，这真的是Swift的重要内容，

28
00:01:28,855 --> 00:01:30,121
在这一点上我可以教你。

29
00:01:30,190 --> 00:01:33,758
Swift 还有更重要的东西，好的，

30
00:01:33,827 --> 00:01:38,263
但是我会在接下来的两个星期里教我们一样。

31
00:01:38,332 --> 00:01:41,500
好的，很多Swift主题，

32
00:01:41,569 --> 00:01:43,769
我们先从第一个开始，大概是所有人

33
00:01:43,837 --> 00:01:45,537
最喜欢的话题，当他们第一次学习Swift，

34
00:01:45,606 --> 00:01:50,275
这是可选的。可选是有趣的Swift，

35
00:01:50,344 --> 00:01:53,345
因为不是很多其他语言都有可选的，所以

36
00:01:53,413 --> 00:01:56,047
我相信，其实我听说过你们中的一些人，

37
00:01:56,116 --> 00:01:58,250
“嗯，我不知道我真的明白可选

38
00:01:58,318 --> 00:02:02,654
事情“，这可能还可以，但到下一个结束

39
00:02:02,723 --> 00:02:04,956
一周你应该对可选项感到非常自信，

40
00:02:05,025 --> 00:02:07,659
因为你会看到他们绝对无处不在

41
00:02:07,728 --> 00:02:10,696
在iOS中。现在我在演讲中提到过，但是

42
00:02:10,765 --> 00:02:12,497
我想从一个代码向你显示，

43
00:02:12,566 --> 00:02:16,134
一种代码的观点，这是可选的

44
00:02:16,203 --> 00:02:19,971
只不过是一个枚举，它只是一个枚举，

45
00:02:20,040 --> 00:02:23,408
这是一个可选的枚举。这是一种通用类型，

46
00:02:23,476 --> 00:02:26,011
有点像阵列，当你说的是数组的类型，

47
00:02:26,080 --> 00:02:29,013
你说你放在数组中的东西的类型。

48
00:02:29,082 --> 00:02:31,783
你应该都是熟悉的，与Java一样

49
00:02:31,852 --> 00:02:33,351
例如，同样的事情在Swift。

50
00:02:33,420 --> 00:02:35,053
所以，选择它是一样的，

51
00:02:35,122 --> 00:02:38,189
你把这个类型和类型关联在那里，或者

52
00:02:38,258 --> 00:02:39,524
不是相关联的，但是

53
00:02:39,593 --> 00:02:41,393
我们正在谈论的通用类型的类型，

54
00:02:41,462 --> 00:02:42,727
那个“T”在一个可选的，

55
00:02:42,796 --> 00:02:45,297
只是这个类型将成为相关联的值。

56
00:02:45,366 --> 00:02:48,533
当你看这个枚举可选的时候，

57
00:02:48,602 --> 00:02:53,005
它只有两种情况：“无”是“未设置”，和

58
00:02:53,073 --> 00:02:56,241
“一些”是“设定”。在某种情况下，看看：

59
00:02:56,310 --> 00:02:59,645
“（T）”，你知道这是从计算器演示，

60
00:02:59,713 --> 00:03:02,480
这是一个相关的价值，就像我们一样

61
00:03:02,549 --> 00:03:06,017
在计算器中操作它具有相关联的值，如一元

62
00:03:06,086 --> 00:03:09,087
操作具有函数的关联值，

63
00:03:09,155 --> 00:03:12,824
常数具有常数值的相关值。

64
00:03:12,893 --> 00:03:15,260
同样的事情在这里，可选的，在“一些”的情况下，

65
00:03:15,329 --> 00:03:17,562
“集”的情况下，它只有一个相关联的值，和

66
00:03:17,631 --> 00:03:19,498
所以选择是什么类型的

67
00:03:19,566 --> 00:03:22,500
如果这是一个可选的字符串，那么它将是一个字符串。

68
00:03:22,569 --> 00:03:28,240
现在什么使可选的像“我不是真的可以选择，

69
00:03:28,309 --> 00:03:30,041
这是什么？“，这是因为所有这些问号和

70
00:03:30,110 --> 00:03:32,577
感叹号但是，所有这些问号和

71
00:03:32,646 --> 00:03:35,146
感叹号，只是糖，

72
00:03:35,215 --> 00:03:39,218
语法糖，使您的代码看起来更简单一点

73
00:03:39,286 --> 00:03:42,153
直截了当，因为使用它们很常见。所以，

74
00:03:42,222 --> 00:03:45,457
我要将这个枚举映射到那个糖上。

75
00:03:46,926 --> 00:03:51,897
我们来看看，这是第一个：如果我说let x：

76
00:03:51,966 --> 00:03:56,835
String？= nil，完全一样

77
00:03:56,904 --> 00:04:01,840
说let x =可选<String> .none，

78
00:04:01,908 --> 00:04:05,777
就像说阵列一样，我会说

79
00:04:05,845 --> 00:04:09,147
Array <String>这意味着我想要一个String数组，

80
00:04:09,216 --> 00:04:11,683
这里当我说可选<String>，这意味着我想要的

81
00:04:11,752 --> 00:04:16,321
一个可选字符串。我正在挑选无一例，而且

82
00:04:16,389 --> 00:04:20,125
以相同的方式，如果我说let x =可选<string> =

83
00:04:20,194 --> 00:04:24,329
你好，我只是说x =可选<string> .some

84
00:04:24,398 --> 00:04:28,800
与相关联的值你好。每个人都得到了就这样

85
00:04:28,869 --> 00:04:31,537
那里正在发生问号的事情。

86
00:04:31,605 --> 00:04:34,839
然后这里是展开。当我们做这个感叹号

87
00:04:34,908 --> 00:04:38,410
所有我们正在做的是做切换来解决问题

88
00:04:38,478 --> 00:04:42,914
一个可选的，所以我们打开可选的，

89
00:04:42,983 --> 00:04:46,251
而在“一些”的情况下，那么我们要抓住这个

90
00:04:46,319 --> 00:04:49,053
相关价值就像我们在计算器中所做的一样

91
00:04:49,122 --> 00:04:51,923
我们说“let function”或“let value”来抓取关联的

92
00:04:51,992 --> 00:04:53,325
价值，我们在这里说“let value”

93
00:04:53,393 --> 00:04:58,663
它正在抓住与它相关联的值。

94
00:04:58,732 --> 00:05:00,798
如果没有，没有设置，

95
00:05:00,867 --> 00:05:04,002
那么它会引发一个异常并崩溃你的程序，

96
00:05:04,071 --> 00:05:07,572
我们没有谈论如何做到这一点，这很容易，但是

97
00:05:07,641 --> 00:05:08,173
这就是这里发生的事情

98
00:05:08,241 --> 00:05:10,843
这一切都是惊叹号，它基本上是一个转变。

99
00:05:11,979 --> 00:05:15,447
最后，如果我们做“if let”，

100
00:05:15,515 --> 00:05:19,084
“if let”也只是一个switch，但是

101
00:05:19,153 --> 00:05:22,254
在没有一个if let的情况下，我们不会引起例外，

102
00:05:22,323 --> 00:05:26,658
我们只是break，break switch。好的，

103
00:05:26,726 --> 00:05:29,361
这有助于您了解什么是可选项

104
00:05:29,429 --> 00:05:32,931
是什么？可选是一个类型，它是一个枚举，它就像任何一个

105
00:05:33,000 --> 00:05:35,400
其他类型，它只是有这个有趣的行为，和

106
00:05:35,468 --> 00:05:36,501
它有所有的问号和

107
00:05:36,570 --> 00:05:39,070
惊叹号使所有的代码看起来有点

108
00:05:39,139 --> 00:05:42,407
简单。现在，还有其他关于可选项的内容

109
00:05:42,476 --> 00:05:46,311
这很有趣可选项可以链接。

110
00:05:46,380 --> 00:05:49,481
这是什么意思？嗯，这是最好的例子。

111
00:05:49,550 --> 00:05:53,885
所以，假设我有一个可选的UILabel像我一样

112
00:05:53,954 --> 00:05:57,556
显示在计算器中，它有文本，也是

113
00:05:57,625 --> 00:06:00,859
一个可选的可选字符串，大家都知道。和

114
00:06:00,928 --> 00:06:04,062
假设我们要获取只是一个var的hashValue

115
00:06:04,131 --> 00:06:07,632
在字符串上，其中包含字符串，给你一些整数

116
00:06:07,701 --> 00:06:10,401
为此，我想得到那个hashValue的内容

117
00:06:10,470 --> 00:06:13,938
显示器。那么我可能会做一些代码

118
00:06:14,007 --> 00:06:16,842
看起来像这样，这可能是相似的代码到什么

119
00:06:16,911 --> 00:06:20,211
我们在我的计算器里有我的显示器，

120
00:06:20,280 --> 00:06:24,882
这是我的IBOutlet可能显示UILabel？和

121
00:06:24,951 --> 00:06:29,321
我要去做“if let”在这里，因为我不想崩溃

122
00:06:29,390 --> 00:06:30,755
所以我不想做感叹号，

123
00:06:30,824 --> 00:06:32,524
我要做“if let”，所以我要说“if let

124
00:06:32,593 --> 00:06:35,794
一些临时值等于显示“（现在temp1是

125
00:06:35,863 --> 00:06:40,599
UILabel），然后我说“如果让temp2 = temp1.text”，

126
00:06:40,667 --> 00:06:43,568
我正在向UILabel发送文本

127
00:06:43,637 --> 00:06:46,037
现在我正在收回一个String，而不是一个可选字符串，但是

128
00:06:46,106 --> 00:06:48,707
一个字符串，因为我做了“如果让”，那我可以终于说，

129
00:06:48,776 --> 00:06:51,542
那么“let x = temp2”就是String，

130
00:06:51,611 --> 00:06:55,747
hashValue。好的，这是很多代码要输入

131
00:06:55,816 --> 00:07:00,084
只是得到那个dang hashValue，从UILabel的文本。

132
00:07:00,153 --> 00:07:03,422
随着可选链接，这个相同的代码看起来像这样，

133
00:07:03,490 --> 00:07:05,290
这两行的第一行。

134
00:07:05,359 --> 00:07:10,696
“如果让x = display？.text？.hashValue，

135
00:07:10,764 --> 00:07:16,568
然后用x“做一些事情，在这种情况下，x会

136
00:07:16,636 --> 00:07:20,005
是一个非可选的，因为我在做，如果让它。

137
00:07:20,073 --> 00:07:23,408
如果我采取“if”关闭，只是做“let x =”所有这一切，

138
00:07:23,476 --> 00:07:27,045
那么x将是一个可选的Int。现在，这是如何工作的？

139
00:07:27,113 --> 00:07:28,547
发生的是每次你有一个

140
00:07:28,616 --> 00:07:31,750
这个问号在可选之后，就是说，

141
00:07:31,819 --> 00:07:35,620
如果这是在这种情况下，那么抓住它并继续

142
00:07:35,689 --> 00:07:39,324
去，发送下一件事。那么，如果是零的话

143
00:07:39,393 --> 00:07:42,861
这整个表情只是返回零，这整条线，

144
00:07:42,930 --> 00:07:45,998
繁荣，它只会返回零。如果我放弃，

145
00:07:46,066 --> 00:07:48,933
那么显然代码不会被执行。

146
00:07:49,002 --> 00:07:51,269
你可以按照你想要的一连几个做，

147
00:07:51,338 --> 00:07:55,574
我们一直这样做，这个可选的链接是要去的

148
00:07:55,642 --> 00:07:58,676
全部在你的代码，这是完美的意义，因为

149
00:07:58,745 --> 00:08:01,280
再次，我们使用这个问号和感叹号

150
00:08:01,348 --> 00:08:04,316
点。在这里我们碰巧使用问号

151
00:08:04,385 --> 00:08:07,952
访问它，而不是宣布它。就是这样

152
00:08:08,021 --> 00:08:09,621
意味着在访问时使用问号，

153
00:08:09,690 --> 00:08:12,557
这意味着去得到它，如果没有设置，

154
00:08:12,626 --> 00:08:14,359
那么从这个整个表达式返回零，

155
00:08:14,428 --> 00:08:15,661
它只会保释出来，

156
00:08:15,729 --> 00:08:18,196
它永远不会执行哈希值，因为我们永远不会

157
00:08:18,265 --> 00:08:20,366
如果任何这些东西都没有，那么下去就可以了。

158
00:08:24,471 --> 00:08:26,971
另一个很酷的选择我们可以做的是可选的

159
00:08:27,040 --> 00:08:31,543
违约。那么如果我们想把一个字符串放在我们里面呢

160
00:08:31,612 --> 00:08:35,480
UILabel就像我们的显示器，但是我们知道如果这样

161
00:08:35,548 --> 00:08:37,749
字符串是零，我们不想把它放在那里，因为

162
00:08:37,818 --> 00:08:40,418
如果我们把文本作为零，那么我们的标签将会发生什么？

163
00:08:40,487 --> 00:08:43,822
它会崩溃，对，大概你们都看到了。

164
00:08:43,891 --> 00:08:44,889
你必须把东西放在那里，

165
00:08:44,958 --> 00:08:47,759
至少有一个空格。所以让我们说，我想这样做，

166
00:08:47,828 --> 00:08:50,829
我想把空间放在那里，如果它是零。这是代码

167
00:08:50,898 --> 00:08:53,565
它会像这样：我会有我的字符串，我会的

168
00:08:53,634 --> 00:08:57,135
说如果字符串不是零，然后把它放在显示中，

169
00:08:57,204 --> 00:09:02,341
否则，如果没有，把空间放在那里。看起来

170
00:09:02,409 --> 00:09:06,845
很多清洁剂，可选的默认值，看起来像

171
00:09:06,913 --> 00:09:11,616
this，display.text = s这意味着如果s为零，请使用

172
00:09:11,685 --> 00:09:15,788
这个其他的事情这是默认的，如果s是nil。

173
00:09:17,191 --> 00:09:20,993
我们也会一直使用这个。每个人都得到了

174
00:09:21,061 --> 00:09:23,862
只是可选的默认值。好的，所以我把那些出来

175
00:09:23,931 --> 00:09:25,463
的可选世界只是为了突出他们，

176
00:09:25,532 --> 00:09:27,432
因为阅读中有很多你正在做的事情

177
00:09:27,501 --> 00:09:29,934
关于可选，但这些都是亮点。

178
00:09:30,003 --> 00:09:32,437
有一些事情其实我稍后会告诉你，

179
00:09:32,505 --> 00:09:35,707
但基本上是可选的。好吧，元组(tuples)。

180
00:09:35,775 --> 00:09:38,743
所以我有你在阅读作品中跳过元组，但是

181
00:09:38,812 --> 00:09:41,947
你将在阅读作业二中阅读他们。

182
00:09:42,015 --> 00:09:42,848
什么是元组(tuples)？

183
00:09:42,916 --> 00:09:47,886
元组是超简单的，它只是一组值，

184
00:09:47,955 --> 00:09:51,189
您可以在任何使用类型的地方使用它。是什么

185
00:09:51,258 --> 00:09:54,692
一个元组看起来像？看起来像这样这个var这里，

186
00:09:54,761 --> 00:09:59,164
这个常数，实际上是x，我把它的类型设置为一个元组

187
00:09:59,232 --> 00:10:04,002
一个字符串和int和aw，这是它的类型。一个元组

188
00:10:04,071 --> 00:10:06,972
在那里可以有任何数量的东西，但实际上，

189
00:10:07,041 --> 00:10:09,908
我们大概只有三四个，有时只有两个，但是

190
00:10:09,977 --> 00:10:15,980
它可以有任何数字。我可以设置x等于括号，

191
00:10:16,049 --> 00:10:19,451
那三种，这三种类型的任何值。所以在这里，

192
00:10:19,519 --> 00:10:22,187
我把它设置为你好，5和0.85。

193
00:10:22,255 --> 00:10:26,591
现在我可以通过这些值来获取值

194
00:10:26,660 --> 00:10:31,496
说，让括号中三个不同的变量名相等

195
00:10:31,565 --> 00:10:34,432
X。现在它会拉出三个不同的值

196
00:10:34,501 --> 00:10:36,968
进入三个单独的变量，单词，数字和

197
00:10:37,037 --> 00:10:41,039
值。所以那里有镜像，

198
00:10:41,108 --> 00:10:43,141
你可以走一走，两个方向，

199
00:10:43,209 --> 00:10:46,511
把东西放进去。实际上，我们相信与否，

200
00:10:46,580 --> 00:10:47,912
大多数时候不要这样做，

201
00:10:47,981 --> 00:10:52,751
因为也可以命名一个元组的元素。

202
00:10:52,819 --> 00:10:55,987
所以在这里，我定义x，同样的事情，string int double，但是

203
00:10:56,056 --> 00:10:57,456
看，我已经命名了他们，

204
00:10:57,524 --> 00:11:00,992
我打电话给字符串部分w，我打电话给我的第一部分，和

205
00:11:01,061 --> 00:11:04,262
由于某种原因我叫双重部分v。现在，我还是设置

206
00:11:04,331 --> 00:11:07,833
它等同于完全相同的方式，没有区别。但

207
00:11:07,901 --> 00:11:10,735
现在我不需要把它拉到单独的变量中。

208
00:11:10,804 --> 00:11:15,407
我可以说xw，并得到它的第一个组成部分。

209
00:11:15,476 --> 00:11:18,510
你看到了吗这是我们如何使用名称的元组。

210
00:11:18,579 --> 00:11:21,446
我强烈建议你几乎总是使用

211
00:11:21,515 --> 00:11:24,183
名称与元组。这只是一点点阅读，

212
00:11:24,251 --> 00:11:27,685
更清楚地说你的意图是作为程序员。

213
00:11:27,754 --> 00:11:28,654
因为那些名字

214
00:11:30,423 --> 00:11:32,590
的元组的部分可以有很好的变量名。

215
00:11:32,659 --> 00:11:35,927
你会看到你的编程分配号码

216
00:11:35,996 --> 00:11:39,564
2，我要写一个返回一个元组的函数，

217
00:11:39,633 --> 00:11:43,568
它将指定零件的名称。现在甚至

218
00:11:43,637 --> 00:11:46,605
如果你给他们命名，就像我们有x一样，

219
00:11:46,674 --> 00:11:50,075
你仍然可以做那个你刚才说的话，let（word，

220
00:11:50,143 --> 00:11:53,211
num，val）等于x，它仍然会拉出来

221
00:11:53,280 --> 00:11:56,448
个人，所以命名他们不会阻止你

222
00:11:56,517 --> 00:11:59,751
如果你想要的话，用单个变量拉出它们。

223
00:11:59,820 --> 00:12:03,254
此外，在元组中，您可以随时放入下划线

224
00:12:03,323 --> 00:12:07,125
任何一个名字，就像这里我可以说let word_ val或

225
00:12:07,193 --> 00:12:11,096
let word，_，val等于x，然后我会得到word和

226
00:12:11,165 --> 00:12:15,367
变成个别的变量，我只会忽略它

227
00:12:15,435 --> 00:12:19,471
中间一个Swift的Underbar总是有点忽视

228
00:12:19,539 --> 00:12:22,341
那个，我对这件事情不感兴趣

229
00:12:22,409 --> 00:12:25,477
我们已经看到这个功能参数

230
00:12:25,546 --> 00:12:29,048
想忽略一个函数参数的外部名称。

231
00:12:29,116 --> 00:12:30,682
好的，所以使用返回值的元组，

232
00:12:30,751 --> 00:12:33,352
就像我说的，你会在作业中看到这个。

233
00:12:33,420 --> 00:12:36,354
这里没什么特别的这是类似任何其他类型，所以

234
00:12:36,423 --> 00:12:39,057
它可以是函数的返回类型。所以，这是你怎么样

235
00:12:39,126 --> 00:12:41,894
可以有一个返回多个值的函数。

236
00:12:41,962 --> 00:12:44,696
在某些语言中，很难做到这一点。

237
00:12:44,765 --> 00:12:46,998
你必须创建一个结构或东西来返回。

238
00:12:47,067 --> 00:12:48,366
然而，这是非常非常非常容易的Swift。

239
00:12:48,435 --> 00:12:50,769
你真的只是这样做和

240
00:12:50,838 --> 00:12:54,273
当您获得从该功能返回的值时，

241
00:12:54,341 --> 00:12:58,343
你只需按名称访问元素。请注意，当我

242
00:12:58,411 --> 00:13:01,747
在我的代码中返回它在getSize，我没有必要

243
00:13:01,816 --> 00:13:04,115
给名字我可以，如果我想，

244
00:13:04,184 --> 00:13:07,585
我可以说返回weight：150，height :,但是

245
00:13:07,654 --> 00:13:11,390
我决定，呃，我只是要回报价值。好的，

246
00:13:11,458 --> 00:13:15,994
另一件事：范围(range)，范围是重要的一点

247
00:13:16,063 --> 00:13:21,165
结构在Swift中：它代表的是两个终点。

248
00:13:21,234 --> 00:13:24,536
因此，范围对于例如文本的选择是有用的，

249
00:13:24,604 --> 00:13:27,806
选择开始的地方和选择结束的地方。

250
00:13:27,874 --> 00:13:32,610
它也适用于数组的子切片。如果你有

251
00:13:32,679 --> 00:13:35,180
数组的100个元素，你可能需要第15个

252
00:13:35,248 --> 00:13:38,250
第40个，所以你可以指定范围，15到40。

253
00:13:38,319 --> 00:13:41,086
所以范围是这个非常简单的小结构，哪一种

254
00:13:41,155 --> 00:13:43,655
看起来像这样。我说了一些，因为还有一点

255
00:13:43,723 --> 00:13:45,991
比这更复杂，但它基本上看起来像这样。

256
00:13:46,059 --> 00:13:49,061
它是一个类似数组的通用类型，因为你可以

257
00:13:49,129 --> 00:13:52,097
有一个ints范围。你可以有一系列的浮标。

258
00:13:52,166 --> 00:13:55,200
你甚至可以有一系列的字符串。可以，然后呢

259
00:13:55,269 --> 00:13:57,836
那个T可以是float，float，int，

260
00:13:57,905 --> 00:14:01,139
串。 T被限制了一点，我没有

261
00:14:01,208 --> 00:14:03,374
真的谈到你如何限制通用类型。

262
00:14:03,443 --> 00:14:04,610
但是T是有限的，

263
00:14:04,678 --> 00:14:07,746
它必须是可比的。那是因为

264
00:14:07,815 --> 00:14:10,481
范围需要确保起始索引小于

265
00:14:10,550 --> 00:14:13,619
最终索引。这是一个范围被定义的一部分。

266
00:14:13,687 --> 00:14:16,354
所以T必须是可以比较的东西

267
00:14:16,423 --> 00:14:19,258
看看开始索引是否小于最终索引，

268
00:14:19,326 --> 00:14:23,495
小东西在那里所以，例如，一个int的范围

269
00:14:23,563 --> 00:14:25,964
对于在数组中指定一个范围是非常好的，

270
00:14:26,032 --> 00:14:28,667
cuz数组由整数索引，从0开始

271
00:14:28,735 --> 00:14:32,170
并且上升到数组中的数量。

272
00:14:32,239 --> 00:14:37,643
现在还有其他更强大，更有能力的范围，

273
00:14:37,712 --> 00:14:41,113
像CountableRange。 CountableRange是

274
00:14:41,181 --> 00:14:43,916
就像一个范围，除了你可以计数

275
00:14:43,984 --> 00:14:47,485
开始和结束之间的中间值。

276
00:14:47,554 --> 00:14:50,856
好的，这就像一系列int CountableRange意味着

277
00:14:50,924 --> 00:14:54,092
开始点和终点，每个点。

278
00:14:54,160 --> 00:14:57,429
现在，当你跨越这个范围，这取决于什么

279
00:14:57,498 --> 00:15:00,565
类型是。跨越一系列的ints是不同的

280
00:15:00,634 --> 00:15:03,735
然后跨越一系列的浮标，或跨越

281
00:15:03,804 --> 00:15:06,471
一系列的字符串。那里有一点区别

282
00:15:06,539 --> 00:15:07,539
我们会在一分钟后再谈一谈。

283
00:15:08,809 --> 00:15:10,508
有一个特殊的语法

284
00:15:10,577 --> 00:15:15,581
做“dot dot than-than”或“dot dot dot”的范围。

285
00:15:15,649 --> 00:15:20,018
点点小于意味着你放开始索引和

286
00:15:20,087 --> 00:15:22,988
点的任一侧的结束索引小于。

287
00:15:23,056 --> 00:15:26,457
这意味着从起始索引到最终索引，

288
00:15:26,526 --> 00:15:29,428
但不包括最终索引，不包括它，

289
00:15:29,497 --> 00:15:32,731
点点包括两端。因此对于

290
00:15:32,800 --> 00:15:36,067
例如，在一个数组中，我们有一个四个数组的数组，

291
00:15:36,136 --> 00:15:39,370
a，b，c，d，让我们说我想要得到c和

292
00:15:39,439 --> 00:15:43,742
d出来，我可以说数组sub，（只是

293
00:15:43,811 --> 00:15:48,947
像我可以说阵列子5或阵列子3是第四个

294
00:15:49,015 --> 00:15:52,350
数组的索引），我也可以指定一个范围

295
00:15:52,419 --> 00:15:55,654
获取一个子数组，一个数组的片段，它被调用。所以

296
00:15:55,722 --> 00:15:59,290
我可以说2 ... 3，这意味着数组中的索引2，

297
00:15:59,359 --> 00:16:03,161
这是c，因为a是索引0，b是索引1，c是索引2，

298
00:16:03,230 --> 00:16:07,032
点点点索引3，这是d包含，它是点

299
00:16:07,101 --> 00:16:10,135
点点然后不到1将是排他的，

300
00:16:10,203 --> 00:16:13,672
所以这就是为什么d不包括在那个。所以

301
00:16:13,740 --> 00:16:16,508
看看我如何使用范围来获取数组的子切片，

302
00:16:16,577 --> 00:16:18,977
那很酷顺便一提，

303
00:16:19,046 --> 00:16:22,314
如果你说给我从6 ... 8的阵列，

304
00:16:22,382 --> 00:16:25,016
这将在运行时崩溃，并使用数组索引

305
00:16:25,085 --> 00:16:28,053
的边界，因为这个数组只有四个元素。所以

306
00:16:28,121 --> 00:16:32,824
只是因为我正在使用一个范围来访问这个下标

307
00:16:32,892 --> 00:16:35,827
而不是一个数字，它仍然必须在边界。

308
00:16:35,896 --> 00:16:38,797
然后如果我说数组[4 ... 1]

309
00:16:38,866 --> 00:16:42,233
这也将在运行时崩溃，因为范围

310
00:16:42,302 --> 00:16:44,970
要看看，说我不能创建一个范围

311
00:16:45,039 --> 00:16:47,272
其中起始值大于结束值，

312
00:16:47,341 --> 00:16:50,776
不能是向后的范围，这就是为什么这种类型

313
00:16:50,844 --> 00:16:53,278
int必须是可比的，当然你可以比较ints。

314
00:16:54,781 --> 00:16:59,718
有一件事非常重要的是要理解：一个字符串，

315
00:16:59,787 --> 00:17:04,089
字符串的子范围不是int的范围。

316
00:17:05,859 --> 00:17:08,093
你可能会认为是对的，我有这个字符串，

317
00:17:08,162 --> 00:17:10,629
100个字符，你可能认为字符串在15到40之间

318
00:17:10,697 --> 00:17:12,998
将是第40位的第15位。和

319
00:17:13,066 --> 00:17:17,068
它不是：一个字符串subrange是一个范围的string.index，

320
00:17:17,137 --> 00:17:18,971
这是一个不同的小数据类型，和

321
00:17:19,039 --> 00:17:20,806
我将在几张幻灯片中谈论这一切。

322
00:17:20,875 --> 00:17:23,541
但我只是想让它真的很清楚，

323
00:17:23,610 --> 00:17:27,846
有可能说字符串subrange start .. <end，

324
00:17:27,914 --> 00:17:31,716
但是start和end不是int，它们是string.indexes，

325
00:17:31,785 --> 00:17:35,587
我们将看看它是如何工作的。如果类型

326
00:17:35,656 --> 00:17:38,089
您创建的点数小于或小于点号

327
00:17:38,158 --> 00:17:41,793
点点，如果该类型是int，（实际上，

328
00:17:41,861 --> 00:17:44,863
如果它是int的话，那么它们可以用int来表示

329
00:17:44,932 --> 00:17:48,000
它不会浮动，但我没有真正的准备

330
00:17:48,068 --> 00:17:52,771
跟你谈谈strideable），但如果范围有

331
00:17:52,840 --> 00:17:57,008
ints在任一端，所以它的范围从2到7，为

332
00:17:57,077 --> 00:18:00,145
例如，那么它会自动创建可计数的范围，

333
00:18:00,214 --> 00:18:03,248
更有能力的范围。

334
00:18:03,317 --> 00:18:06,485
那个范围就会变成所谓的序列，而且

335
00:18:06,554 --> 00:18:10,188
可以遍历或枚举序列，

336
00:18:10,257 --> 00:18:14,726
你这样做的方式是与“for in”，所以Swift的

337
00:18:14,795 --> 00:18:19,430
声明，这是唯一的一个。它被称为

338
00:18:19,499 --> 00:18:24,069
“for in”，所有的意思是，我想去列举

339
00:18:24,138 --> 00:18:28,206
序列的所有值。我要谈谈什么

340
00:18:28,275 --> 00:18:31,009
可以排序的东西可数范围为1，

341
00:18:31,078 --> 00:18:33,044
因为如果一个int从0到7，而

342
00:18:33,113 --> 00:18:36,815
它是一个可数的范围，那么它可以去0，1，2，3，4，5，6，

343
00:18:36,884 --> 00:18:42,353
数组是其元素的序列，序列。

344
00:18:42,422 --> 00:18:45,591
所以你可以通过一个数组“for in”。词典也是，

345
00:18:45,659 --> 00:18:49,161
我们稍后会看到。所以这就是你的做法

346
00:18:49,230 --> 00:18:54,132
对于（i = 0; i <20; i ++），正常的C-like循环。

347
00:18:54,201 --> 00:18:56,901
你不能在Swift中做到这一点，语法根本就没有

348
00:18:56,970 --> 00:19:01,807
存在。相反，你会为我在0 .. <20，

349
00:19:01,875 --> 00:19:04,509
因为通知我说不到20，不小于或等于

350
00:19:04,578 --> 00:19:10,448
等于20，所以0 .. <20表示通过。所以

351
00:19:10,517 --> 00:19:12,984
那一小块代码将被执行一次

352
00:19:13,053 --> 00:19:17,155
0，1，2，3，4，一直到19号，所以

353
00:19:17,224 --> 00:19:19,057
这与你在那里看到的一样。

354
00:19:19,126 --> 00:19:21,860
现在怎么样？浮动有点奇怪。

355
00:19:21,929 --> 00:19:28,066
如果我想为{i = 0.5;我<= 15.25; i + = 0}。

356
00:19:28,135 --> 00:19:32,905
哇，我该怎么办？我不能，因为

357
00:19:32,973 --> 00:19:38,076
例如，说我在0.5 ... 15.25。

358
00:19:38,145 --> 00:19:42,447
怎么知道要走0.3？答案是，它没有。

359
00:19:42,516 --> 00:19:47,219
事实上，这样的范围，0.5 ... 15.25是不可数的

360
00:19:47,287 --> 00:19:50,923
范围，只是范围。它只知道开始和结束，

361
00:19:50,991 --> 00:19:53,725
所以它什么都不知道

362
00:19:53,794 --> 00:19:56,995
它不能是一个序列，它不能在过去。但

363
00:19:57,064 --> 00:20:01,567
幸运的是，这个伟大的全球功能叫做stride。

364
00:20:01,635 --> 00:20:04,636
步行从一个到一个或一个通过，

365
00:20:04,704 --> 00:20:06,939
（取决于你想通过到底，

366
00:20:07,008 --> 00:20:09,341
或者只是为了而不包括它），和

367
00:20:09,409 --> 00:20:11,476
一个，这是什么将要走。

368
00:20:11,545 --> 00:20:15,781
所以在这里，我说从0.5到15.25步长，

369
00:20:15,849 --> 00:20:19,351
因为我想要小于或等于0.3，和

370
00:20:19,419 --> 00:20:23,254
那将要创建一个新的对象，它是一个CountableRange。

371
00:20:23,323 --> 00:20:26,024
现在它是一个特殊的CountableRange，它知道

372
00:20:26,093 --> 00:20:30,261
如何通过0.3步计算从0.25到15.25。您

373
00:20:30,330 --> 00:20:32,797
不用担心它如何实现它，只是走了

374
00:20:32,866 --> 00:20:35,633
创建一个CountableRange。其实这将被称为

375
00:20:35,702 --> 00:20:39,204
一个ClosedCountableRange因为它计数到最后，

376
00:20:39,273 --> 00:20:42,374
所以它是一个点点点类型的点点范围

377
00:20:42,442 --> 00:20:45,978
小于范围。所以我有一个CountableRange，和

378
00:20:46,046 --> 00:20:49,648
这是一个序列，所以我可以在其中，所以我为我说。

379
00:20:49,717 --> 00:20:53,451
大步走，我可能会说f，甚至比f还好

380
00:20:53,520 --> 00:20:56,688
一世。很多次，顺便说一下，在我的幻灯片上，我会使用

381
00:20:56,756 --> 00:20:59,457
像i或x或d这样的变量，因为我想要它适合我的

382
00:20:59,526 --> 00:21:02,594
幻灯片，我不想让它包装。对你来说很难

383
00:21:02,663 --> 00:21:05,264
读取幻灯片，如果代码总是包围，所以 =

384
00:21:05,332 --> 00:21:07,799
只是因为你看到我使用我和d和f并不意味着

385
00:21:07,868 --> 00:21:10,401
这是许可证有这些可怕的名字

386
00:21:10,470 --> 00:21:14,773
你的变量你需要有意义的名字。所以

387
00:21:14,842 --> 00:21:16,274
这就是在这里的作品，

388
00:21:16,343 --> 00:21:18,076
因为步幅会返回一个CountableRange，

389
00:21:18,145 --> 00:21:20,779
在这种情况下为ClosedCountableRange。所以

390
00:21:20,848 --> 00:21:25,450
这就是你从C做循环的标准

391
00:21:25,518 --> 00:21:29,587
好的，我们来谈一谈Swift的数据结构。

392
00:21:29,656 --> 00:21:31,823
你已经了解了四个中的三个，

393
00:21:31,891 --> 00:21:37,296
它们是类，结构和枚举。在我们的讲座中，

394
00:21:37,365 --> 00:21:39,130
我们已经做了这三件事了。

395
00:21:39,199 --> 00:21:41,233
我们有一个类，这是我们的视图控制器子类。

396
00:21:41,302 --> 00:21:42,634
我们有一个结构，这是我们的计算器大脑。

397
00:21:42,703 --> 00:21:45,304
我们有枚举，这是我们的操作。

398
00:21:46,607 --> 00:21:49,407
第四个是协议，

399
00:21:49,476 --> 00:21:51,776
我不会在下周讨论这个问题

400
00:21:51,845 --> 00:21:54,446
甚至一周之后。协议是超级，重要的，

401
00:21:54,515 --> 00:21:56,314
我不想让它听起来像他们不重要，

402
00:21:56,383 --> 00:21:58,817
但是他们对你来说很新鲜，所以我会尝试一下

403
00:21:58,886 --> 00:22:01,119
放松你更熟悉的这些，

404
00:22:01,188 --> 00:22:03,855
虽然在Swift中可能不同于你所使用的

405
00:22:03,924 --> 00:22:06,258
他们还是比较熟悉的。

406
00:22:06,326 --> 00:22:09,594
我们来快速检查这三个结构，什么是

407
00:22:09,663 --> 00:22:13,665
他们相同和不同。那又怎么样？

408
00:22:13,733 --> 00:22:14,599
他们被宣布非常，

409
00:22:14,668 --> 00:22:16,601
非常相似：他们有不同的关键词，但是

410
00:22:16,670 --> 00:22:17,869
他们几乎完全一样。

411
00:22:17,938 --> 00:22:20,405
唯一的区别是真正的一个类可以指定一个超级

412
00:22:20,473 --> 00:22:23,675
类，否则声明完全一样。

413
00:22:23,744 --> 00:22:26,611
他们都可以拥有属性和功能，所以，

414
00:22:26,680 --> 00:22:30,015
他们都非常相似。唯一的事情在这里

415
00:22:30,084 --> 00:22:34,452
是在枚举中不能有任何存储的属性。

416
00:22:34,521 --> 00:22:37,956
枚举保留所有相关值中的数据，因此不能

417
00:22:38,025 --> 00:22:41,025
有任何存储的属性，但它可以计算

418
00:22:41,094 --> 00:22:44,930
属性，他们当然都可以有功能。

419
00:22:44,998 --> 00:22:47,532
另一件非常相似的事情是他们都可以

420
00:22:47,601 --> 00:22:50,001
除了枚举之外还有初始化器。枚举不需要

421
00:22:50,070 --> 00:22:52,571
一个初始化器，你只是说你想要的情况，但是

422
00:22:52,640 --> 00:22:56,441
结构和类有初始化器。可以，然后呢

423
00:22:56,510 --> 00:22:58,543
这是一样的现在有什么区别？

424
00:22:58,612 --> 00:23:01,880
当然，继承对于课堂来说是一个很大的区别。

425
00:23:01,948 --> 00:23:05,784
课程有继承。结构和枚举不。但

426
00:23:05,853 --> 00:23:08,820
最重要的区别是我上次提到的，

427
00:23:08,889 --> 00:23:12,857
结构和枚举是值类型，

428
00:23:12,926 --> 00:23:16,194
类是引用类型。所以让我们来谈谈

429
00:23:16,262 --> 00:23:18,096
关于它只是一点点。这很重要，我会

430
00:23:18,165 --> 00:23:22,534
再说一遍值类型，这是什么意思？

431
00:23:22,602 --> 00:23:26,404
这意味着当您作为参数传递它时，它被复制

432
00:23:26,473 --> 00:23:27,906
它被复制，即使你只是将它分配给另一个变量，

433
00:23:27,907 --> 00:23:29,340
到一个功能。

434
00:23:29,410 --> 00:23:33,445
它被复制。如果你把它分配给一个let，它是不可变的，

435
00:23:33,514 --> 00:23:36,314
这是非常重要的了解。如果你分配了

436
00:23:36,383 --> 00:23:40,785
一个值类型给let，使用let x等于该东西，

437
00:23:40,854 --> 00:23:44,155
你只是使它变得不可变，无论多么复杂。

438
00:23:44,224 --> 00:23:45,890
如果它是一个数组或字典，

439
00:23:45,959 --> 00:23:49,261
你不能添加任何元素。如果它是一个计算器，

440
00:23:49,329 --> 00:23:52,130
这意味着你不能调用其任何可变功能

441
00:23:52,199 --> 00:23:55,800
你不能对它执行操作。现在在任务二，

442
00:23:55,869 --> 00:23:58,704
我会给你添加一个计算器大脑的方法

443
00:23:58,772 --> 00:24:01,539
那就是让你使用计算器的大脑

444
00:24:01,608 --> 00:24:04,843
不可改变，这很酷。你还不会

445
00:24:04,912 --> 00:24:07,545
能够执行操作，但你可以做某事

446
00:24:07,614 --> 00:24:12,350
非常重要，不可磨灭。现在因为这样，这种

447
00:24:12,419 --> 00:24:15,487
值类型的版权行为，你必须，

448
00:24:15,556 --> 00:24:18,957
当然，标记所有的功能

449
00:24:19,026 --> 00:24:23,094
修改它作为变异。这就是Swift知道的，

450
00:24:23,163 --> 00:24:27,299
“哎呀，我必须复制一份这个真实的副本，

451
00:24:27,368 --> 00:24:31,135
如果有人写信给它“，现在参考类很漂亮

452
00:24:31,204 --> 00:24:34,639
不同之处在于它被存储在某处的堆中

453
00:24:34,708 --> 00:24:37,909
指向它，当你传递给它

454
00:24:37,978 --> 00:24:41,713
一个函数或将其分配给另一个变量或某个东西

455
00:24:41,782 --> 00:24:46,618
像这样，你只是传递一个指针。

456
00:24:46,687 --> 00:24:51,089
现在，顺便说一下，当你说，let x等于参考类型，

457
00:24:51,158 --> 00:24:54,626
你仍然可以发送它将会变异的消息。

458
00:24:55,996 --> 00:24:58,764
你所说的是指针不能改变，但是

459
00:24:58,833 --> 00:25:01,533
它指向什么可以永远改变。

460
00:25:01,601 --> 00:25:05,137
现在参考类型是你习惯的。

461
00:25:05,205 --> 00:25:08,974
大多数语言都有面向对象的参考

462
00:25:09,043 --> 00:25:15,213
类型。参考类型是一点点野西 - 我

463
00:25:15,282 --> 00:25:17,816
没有时间教你这个，希望你能看看

464
00:25:17,885 --> 00:25:19,651
在某个时候你在斯坦福大学的职业生涯，但是

465
00:25:19,720 --> 00:25:21,820
有一种不同的编程思路

466
00:25:21,888 --> 00:25:23,988
比你习惯的：它被称为功能编程。

467
00:25:24,057 --> 00:25:25,089
有多少人听过这个短语，

468
00:25:25,158 --> 00:25:29,227
功能编程？所以大约一半你这个想法

469
00:25:29,296 --> 00:25:31,663
的功能编程是：你不想要这个狂野的西部

470
00:25:31,732 --> 00:25:34,599
你有多个人指着这些对象

471
00:25:34,668 --> 00:25:37,936
在他们身上，任何一个人都可以随时修改它。

472
00:25:38,004 --> 00:25:41,105
这让你在验证中遇到很多困难

473
00:25:41,174 --> 00:25:42,975
你的程序的正确性。

474
00:25:43,043 --> 00:25:46,278
而如果你有很多不可变的对象，

475
00:25:46,346 --> 00:25:49,715
你知道他们不能改变，他们的API基本上是

476
00:25:49,783 --> 00:25:52,718
像数学进入的数学函数

477
00:25:52,786 --> 00:25:55,520
可预测的数据出来，因为有

478
00:25:55,588 --> 00:25:59,291
不是所有这些副作用，数据影响的其他对象

479
00:25:59,359 --> 00:26:02,194
所有这些都指着别人。

480
00:26:02,262 --> 00:26:04,595
这是一个非常好的小东西。

481
00:26:04,664 --> 00:26:08,433
现在，iOS不是开发函数式编程的

482
00:26:08,502 --> 00:26:11,603
在所有但发明了Swift的人，

483
00:26:11,671 --> 00:26:15,074
他们正在考虑函数式编程，所以

484
00:26:15,142 --> 00:26:17,009
你可以混合很多元素

485
00:26:17,077 --> 00:26:19,244
功能编程到您的应用程序，

486
00:26:19,312 --> 00:26:22,080
如果您正在构建iOS应用程序。现在这是一个新的

487
00:26:22,149 --> 00:26:26,051
在iOS的前沿，因为不了20年，

488
00:26:26,119 --> 00:26:28,120
真的，或30年，真的，如果你一直考虑

489
00:26:28,188 --> 00:26:31,723
回到引发iOS技术的发明，

490
00:26:31,792 --> 00:26:36,028
人们已经基本上编程了

491
00:26:36,096 --> 00:26:39,831
参考类型仅用于其面向对象。

492
00:26:39,900 --> 00:26:42,534
但是当你用结构体(structs)和

493
00:26:42,603 --> 00:26:46,104
枚举(enums)，特别是当你抛出协议时，(我

494
00:26:46,173 --> 00:26:47,939
告诉你我会告诉你，这是非常重要的，但是

495
00:26:48,008 --> 00:26:51,843
我不能向你解释，和泛型），

496
00:26:51,912 --> 00:26:54,579
当你开始把这些东西都放在那里的时候，你可以

497
00:26:54,648 --> 00:26:58,216
做真正的功能编程真的做得很好。

498
00:26:58,285 --> 00:27:02,153
所有的Swift基金会都是真正设计的

499
00:27:02,222 --> 00:27:06,057
的功能性编程。如果你真的想要

500
00:27:06,126 --> 00:27:09,962
看到一个很好的例子，如何应用这种不变性

501
00:27:10,030 --> 00:27:13,698
和泛型，协议和所有要构建的东西

502
00:27:13,767 --> 00:27:16,968
一个建筑，追逐所有的事情

503
00:27:17,037 --> 00:27:21,006
在基础库中进行：字符串和范围

504
00:27:21,075 --> 00:27:24,075
所有这些事情记住，我说的话

505
00:27:24,144 --> 00:27:26,878
范围是一个序列，或者这个东西是可比的，

506
00:27:26,947 --> 00:27:29,414
记得我怎么说这样的话？好的，好吧

507
00:27:29,483 --> 00:27:32,483
你怎么表达呢？你使用协议，

508
00:27:32,552 --> 00:27:37,822
与这些不变的类型，这是不可变的和

509
00:27:37,891 --> 00:27:41,593
使用泛型。所以我不能解释一切，

510
00:27:41,662 --> 00:27:44,362
我已经花了太多的时间，而不是我平安

511
00:27:44,431 --> 00:27:45,964
在今天的讲座中谈论它，但是就这样

512
00:27:46,033 --> 00:27:49,601
你知道，编程的巨大优势在于

513
00:27:49,669 --> 00:27:52,504
不同的方式它需要一个真正的心态变化。

514
00:27:52,572 --> 00:27:55,440
所以希望你会参加一个课程，也许整个

515
00:27:55,509 --> 00:27:56,641
类是函数式编程，

516
00:27:56,710 --> 00:27:58,110
真的，你会得到它的感觉。

517
00:27:58,179 --> 00:28:00,245
Swift做了很好的支持

518
00:28:00,313 --> 00:28:04,849
你需要做的基本面。那很好

519
00:28:04,918 --> 00:28:08,086
你选择的长风答案。如果你是

520
00:28:08,154 --> 00:28:10,756
做更多的功能性方法，即使你在做

521
00:28:10,824 --> 00:28:13,692
一个基于参考的方法，像你以前习惯的，尝试

522
00:28:13,760 --> 00:28:16,361
倾向于不变性，尝试问自己，

523
00:28:16,430 --> 00:28:21,299
这件事可以做到吗？有没有

524
00:28:21,368 --> 00:28:24,169
我的程序中的功能，我可以通过创建共享

525
00:28:24,238 --> 00:28:29,107
一个通用的，例如。至少这些倾向

526
00:28:29,176 --> 00:28:31,376
可能会帮助您构建更可测试的应用程序，

527
00:28:31,445 --> 00:28:32,777
因为写一个测试很容易

528
00:28:32,846 --> 00:28:34,646
这就像一个数学函数

529
00:28:34,715 --> 00:28:36,515
你知道数据应该是一样的

530
00:28:36,584 --> 00:28:38,817
数据，而不是它的东西

531
00:28:38,886 --> 00:28:40,919
很多数据，你必须设置一切。设置这个，

532
00:28:40,988 --> 00:28:43,688
设置这个和这个和这个，现在调用方法，

533
00:28:43,757 --> 00:28:47,925
这很难写出测试用例等。

534
00:28:47,994 --> 00:28:50,428
这就是价值和参考。我们来谈谈一点

535
00:28:50,497 --> 00:28:52,664
方法的语法。我要快点走了。

536
00:28:52,732 --> 00:28:54,366
希望大家都明白这一点。

537
00:28:54,435 --> 00:28:57,168
所有参数名称都有外部名称和内部名称

538
00:28:57,237 --> 00:29:01,640
名。内部名称用于定义内，或

539
00:29:01,709 --> 00:29:04,276
内部实现的功能。

540
00:29:04,345 --> 00:29:06,878
所以这里我有这两个功能，foo和bar。酒吧

541
00:29:06,947 --> 00:29:11,416
调用foo。所以你可以看到在foo的实现中，

542
00:29:11,484 --> 00:29:14,820
它正在使用第一和第二，而酒吧，

543
00:29:14,889 --> 00:29:17,923
当bar调用foo时，它会使用外部的第一个和

544
00:29:17,991 --> 00:29:22,694
外部第二，作为项目的名称。而且你知道

545
00:29:22,763 --> 00:29:25,430
你可以放下一个酒吧，使它没有

546
00:29:25,499 --> 00:29:30,068
外部名称。我们只做99.99％的时间

547
00:29:30,137 --> 00:29:34,039
第一个项目。为什么这样做呢？因为有时候这个名字

548
00:29:34,107 --> 00:29:38,743
的方法和/或第一个参数的类型是

549
00:29:38,812 --> 00:29:41,780
足以说明这件事应该是什么，

550
00:29:41,849 --> 00:29:43,849
所以我们不需要放一个外部名字。

551
00:29:43,917 --> 00:29:45,683
有点清楚所有其他参数，

552
00:29:45,752 --> 00:29:48,786
我们没有方法名称的优点

553
00:29:48,855 --> 00:29:51,823
那里。所以这就是为什么我们几乎从来没有放下吧

554
00:29:51,892 --> 00:29:56,294
后来的。顺便说一句，如果你只放一个

555
00:29:56,363 --> 00:30:00,031
参数名称，那就是外部名称和

556
00:30:00,100 --> 00:30:03,468
内部名称，这并不罕见，

557
00:30:03,537 --> 00:30:07,306
你会偶尔做的。好吧，所以你知道

558
00:30:07,374 --> 00:30:12,344
那。当涉及到覆盖，子类化，in

559
00:30:12,413 --> 00:30:15,747
引用类型和类，当你覆盖，你必须

560
00:30:15,816 --> 00:30:19,584
明确地让Swift知道你知道你这样做。

561
00:30:19,653 --> 00:30:21,753
你可以通过放置override关键字来实现。

562
00:30:21,822 --> 00:30:25,823
所以如果你从你的父类覆盖一个方法

563
00:30:25,892 --> 00:30:29,728
说覆盖func什么。您可以标记方法或

564
00:30:29,797 --> 00:30:33,732
甚至是一个全班的决赛，这意味着它不可能

565
00:30:33,801 --> 00:30:38,269
被覆盖的子类将不被允许覆盖它。

566
00:30:38,338 --> 00:30:42,841
大多数语言都有。现在关于方法的话题。

567
00:30:44,345 --> 00:30:48,447
你已经看到，实际上你已经看到了，但大多是看到的

568
00:30:48,516 --> 00:30:51,984
理解的实例方法。这些是方法，

569
00:30:52,052 --> 00:30:56,255
或vars，它们被发送到该类的一个实例

570
00:30:56,323 --> 00:31:00,058
结构或枚举。换句话说，其中之一。

571
00:31:00,127 --> 00:31:04,429
像我创造的其中之一：我创造了一个double的15.5，

572
00:31:04,498 --> 00:31:07,466
我有一个，我可以发信息。

573
00:31:07,534 --> 00:31:11,503
但类型，类型double，类型强度，

574
00:31:11,571 --> 00:31:15,808
类型计算器大脑，他们也可以有方法和

575
00:31:15,876 --> 00:31:21,279
vars。计算的变量，没有存储，但计算的vars。

576
00:31:21,348 --> 00:31:25,017
所有你添加一个方法或一个var类型是

577
00:31:25,085 --> 00:31:27,385
你把静态放在声明前。

578
00:31:27,454 --> 00:31:30,722
所以“static func whatever”意味着这是一个功能

579
00:31:30,791 --> 00:31:34,726
类型，而不是类型的实例，对类型本身。

580
00:31:34,795 --> 00:31:37,762
例如，让我们在这里考虑一下double。

581
00:31:37,831 --> 00:31:43,502
Double实际上有很多静态或类型方法

582
00:31:43,571 --> 00:31:47,773
vars。通过发送消息来访问它们

583
00:31:47,841 --> 00:31:51,242
double的word，l D-O-U-B-L-E。您

584
00:31:51,311 --> 00:31:54,012
不要发送到一个实例，你发送到该单词。和

585
00:31:54,080 --> 00:31:57,715
你已经看到至少有一个，这是pi。

586
00:31:57,784 --> 00:32:00,753
记住我们说Double.pi，我们得到pi的价值？

587
00:32:00,821 --> 00:32:05,790
Pi是一个var，一个计算的var，在类或

588
00:32:05,859 --> 00:32:09,594
结构实际上是double的，但也有其他的方法，

589
00:32:09,663 --> 00:32:12,564
像abs。 Abs(绝对值) double的值

590
00:32:12,633 --> 00:32:16,701
返回它的绝对值。那就是类型。

591
00:32:16,770 --> 00:32:21,039
你说Double.abs，Double.pi。相反，例如，

592
00:32:21,108 --> 00:32:23,375
如果我有一个double，就像x等于23.85。

593
00:32:23,444 --> 00:32:27,379
所以x现在是double的。我不能说x Double.pi

594
00:32:29,149 --> 00:32:31,950
x是double的一个实例。你看到差异？

595
00:32:32,019 --> 00:32:34,787
我们看到x.pi，试图发送pi

596
00:32:34,855 --> 00:32:38,157
到一个实例，而不是将pi发送到double类型。

597
00:32:39,593 --> 00:32:42,460
那么我们用这些类型的方法呢？

598
00:32:42,529 --> 00:32:45,263
那么，我们无法访问任何实例变量，因为

599
00:32:45,332 --> 00:32:47,032
我们不会将它们发送到一个实例。

600
00:32:47,100 --> 00:32:51,035
我们主要使用它们的实用方法，这样的东西。

601
00:32:51,104 --> 00:32:55,640
像pi这样的常数就是一个很好的例子。事情

602
00:32:55,709 --> 00:32:59,177
一种是与这种类型相关联的函数

603
00:32:59,246 --> 00:33:00,846
不属于特定实例或

604
00:33:00,914 --> 00:33:03,882
不会真的在一个实例上操作。例如，

605
00:33:03,951 --> 00:33:06,885
你可能有一个实例方法或

606
00:33:06,954 --> 00:33:10,856
甚至一个实例var称为abs，ABS，没有参数，

607
00:33:10,925 --> 00:33:12,624
你会发送到一个实例，这将需要

608
00:33:12,693 --> 00:33:16,160
你发送给你的东西的绝对价值。但

609
00:33:16,229 --> 00:33:19,030
当然，类型一个必须有一个参数，因为

610
00:33:19,099 --> 00:33:20,265
你将它发送到double类型，

611
00:33:20,334 --> 00:33:21,699
所以没有double参与。

612
00:33:21,768 --> 00:33:25,904
没有涉及的double实例。每个人都得到

613
00:33:25,972 --> 00:33:30,909
那？好的：属性。你知道所有关于属性。

614
00:33:30,978 --> 00:33:33,779
我们看到了计算的属性，如显示值

615
00:33:33,847 --> 00:33:36,314
我们的计算器其实真的很酷

616
00:33:36,383 --> 00:33:39,717
属性功能。最有趣的一个是

617
00:33:39,786 --> 00:33:43,155
财产观察员。什么是物业观察者？

618
00:33:43,223 --> 00:33:45,891
属性观察者是一小段代码

619
00:33:45,959 --> 00:33:49,028
当您的财产变更时，将会执行。

620
00:33:51,065 --> 00:33:53,498
任何时候，您的属性只会改变一小段代码

621
00:33:53,567 --> 00:33:56,134
可以执行现在你可以找到

622
00:33:56,203 --> 00:33:58,403
在您的属性更改之前。要么

623
00:33:58,471 --> 00:34:00,438
您可以在属性更改后找到。

624
00:34:00,507 --> 00:34:03,208
或两者。和你这样做的方式，这适用于

625
00:34:03,276 --> 00:34:06,378
您的存储属性，如userIs InTheMiddleOfTyping：

626
00:34:06,447 --> 00:34:08,246
我们可以把一个属性观察员放在那里

627
00:34:08,315 --> 00:34:12,183
每次我们改变一些代码时都执行一些代码它也有效

628
00:34:12,252 --> 00:34:15,654
对于继承的属性，所以如果你继承的东西

629
00:34:15,723 --> 00:34:19,691
从你的父类，你可以把这些属性和

630
00:34:19,760 --> 00:34:24,730
注意到它改变了。顺便说一句，如果你有一个属性

631
00:34:24,798 --> 00:34:28,934
它是一个值类型，（一个结构体或

632
00:34:29,003 --> 00:34:31,769
某些东西，像数组或字典），这个属性

633
00:34:31,838 --> 00:34:34,639
如果事情发生变化，观察员将会发生，

634
00:34:34,708 --> 00:34:37,709
如果它变异所以如果你添加一些数组，

635
00:34:37,777 --> 00:34:40,112
房地产观察家将会踢进来说，

636
00:34:40,181 --> 00:34:43,081
“改了”。这些属性观察员如何？

637
00:34:43,149 --> 00:34:46,318
工作？他们看起来很像计算的属性。记得

638
00:34:46,386 --> 00:34:48,286
计算的属性displayValue已经得到和

639
00:34:48,355 --> 00:34:50,656
那么我们有一些代码，然后我们已经设置了

640
00:34:50,724 --> 00:34:53,057
我们有一些代码？这是类似的，除了

641
00:34:53,126 --> 00:34:57,329
得到和设置它将设置，或设置。

642
00:34:59,566 --> 00:35:01,332
顺便说一句，你可能永远不会（我甚至不知道

643
00:35:01,401 --> 00:35:04,236
你可以）在计算属性中使用它，因为

644
00:35:04,304 --> 00:35:06,004
你有这样的set子句

645
00:35:06,073 --> 00:35:07,339
你可以把它放在一起。

646
00:35:07,407 --> 00:35:10,409
你不需要知道什么时候设置，因为你设置

647
00:35:10,477 --> 00:35:13,311
它。但是对于存储的属性和继承的属性，

648
00:35:13,380 --> 00:35:15,880
这是有道理的，所以你会有意志。

649
00:35:15,949 --> 00:35:18,683
现在，willSet，首先你把它放在一个卷曲

650
00:35:18,752 --> 00:35:21,853
属性之后的大括号就像你在做的一样

651
00:35:21,922 --> 00:35:23,922
一个计算属性，但这不是一个计算属性，

652
00:35:23,991 --> 00:35:25,757
只是添加一个大括号不会使其计算

653
00:35:25,826 --> 00:35:29,494
属性，你必须放在或放在那里，但是，

654
00:35:29,563 --> 00:35:33,031
如果我把willSet，那么在里面的代码里，

655
00:35:33,100 --> 00:35:35,534
有一个特殊的变量就像集合中的那样

656
00:35:35,603 --> 00:35:38,270
计算机属性的情况，称为newValue，和

657
00:35:38,338 --> 00:35:42,073
那就是这个东西的价值。

658
00:35:42,142 --> 00:35:44,309
还没有设置一些属性，

659
00:35:44,378 --> 00:35:46,811
看到一些存储的属性在那里？还没有

660
00:35:46,880 --> 00:35:49,914
被设置为newValue但它将是。然后didSet，

661
00:35:49,983 --> 00:35:52,917
该代码发生在某些属性设置后

662
00:35:52,986 --> 00:35:55,720
那里的特殊变量是oldValue。

663
00:35:55,789 --> 00:35:58,456
这是它在设定之前所拥有的价值。所以

664
00:35:58,525 --> 00:36:01,159
你可以比较它们是否改变了

665
00:36:01,228 --> 00:36:05,864
例。那么我们在哪里使用这些东西？

666
00:36:05,932 --> 00:36:08,734
可能我们使用它们的第一个地方在我们的

667
00:36:08,803 --> 00:36:14,205
控制器在视野中。假设我是一个按钮

668
00:36:14,274 --> 00:36:16,941
我的背景颜色变化。我继承了我的背景颜色

669
00:36:17,010 --> 00:36:21,413
从我的超级类，UI视图。连上父类。

670
00:36:21,482 --> 00:36:22,847
每次背景颜色发生变化时，

671
00:36:22,916 --> 00:36:25,116
该按钮想要自己重绘

672
00:36:25,185 --> 00:36:29,688
它会有var背景颜色是一个UI颜色，

673
00:36:29,757 --> 00:36:32,791
打开卷曲大括号，didSet打开卷曲大括号

674
00:36:32,860 --> 00:36:38,630
画我自己封闭的大括号。题？好的，

675
00:36:38,699 --> 00:36:41,599
所以问题是，如果有人更改一些存储的属性

676
00:36:41,668 --> 00:36:44,502
在那里，我负责做一些事情

677
00:36:44,571 --> 00:36:46,572
在willSet或didSet？我必须实际设置吗？和

678
00:36:46,640 --> 00:36:48,807
答案是不。好的，那是在别的地方。

679
00:36:48,875 --> 00:36:50,675
你只是有机会运行一些其他代码

680
00:36:50,744 --> 00:36:53,145
你想在之前运行，就在它发生之后。

681
00:36:53,213 --> 00:36:55,547
但您不负责设置实际值。

682
00:36:55,616 --> 00:36:57,716
这是为你做的这就是为什么你得到

683
00:36:57,784 --> 00:37:02,420
看看其中的两个旧价值和新价值。

684
00:37:02,489 --> 00:37:05,323
所以下一周我们来看看，我们开始画画

685
00:37:05,392 --> 00:37:08,126
屏幕，我们将会看到物业变化

686
00:37:08,194 --> 00:37:14,166
我们可以让自己重画。接下来，懒加载(lazy)的属性。

687
00:37:14,235 --> 00:37:19,938
懒惰初始化是一个非常强大的工具。

688
00:37:20,006 --> 00:37:23,975
这将会让你从这个课程中获得很多的约束力。

689
00:37:24,044 --> 00:37:27,679
这是什么意思？一个lazy的var，一个var

690
00:37:27,748 --> 00:37:32,884
你说lazy在前面，不管它是等于，

691
00:37:32,953 --> 00:37:36,688
有人访问实际上并不会发生这个等于

692
00:37:36,757 --> 00:37:41,593
那个var直到有人要求该值的值，

693
00:37:41,662 --> 00:37:45,030
它实际上并没有在那里进行初始化。

694
00:37:45,098 --> 00:37:46,698
它不这样做是平等的。

695
00:37:46,767 --> 00:37:48,199
所以这很懒。正在等待

696
00:37:48,268 --> 00:37:51,136
现在为什么要懒惰(lazy)？那么一个明显的原因

697
00:37:51,205 --> 00:37:53,772
就像这里lazy var brain等于calculator

698
00:37:53,840 --> 00:37:56,307
brain，如果计算器的大脑真的很贵

699
00:37:56,376 --> 00:37:58,843
创建。如果它打开网络连接怎么办？

700
00:37:58,912 --> 00:38:01,379
我们将与互联网共享计算

701
00:38:01,448 --> 00:38:02,413
或者什么，你知道我的意思，

702
00:38:02,482 --> 00:38:04,149
做一些昂贵的事情

703
00:38:04,218 --> 00:38:05,083
嗯，你不想这样做，

704
00:38:05,151 --> 00:38:08,253
除非有人试图进入大脑，

705
00:38:08,321 --> 00:38:10,922
叫做设置操作数就可以了。那你会的

706
00:38:10,991 --> 00:38:12,424
想要实际做的工作来创造它。

707
00:38:12,493 --> 00:38:14,493
好的，所以有一个理由是懒惰，

708
00:38:14,562 --> 00:38:17,128
但事实并非如此重要

709
00:38:17,197 --> 00:38:21,500
一个是延迟昂贵的操作。但

710
00:38:21,569 --> 00:38:25,236
还有什么理由呢？那么，在Swift，

711
00:38:25,305 --> 00:38:30,275
所有的var必须被初始化。还记得吗

712
00:38:30,343 --> 00:38:32,143
记住我们添加了userIsInTheMiddleOfTyping。

713
00:38:32,212 --> 00:38:34,579
我们没有说，等于false。我们收到一个错误。

714
00:38:34,648 --> 00:38:38,116
它说我们没有初始化，因为我们没有初始化

715
00:38:38,184 --> 00:38:42,921
那。不仅他们都必须被初始化，而且

716
00:38:42,989 --> 00:38:45,457
他们都必须在你甚至可以发送之前进行初始化

717
00:38:45,525 --> 00:38:50,095
一个消息给该类，甚至在内部。所以

718
00:38:50,163 --> 00:38:52,697
你完全不能调用任何你自己的方法

719
00:38:52,766 --> 00:38:55,834
初始化你自己如果你想要的一件事情怎么办？

720
00:38:55,902 --> 00:39:02,040
初始化需要调用自己的方法？它的

721
00:39:02,109 --> 00:39:05,243
不可能。因为如果你需要初始化一些东西

722
00:39:05,312 --> 00:39:07,045
被允许发送消息给自己，你需要

723
00:39:07,114 --> 00:39:09,047
发送消息给你自己初始化一些东西，

724
00:39:09,116 --> 00:39:12,751
这是一个僵局你不能这样做好的，懒得让我们吧

725
00:39:12,820 --> 00:39:16,221
做到这一点因为你可以说，例如最后一个;

726
00:39:16,290 --> 00:39:20,925
懒惰我的属性等于我自己的一些方法。这不是

727
00:39:20,994 --> 00:39:24,896
直到有人说我的属性和

728
00:39:24,965 --> 00:39:27,733
没有人被允许访问我的属性，直到我完全

729
00:39:27,801 --> 00:39:32,437
初始化。所以根据定义，没有办法

730
00:39:32,506 --> 00:39:35,440
那将要尝试初始化，直到我已经

731
00:39:35,508 --> 00:39:40,011
完全初始化然而这个懒惰的事情就是这样的

732
00:39:40,080 --> 00:39:46,284
事情已被初始化所以这是很大的漏洞。

733
00:39:46,353 --> 00:39:49,554
Lazy var myProperty计数为已初始化

734
00:39:49,623 --> 00:39:51,389
即使它还没有。因为它在等待

735
00:39:51,458 --> 00:39:55,393
实际访问myProperty的东西。但它值得

736
00:39:55,462 --> 00:39:58,263
这个规则的目的，所以现在有人来了

737
00:39:58,332 --> 00:40:00,331
并访问它，现在我们可以调用这个方法。所以

738
00:40:00,400 --> 00:40:03,101
你会看到如何推迟这个方法的调用

739
00:40:03,169 --> 00:40:05,804
为了初始化这个命令，我们可以绕过这个要求

740
00:40:05,873 --> 00:40:08,173
一切都被初始化了

741
00:40:08,241 --> 00:40:10,309
真的很棘手然后中间那里，

742
00:40:10,377 --> 00:40:13,979
一些属性，这是超级棘手。因为你能

743
00:40:14,048 --> 00:40:17,216
实际上有一个关闭，（记住关闭是什么，

744
00:40:17,284 --> 00:40:19,284
从计算器大脑，这只是一个功能，

745
00:40:19,352 --> 00:40:22,488
在线功能），您实际上可以有一个关闭

746
00:40:22,556 --> 00:40:26,090
初步化你的东西懒惰。你所做的就是你

747
00:40:26,159 --> 00:40:28,493
把关闭，打开大括号，关闭大括号。

748
00:40:28,562 --> 00:40:31,796
显然必须返回一些类型的东西

749
00:40:31,865 --> 00:40:35,233
的酒吧。然后只是放开小圆括号，

750
00:40:35,302 --> 00:40:38,237
最后的圆括号。当我们打开括号和

751
00:40:38,305 --> 00:40:39,438
关闭结束时的圆括号，

752
00:40:39,507 --> 00:40:42,674
这意味着现在执行这个关闭。但

753
00:40:42,742 --> 00:40:45,611
现在不会执行，这样做会很懒惰

754
00:40:45,679 --> 00:40:50,381
它会发生在后面。这意味着那个关闭

755
00:40:50,450 --> 00:40:53,919
里面可以引用自我。因为自己会充分

756
00:40:53,988 --> 00:40:56,154
在这个关闭被执行的时候被初始化，

757
00:40:56,223 --> 00:41:00,058
因为它是懒惰执行。所以

758
00:41:00,127 --> 00:41:02,694
懒惰会让你从一些这些棘手的门票中脱颖而出，

759
00:41:02,762 --> 00:41:04,963
因为当你看到我谈论初始化时，

760
00:41:05,032 --> 00:41:08,333
你会像，“我不想这样做，永远”。

761
00:41:08,402 --> 00:41:09,701
你会尝试避免它，

762
00:41:09,770 --> 00:41:12,704
这是避免这种情况的好方法。嗯是的，

763
00:41:12,773 --> 00:41:18,810
它仍然满足所有这些事情。好吧，对阵。

764
00:41:18,879 --> 00:41:21,079
每个人都知道一个数组。大家知道什么

765
00:41:21,148 --> 00:41:23,549
一个通用的数组是。您只是在声明数组时，

766
00:41:23,617 --> 00:41:25,517
你必须说什么类型的事情会发生

767
00:41:25,585 --> 00:41:28,553
在阵列中。虽然有不同的语法，

768
00:41:28,622 --> 00:41:32,724
当我在演示中做字典时，我没有介绍。

769
00:41:32,793 --> 00:41:36,428
但是你可以声明一个数组，这两个黄色的东西

770
00:41:36,497 --> 00:41:38,696
那里有完全一样的事情。所以，

771
00:41:38,765 --> 00:41:39,464
开方括号，

772
00:41:39,533 --> 00:41:41,934
字符串的近方括号与说完全相同

773
00:41:42,002 --> 00:41:45,537
阵列角括弧串。这只是一个特别的

774
00:41:45,606 --> 00:41:48,873
方式来声明一个数组，它实际上似乎是

775
00:41:48,942 --> 00:41:51,443
首选方式。我其实更喜欢另一种方式，因为

776
00:41:51,512 --> 00:41:54,079
这是一个更清楚的你正在学习这是

777
00:41:54,148 --> 00:41:57,182
一个数组，因为它表示数组和字符串。

778
00:41:57,251 --> 00:41:59,918
但是打开方括号，方括号，

779
00:41:59,986 --> 00:42:02,187
我们知道这将被索引到数组中

780
00:42:02,256 --> 00:42:03,722
它看起来有点阵列，但是

781
00:42:03,790 --> 00:42:08,594
只是习惯了它。 [String]表示字符串数组。

782
00:42:08,662 --> 00:42:11,997
这是S的声明和它的名字

783
00:42:12,066 --> 00:42:16,635
键入字符串数组。所以如果我在这里有一个字符串像

784
00:42:16,704 --> 00:42:21,106
这只长颈鹿，牛，小狗和鸟。这里有四只动物，

785
00:42:21,175 --> 00:42:24,475
四弦和我说动物点鸵鸟，

786
00:42:24,544 --> 00:42:28,147
很好的追加附加一些东西到阵列，现在的事情

787
00:42:28,215 --> 00:42:30,616
你附加的显然是一样的

788
00:42:30,684 --> 00:42:33,218
作为数组中的所有内容的类型，但是类型

789
00:42:33,286 --> 00:42:36,955
被宣布请注意，动物被推断。

790
00:42:37,024 --> 00:42:40,225
由Swift，成为一个字符串数组。因为Swift看到

791
00:42:40,294 --> 00:42:42,126
你把它发送到一系列的东西和

792
00:42:42,195 --> 00:42:44,096
它看着所有的东西，他们都是字符串。

793
00:42:44,164 --> 00:42:46,965
所以说，动物必须是一串弦。现在，

794
00:42:47,033 --> 00:42:50,335
这行代码animals.append（“鸵鸟”）。

795
00:42:50,403 --> 00:42:51,036
这非常糟糕。

796
00:42:51,104 --> 00:42:53,004
任何人都可以告诉我为什么不会工作？

797
00:42:53,073 --> 00:43:02,247
是吗？ >>这是对的

798
00:43:02,316 --> 00:43:06,485
我们用let定义这个动物的变量，所以

799
00:43:06,554 --> 00:43:09,888
这是不可变的所以当我们说附加一只鸵鸟

800
00:43:09,956 --> 00:43:13,025
这是一个不可改变的事情，它会使我的程序崩溃。

801
00:43:13,093 --> 00:43:15,027
但实际上，甚至不会使我的程序崩溃。

802
00:43:15,095 --> 00:43:15,727
它甚至不会编译。

803
00:43:15,796 --> 00:43:17,796
喜欢，Swift编译器只是说，没办法，

804
00:43:17,865 --> 00:43:19,865
你不能做附加的东西或其他。

805
00:43:19,934 --> 00:43:22,467
那么那是一个很好的那个，你得到了。

806
00:43:22,536 --> 00:43:24,336
这个怎么样？我会给你第二次机会

807
00:43:24,405 --> 00:43:27,139
大家。为什么这个没有好处？好的，

808
00:43:27,208 --> 00:43:31,477
我试图在那里得到动物[4]，为什么？没有人？

809
00:43:31,545 --> 00:43:38,717
这个更简单数组索引，是的！数组索引是

810
00:43:38,786 --> 00:43:42,553
超出范围，因为数组从零开始编入索引。

811
00:43:42,622 --> 00:43:45,357
好吧，所以长颈鹿，牛，小狗，小鸟是零，一，二和

812
00:43:45,425 --> 00:43:48,727
三。所以如果我说，给我阵列四，巴姆，

813
00:43:48,795 --> 00:43:53,165
坠毁了我的程序数组索引。

814
00:43:53,234 --> 00:43:57,669
我们来讨论数组是一个序列的事实。

815
00:43:57,738 --> 00:44:00,872
数组实际上是一个集合，集合是序列。

816
00:44:00,941 --> 00:44:05,577
一个序列意味着我可以做到这一点。所以如果我说

817
00:44:05,646 --> 00:44:09,348
动物在动物中，我的小循环将被执行

818
00:44:09,416 --> 00:44:12,651
四次，一次与动物长颈鹿，下一个与

819
00:44:12,720 --> 00:44:14,586
动物是牛，下一个动物是小狗，

820
00:44:14,655 --> 00:44:19,791
下一只动物是鸟。好的，那真是太棒了

821
00:44:19,860 --> 00:44:23,562
特征。记住，这是唯一的四个在迅速。

822
00:44:23,631 --> 00:44:31,069
在那里，那是唯一的，没有别的。

823
00:44:31,138 --> 00:44:36,107
所以排列在很多班级的指导下

824
00:44:36,176 --> 00:44:38,376
在iOS中有一些有趣的方法

825
00:44:38,445 --> 00:44:43,648
有参数是闭包的。所以我教闭包

826
00:44:43,717 --> 00:44:45,851
在本学期开始的时候，

827
00:44:45,919 --> 00:44:48,520
为什么要这样做？因为闭包是重要的

828
00:44:48,589 --> 00:44:51,456
要了解如果你想真正使用iOS API

829
00:44:51,525 --> 00:44:55,794
好。所以让我们来看看（就这样我们可以学一点吧）

830
00:44:55,863 --> 00:44:58,497
关于如何闭包可以使我们的API很好，

831
00:44:58,565 --> 00:45:02,166
特别是如果你正在做函数式编程，

832
00:45:02,235 --> 00:45:05,904
闭包可以真的很好），但为什么闭包如此之大？

833
00:45:05,972 --> 00:45:08,907
所以让我们看看这个，这个第一个函数就在这里

834
00:45:08,976 --> 00:45:11,776
称为过滤器是一种数组方法。

835
00:45:11,845 --> 00:45:16,515
没什么特别的，它只是funk和阵列。

836
00:45:16,584 --> 00:45:20,853
它有一个参数，称为includeElement。

837
00:45:22,590 --> 00:45:26,824
而这个说参数是一个函数。这是一个函数

838
00:45:26,893 --> 00:45:29,827
需要一个与之相同类型的参数

839
00:45:29,896 --> 00:45:33,999
数组，这是一个t。所以我有一个数组角括号t。

840
00:45:34,067 --> 00:45:37,535
它是一个通用类型，因此这个函数被声明在那里

841
00:45:37,604 --> 00:45:40,205
通用类型，所以t表示相同的t，相同类型。所以

842
00:45:40,274 --> 00:45:43,141
如果我有一个字符串数组，这个过滤器期望这个

843
00:45:43,210 --> 00:45:46,044
是一个需要一个字符串的函数。作为唯一的参数。

844
00:45:46,113 --> 00:45:48,280
它返回一个Bool，所以这就是参数。

845
00:45:48,348 --> 00:45:50,549
参数是一个接受字符串的函数

846
00:45:50,617 --> 00:45:53,184
返回一个Bool或者一个T，无论如何，和

847
00:45:53,253 --> 00:45:56,388
返回一个Bool。那么什么是回报

848
00:45:56,457 --> 00:46:00,425
这个过滤器的价值是多少？它是一个T的数组，所以另一个

849
00:46:00,494 --> 00:46:03,629
数组具有相同种类的元素。那么什么是过滤器

850
00:46:03,697 --> 00:46:07,499
做？过滤器将数组中的每个单个元素

851
00:46:07,568 --> 00:46:10,435
你发送它，它运行那个小功能。和

852
00:46:10,504 --> 00:46:13,238
如果该函数返回true，它将其包含在数组中

853
00:46:13,307 --> 00:46:15,940
回报。如果它返回false，它不会。

854
00:46:16,009 --> 00:46:17,408
它抛出来所以

855
00:46:17,477 --> 00:46:21,346
它是一个过滤器：它过滤您的数组并创建一个新的

856
00:46:21,415 --> 00:46:24,916
数组与所有你不想要的东西由这个定义

857
00:46:24,985 --> 00:46:26,885
你提供的功能是一个参数。

858
00:46:26,954 --> 00:46:29,020
所有你不想抛出的东西。因此对于

859
00:46:29,089 --> 00:46:33,559
这里的例子，我有这个var，我正在创建，

860
00:46:33,627 --> 00:46:37,028
bigNumbers，我正在飞行中创建一个数组2，

861
00:46:37,097 --> 00:46:39,798
47,118,5,9，（见？我创建了一个数组），看看，

862
00:46:39,867 --> 00:46:44,469
我马上给它发信息。是的，我没有必要

863
00:46:44,538 --> 00:46:47,939
把它放在另一个var，顺便说一下，我可以有，但是，

864
00:46:48,008 --> 00:46:51,509
我只想让所有人都在这里一行。我创建了这个数组

865
00:46:51,578 --> 00:46:53,445
我发送消息过滤器和

866
00:46:53,514 --> 00:46:55,714
看看我在那里提供的论据。

867
00:46:57,284 --> 00:46:59,618
这包括元素它有一个下划线，所以，你没有

868
00:46:59,686 --> 00:47:03,488
实际上将include元素列放在那里。所以，

869
00:47:03,557 --> 00:47:07,525
我在那里放什么？这是一个关闭。所以

870
00:47:07,594 --> 00:47:11,496
这意味着它是一个功能。现在，Swift知道这是

871
00:47:11,564 --> 00:47:13,031
一个返回bool的函数。所以

872
00:47:13,100 --> 00:47:16,868
我不必把这个字放在那里。我可以用

873
00:47:16,937 --> 00:47:20,639
$0是函数的唯一参数。

874
00:47:20,708 --> 00:47:22,207
我只是去检查和

875
00:47:22,276 --> 00:47:23,875
看看$0是否大于20，换句话说，

876
00:47:23,944 --> 00:47:28,947
这是一个很大的数字。所以我收回一个只有一个数组

877
00:47:29,016 --> 00:47:32,951
47和118，因为我已经滤掉了所有的东西

878
00:47:33,020 --> 00:47:38,156
其值不大于20.想象一下写作

879
00:47:38,225 --> 00:47:43,194
这行代码没有过滤器。你会有

880
00:47:43,263 --> 00:47:45,630
到四环。你将要创建另一个数组。

881
00:47:45,699 --> 00:47:48,133
你必须运行这个小功能，

882
00:47:48,202 --> 00:47:50,169
调用这个函数，创建一个新的数组和

883
00:47:50,237 --> 00:47:52,170
添加，附加东西来做。至少有四个

884
00:47:52,239 --> 00:47:55,807
五行代码。在这里你会得到它的一行

885
00:47:55,876 --> 00:47:59,311
代码好吗？所以你看到闭包如何帮助我们。

886
00:47:59,380 --> 00:48:02,481
这也是更可读的，你可以阅读这个

887
00:48:02,550 --> 00:48:05,718
像这样：让大数字等于这个数组，但是

888
00:48:05,786 --> 00:48:08,053
过滤器的东西大于20。

889
00:48:09,223 --> 00:48:11,356
这听起来很好，所以我很清楚。

890
00:48:11,424 --> 00:48:14,426
很容易理解这里发生了什么。

891
00:48:14,495 --> 00:48:19,030
所以这是另一个。它被称为地图。地图做什么？

892
00:48:19,099 --> 00:48:21,967
它需要闭包或函数。和

893
00:48:22,036 --> 00:48:26,371
它执行函数能以便转换每个

894
00:48:26,439 --> 00:48:29,107
您要发送的阵列中的元素映射到，

895
00:48:29,175 --> 00:48:30,342
到一个新的数组。

896
00:48:30,411 --> 00:48:32,878
现在这个转变可以是一个功能的任何东西

897
00:48:32,946 --> 00:48:36,048
可以做。您可以将其转换为任何您想要的新类型。

898
00:48:36,116 --> 00:48:39,083
虽然它是一个功能，所以它

899
00:48:39,152 --> 00:48:42,253
将所有东西都覆盖到同一类型。所以你可以用它

900
00:48:42,322 --> 00:48:44,790
像我这样的类型转换。我拿了1，

901
00:48:44,858 --> 00:48:48,059
2，3并将其映射到字符串版本1，2，3，所以

902
00:48:48,128 --> 00:48:51,429
现在我有一个包含字符串的新数组。字符串1，

903
00:48:51,498 --> 00:48:54,466
字符串2，字符串3.这是一个简单的映射。

904
00:48:54,535 --> 00:48:56,801
但是，您可以想像出更强大的映射

905
00:48:56,870 --> 00:48:58,036
取数组的每个元素，和

906
00:48:58,105 --> 00:49:01,372
调用一些复杂的函数，并得到结果

907
00:49:01,441 --> 00:49:06,044
一个新的数组。所以通过创造一个非常强大的论据

908
00:49:06,112 --> 00:49:09,014
而不是String（$ 0），更强大的是你

909
00:49:09,083 --> 00:49:11,950
真的可以有一行代码真的很有表现力。

910
00:49:12,019 --> 00:49:15,587
它可以做很多事情。有一件事：通知

911
00:49:15,656 --> 00:49:19,224
在地图之后，没有括号，

912
00:49:19,293 --> 00:49:21,259
没有开放括号。你注意到了吗？

913
00:49:21,328 --> 00:49:23,795
你看到过滤器和地图之间的区别，好吗？

914
00:49:23,864 --> 00:49:25,931
当我打电话给过滤器时，我打开括号，

915
00:49:25,999 --> 00:49:28,634
打开卷曲大括号，功能，大括号，关闭

916
00:49:28,703 --> 00:49:34,506
括号。这里我只是说{String $ 0}，没有括号。

917
00:49:34,575 --> 00:49:38,910
这就是所谓的尾随闭包语法。您

918
00:49:38,979 --> 00:49:42,981
被允许拥有最后一个参数的闭包

919
00:49:43,050 --> 00:49:46,384
一个函数。该函数的括号外，

920
00:49:46,453 --> 00:49:49,621
如果他们是拖尾，看到他们正在追尾。和

921
00:49:49,690 --> 00:49:51,723
事实上，如果只有一个参数

922
00:49:51,792 --> 00:49:53,759
它是闭包，你根本不需要括号。

923
00:49:53,828 --> 00:49:55,560
那就是地图发生了什么。

924
00:49:55,629 --> 00:49:59,130
我只是说地图，括号摆脱他们。

925
00:49:59,199 --> 00:50:02,368
只要把闭包在那里，拖尾。和

926
00:50:02,436 --> 00:50:04,436
这也导致一些非常酷的外观

927
00:50:06,473 --> 00:50:09,641
代码就在这里，你看到了吗？所以你可以在任何地方使用

928
00:50:09,710 --> 00:50:12,944
闭包是函数的最后一个参数。

929
00:50:13,013 --> 00:50:15,713
你可以把它放在大括号外面。你已经可以了

930
00:50:15,782 --> 00:50:17,449
得到了花括号，这就是为什么他们这样做。

931
00:50:17,517 --> 00:50:19,951
你也不需要它周围的括号。

932
00:50:20,020 --> 00:50:20,786
所以说到底。

933
00:50:20,854 --> 00:50:22,554
并把所有其余的论据，如果你有的话，

934
00:50:22,623 --> 00:50:27,158
在括号内。最后一个，我不会

935
00:50:27,227 --> 00:50:29,061
进入细节，但它是一个类似的事情。

936
00:50:29,129 --> 00:50:32,097
减少：什么减少是需要整个数组和

937
00:50:32,165 --> 00:50:36,200
将其减少到单个值。所以这里我正在减少它

938
00:50:36,269 --> 00:50:39,737
在阵列中添加所有数字。所以我的关闭是$ 0

939
00:50:39,806 --> 00:50:43,408
+ $ 1，因为它需要的参数是一个函数

940
00:50:43,477 --> 00:50:46,245
两个元素。其中一个是数组中的一个元素

941
00:50:46,313 --> 00:50:49,247
另一个是迄今为止的答案

942
00:50:49,316 --> 00:50:52,317
那么它返回到目前为止的新答案。所以它只是执行

943
00:50:52,385 --> 00:50:55,453
这个函数在数组上是一遍又一遍的。

944
00:50:55,522 --> 00:50:58,957
顺便一提，我可以说这个是sum = [1，

945
00:50:59,026 --> 00:51:03,228
2，3] .reduce（0，+）这是我开始的价值。

946
00:51:03,297 --> 00:51:06,064
我没有添加一个名字，所以它从0开始

947
00:51:06,133 --> 00:51:09,200
那我可以说加。我可以说的原因加权利

948
00:51:09,269 --> 00:51:11,803
在底线，是因为加号

949
00:51:11,872 --> 00:51:14,406
在Swift不是有点怪异的内置东西，

950
00:51:14,474 --> 00:51:18,076
这只是一个功能。这是一个恰好是一个功能

951
00:51:18,145 --> 00:51:20,745
以这样的方式宣布，这是一个功能，但是

952
00:51:20,814 --> 00:51:23,348
它的两面都是两个论点。

953
00:51:23,417 --> 00:51:28,453
它被称为函数上的中缀运算符。所以

954
00:51:28,521 --> 00:51:30,255
因为加号只是一个函数，而且

955
00:51:30,324 --> 00:51:31,556
我以函数为参数，

956
00:51:31,625 --> 00:51:34,826
只要它是一个需要两个参数的函数

957
00:51:34,895 --> 00:51:37,962
返回一个，这正是加号，它的作品

958
00:51:38,031 --> 00:51:40,265
那里。我们也可以在我们的计算器脑中做到这一点。

959
00:51:40,334 --> 00:51:45,003
记住我们正在做的所有闭包（$ 0 * $ 1），

960
00:51:45,072 --> 00:51:50,909
这可能只是*），（$ 0 + $ 1），这可能只是

961
00:51:50,978 --> 00:51:54,813
已经+。 Cuz +是一个需要double和double的函数

962
00:51:54,882 --> 00:51:58,416
返回一个double。加上也知道如何加其他类型，

963
00:51:58,485 --> 00:52:01,619
整数。它甚至知道如何加上和浮动，

964
00:52:01,688 --> 00:52:05,356
例如，你可以加上字符串在一起。

965
00:52:05,425 --> 00:52:07,525
所以这只是一点点给你

966
00:52:07,594 --> 00:52:11,162
介绍那里。你会开始看到很多

967
00:52:11,231 --> 00:52:12,631
以函数为参数的方法。

968
00:52:12,700 --> 00:52:15,667
所以我想让你开始很舒服。

969
00:52:15,736 --> 00:52:19,204
好的，字典所以我们学到了很多关于字典

970
00:52:19,273 --> 00:52:22,140
在我们的第一次讲座。字典也有这个

971
00:52:22,208 --> 00:52:25,977
特殊声明语法，是开放的方括号

972
00:52:26,046 --> 00:52:30,882
键类型冒号值类型闭合方括号。所以

973
00:52:30,951 --> 00:52:34,386
黄色的这两件事情是相当的。

974
00:52:34,455 --> 00:52:36,755
而底下的人似乎是首选

975
00:52:36,823 --> 00:52:41,960
一天这些所以你知道你可以创建一个字典。

976
00:52:42,029 --> 00:52:44,796
顺便说一下，我向你展示了从中创建字典

977
00:52:44,865 --> 00:52:46,198
这里有一些常数值。

978
00:52:46,267 --> 00:52:48,667
但是你可以创建一个字典，只是说，

979
00:52:48,736 --> 00:52:50,802
let d等于字典。开括号，

980
00:52:50,871 --> 00:52:53,405
右括号如果你说var d

981
00:52:53,474 --> 00:52:55,941
等于字典，那么现在你可以开始追加项目

982
00:52:56,009 --> 00:52:58,176
因为你得到一个空的字典来启动它。但

983
00:52:58,245 --> 00:53:01,012
在这里我开始我的字典与它的东西。

984
00:53:01,081 --> 00:53:06,051
这可能应该说var pac12teamRankings

985
00:53:06,119 --> 00:53:10,154
因为两行以后我说pac12teamRankings sub Cal

986
00:53:10,223 --> 00:53:15,159
等于12.还要注意

987
00:53:15,228 --> 00:53:18,964
当我尝试获得俄亥俄州的排名时，它返回零。

988
00:53:19,032 --> 00:53:21,032
我们知道当我们使用方括号来获得

989
00:53:21,101 --> 00:53:22,367
字典中的某些东西返回

990
00:53:22,436 --> 00:53:26,838
我们的价值类型是可选的。我们的价值类型是ints，

991
00:53:26,907 --> 00:53:32,544
所以它会返回一个可选的int。

992
00:53:32,613 --> 00:53:37,683
好的，列举。字典也是

993
00:53:37,751 --> 00:53:40,852
一个集合，因此可以排序。所以你可以做

994
00:53:40,921 --> 00:53:43,388
在上面当然，字典有键和

995
00:53:43,457 --> 00:53:48,326
值。所以我们需要一个元组来做我们的枚举

996
00:53:48,395 --> 00:53:52,964
字典中的元组键常用值。和

997
00:53:53,033 --> 00:53:56,468
那么它将通过，钥匙的价值将被设置。

998
00:53:57,605 --> 00:53:59,104
这是一个非常简单的方法

999
00:53:59,173 --> 00:54:04,643
列举或迭代字典。好的，

1000
00:54:04,711 --> 00:54:08,547
串。所以你会想，字符串是最简单的类

1001
00:54:08,615 --> 00:54:11,182
所有的语言。这只是一个字符串，对吧？

1002
00:54:11,251 --> 00:54:14,752
那么事实证明不是那么真实。当你想到

1003
00:54:14,821 --> 00:54:17,756
一个代表整个世界各种语言的字符串，

1004
00:54:17,824 --> 00:54:21,760
突然之间真的很复杂。

1005
00:54:21,828 --> 00:54:26,397
因为一些语言是表意的。一些语言去

1006
00:54:26,466 --> 00:54:29,735
从右到左，而不是从左到右。有些语言有

1007
00:54:29,803 --> 00:54:34,639
他们中有许多变音符号和口音。有些不行

1008
00:54:34,708 --> 00:54:37,976
大多数语言不使用与我们使用相同的字母表。

1009
00:54:38,045 --> 00:54:40,412
所以字符串是超级复杂，

1010
00:54:40,480 --> 00:54:43,982
这是一个非常复杂的课。现在字符串尝试

1011
00:54:44,050 --> 00:54:46,485
最好的，做一个很好的简化它

1012
00:54:46,553 --> 00:54:51,423
你的使用。但复杂性仍然存在。现在最多

1013
00:54:51,491 --> 00:54:54,393
一个字符串的重要复杂性就是代表

1014
00:54:54,462 --> 00:54:59,631
一个字符串并不总是一个字符等于一个

1015
00:54:59,699 --> 00:55:04,269
内部代表单位现在单位，那种

1016
00:55:04,338 --> 00:55:06,804
用来表示里面的字符串的东西，

1017
00:55:06,873 --> 00:55:10,642
是Unicodes。我有你在作业中跳过阅读

1018
00:55:10,711 --> 00:55:13,344
一个，我把它放在作业二。

1019
00:55:13,413 --> 00:55:14,980
这真的不是你所了解的关键。

1020
00:55:15,049 --> 00:55:16,248
我认为这很有趣，但是

1021
00:55:16,317 --> 00:55:19,918
你可能想读它。但是关于Unicodes的事情

1022
00:55:19,987 --> 00:55:22,420
它不是一个Unicode等于一个字符。

1023
00:55:22,489 --> 00:55:27,392
其实，如果你有一个小狗表情的狗吠叫，

1024
00:55:27,461 --> 00:55:30,562
这可能是三个Unicode字符。只有一个

1025
00:55:30,630 --> 00:55:32,631
关于你认为是一个人物。要么

1026
00:55:32,700 --> 00:55:36,902
更简单的说，我在这里的例子是咖啡厅。

1027
00:55:36,970 --> 00:55:40,371
最后有口音aigu，对，这是一个法语

1028
00:55:40,440 --> 00:55:43,242
字，e口音aigu。那可能是四个Unicodes，

1029
00:55:43,310 --> 00:55:45,710
因为有一个Unicode为e口音aigu。

1030
00:55:45,779 --> 00:55:49,548
或者可能是五。它可能是另一个Unicode的e

1031
00:55:49,616 --> 00:55:52,617
这个字符表示了以前的口音

1032
00:55:52,686 --> 00:55:57,489
字符。所以，当你有这么多未知数的时候

1033
00:55:57,558 --> 00:56:00,325
它代表的字符，你需要一个新的抽象

1034
00:56:00,394 --> 00:56:04,495
代表我们认为人类是一个人物。

1035
00:56:04,564 --> 00:56:07,833
即使这样很难真正定义，当你认为

1036
00:56:07,901 --> 00:56:09,734
世界上所有的语言。英文很简单，

1037
00:56:09,803 --> 00:56:15,274
虽然。所以这真的是我们要如何互动

1038
00:56:15,342 --> 00:56:17,976
字符串：试图用角色来思考它们。

1039
00:56:18,045 --> 00:56:19,711
但是字符串本身并不是实际的

1040
00:56:19,780 --> 00:56:20,712
一个字符的集合。

1041
00:56:20,781 --> 00:56:23,181
字符串是一个更强大的内部结构，

1042
00:56:23,250 --> 00:56:25,783
所有的Unicodes都在那里，所有的东西，

1043
00:56:25,852 --> 00:56:29,087
这不是那么的这样做有一点点

1044
00:56:29,156 --> 00:56:34,225
你会看到并发症。现在，你不能字符串，是的

1045
00:56:34,294 --> 00:56:37,229
可索引，这意味着您可以使用打开的方括号

1046
00:56:37,297 --> 00:56:40,665
就像你可以在数组中获得一个字符。

1047
00:56:40,734 --> 00:56:43,736
唯一的磨擦是我在另一张幻灯片中所说的索引

1048
00:56:43,804 --> 00:56:46,505
不是int。所以如果你有这个词你好，

1049
00:56:46,573 --> 00:56:53,378
这不像你可以说，你好[1]等于e。

1050
00:56:53,447 --> 00:56:56,481
你不能这样做，因为它可能，

1051
00:56:56,550 --> 00:56:59,050
如果是咖啡厅，那么咖啡厅3。

1052
00:56:59,119 --> 00:57:03,088
现在还不清楚你想要一个角色，

1053
00:57:03,157 --> 00:57:06,258
所以你必须确保你在那里得到正确的索引

1054
00:57:06,326 --> 00:57:08,961
因为幕后的索引可以相当

1055
00:57:09,029 --> 00:57:11,997
复杂。有这个其他的结构，它是

1056
00:57:12,065 --> 00:57:15,267
称为string.index。所以说我有一个字符串，

1057
00:57:15,336 --> 00:57:18,870
我会打电话给我，我会把你好。

1058
00:57:18,939 --> 00:57:23,842
现在，如果我现在想要s [0]，我不能做s [0]

1059
00:57:23,911 --> 00:57:25,678
因为我们不用整数索引字符串

1060
00:57:25,746 --> 00:57:28,046
让我们说我想要。我该如何得到它？好，

1061
00:57:28,115 --> 00:57:31,450
我首先调用这个var，再次使用这个var和

1062
00:57:31,518 --> 00:57:34,386
字符串叫startIndex，好吗？它给了我们

1063
00:57:34,455 --> 00:57:37,322
一个string.index。这很重要，我们需要得到

1064
00:57:37,391 --> 00:57:39,958
持有一个string.index因为我们的方式

1065
00:57:40,027 --> 00:57:42,427
在字符串中移动是通过我们知道的索引

1066
00:57:42,496 --> 00:57:44,963
人性向前或向后移动

1067
00:57:45,032 --> 00:57:47,666
可以理解的性格不是Unicodes，因为我们

1068
00:57:47,734 --> 00:57:50,068
不知道每个字符有多少个Unicodes

1069
00:57:50,137 --> 00:57:52,637
我们一定要来回移动。

1070
00:57:52,706 --> 00:57:54,506
所以我们从第一个开始。

1071
00:57:54,574 --> 00:57:56,941
所以现在我可以创建一个变量firstChar

1072
00:57:57,010 --> 00:57:57,976
这种字符，

1073
00:57:58,045 --> 00:58:00,746
这个人类可以理解的性格。

1074
00:58:00,814 --> 00:58:03,715
这将是平等的[firstIndex]。所以看看，

1075
00:58:03,784 --> 00:58:06,552
我使用方括号来索引到一个字符串，但是

1076
00:58:06,620 --> 00:58:10,722
我不得不使用String.Index不是Int。这第一个索引

1077
00:58:10,791 --> 00:58:13,091
我问了字符串“你的第一个索引是什么”？

1078
00:58:13,160 --> 00:58:15,160
这是有用的，因为我不得不问

1079
00:58:15,228 --> 00:58:17,161
字符串，你的第一个字符的索引是什么？

1080
00:58:17,230 --> 00:58:19,731
然后转身说好，给我S你的第一个字符。

1081
00:58:19,800 --> 00:58:20,899
所以这不是有趣的事情，

1082
00:58:20,968 --> 00:58:23,835
如果我想要下一个字符怎么办？如果我

1083
00:58:23,904 --> 00:58:27,006
想要下一个字符，我要求字符串是什么索引

1084
00:58:27,074 --> 00:58:30,975
你的第一个角色后的角色。和

1085
00:58:31,044 --> 00:58:33,178
它会给我一个新的索引，它的第二个字符和

1086
00:58:33,247 --> 00:58:37,215
现在我可以得到那个。即使是有点像，

1087
00:58:37,284 --> 00:58:38,049
我的上帝，你在开玩笑，

1088
00:58:38,118 --> 00:58:41,219
这真的是我该怎么做的？如果我想要怎么办

1089
00:58:41,288 --> 00:58:44,056
去跳，但得到第四，第五

1090
00:58:44,124 --> 00:58:47,959
人物，我们来说吧好吧，我可以说，

1091
00:58:48,028 --> 00:58:52,197
给我索引，从你的第一个索引开始，

1092
00:58:52,266 --> 00:58:53,832
这是四大领先，所以跳四跳，

1093
00:58:53,901 --> 00:58:58,770
四个字符在前面。这是一点点

1094
00:58:58,839 --> 00:59:01,706
这很麻烦，当然这不是我们实际的方式

1095
00:59:01,775 --> 00:59:03,775
与字符串进行交互我们通常在寻找

1096
00:59:03,844 --> 00:59:07,346
字符串的子字符串，好的或subranges

1097
00:59:07,414 --> 00:59:09,281
我们试图在字符串中找到一个字符。

1098
00:59:10,684 --> 00:59:13,485
顺便说一句，你可以使用范围，所以我可以说

1099
00:59:13,554 --> 00:59:17,021
给我的子串是firstIndex ... secondIndex和

1100
00:59:17,090 --> 00:59:21,460
它会给我他的一个新的字符串是他，所以

1101
00:59:21,528 --> 00:59:25,330
你可以使用范围，但它们必须是string.index

1102
00:59:25,398 --> 00:59:29,968
不是ints。所以我们基本上想要的东西

1103
00:59:30,037 --> 00:59:34,673
是一个字符的集合。字符串不是集合

1104
00:59:34,742 --> 00:59:37,709
的字符，所以你不能做，例如，在它。

1105
00:59:37,778 --> 00:59:39,178
你甚至不能说索引（:)。

1106
00:59:39,246 --> 00:59:42,714
索引（:)是这个伟大的事情，你可以，

1107
00:59:42,783 --> 00:59:44,215
如果你收集的东西，你可以说给

1108
00:59:44,284 --> 00:59:47,452
我这个东西的指标在那里你甚至不能这样做

1109
00:59:47,521 --> 00:59:50,656
与一个字符串，因为它不是一个集合。幸运的是，

1110
00:59:50,724 --> 00:59:53,858
string有一个var，它会给你一个它的集合

1111
00:59:53,927 --> 00:59:56,228
字符。它不仅会给予

1112
00:59:56,297 --> 00:59:58,964
你可以收集它的字符

1113
00:59:59,032 --> 01:00:02,768
在索引（:)中，但是你得到的字符串索引

1114
01:00:02,836 --> 01:00:07,472
从该集合将匹配字符串中的内容。所以

1115
01:00:07,541 --> 01:00:10,008
您可以使用此字符集来查找内容

1116
01:00:10,077 --> 01:00:13,378
在那里，得到一个字符的索引，像

1117
01:00:13,447 --> 01:00:15,947
那。然后使用您在那里找到的索引返回

1118
01:00:16,016 --> 01:00:20,752
你的字符串说，现在可以给我一个子字符串。所以

1119
01:00:20,821 --> 01:00:24,890
字符是此字符串上的var的名称。所以例如，

1120
01:00:24,958 --> 01:00:27,993
如果我想逐个迭代所有的字符，

1121
01:00:28,062 --> 01:00:29,828
做一个循环他们可以说，for c：

1122
01:00:29,897 --> 01:00:31,730
这将是类型字符，

1123
01:00:31,798 --> 01:00:36,334
顺便说一下，以字符。我不能for c：in s，for

1124
01:00:36,403 --> 01:00:40,372
c：in s.characters。那就是打电话给我

1125
01:00:40,441 --> 01:00:43,308
每个角色循环一次。题？是啊，

1126
01:00:43,377 --> 01:00:46,211
很好的问题所以如果我这样做在咖啡馆，

1127
01:00:46,279 --> 01:00:49,580
我会得到什么？我会得到四个角色，好的，

1128
01:00:49,649 --> 01:00:52,150
因为他们使用的E-accent-agu在我们的考虑

1129
01:00:52,219 --> 01:00:54,520
人的感知一个字。

1130
01:00:54,588 --> 01:00:56,454
我会得到四个字符所以有一个角色。

1131
01:00:56,523 --> 01:00:58,423
字符是结构，正确和在字符

1132
01:00:58,491 --> 01:01:01,093
有一个代表e-accent-agu的角色。

1133
01:01:01,161 --> 01:01:02,360
无论在字符串中如何表示，

1134
01:01:02,429 --> 01:01:03,895
在字符串中可能是两个字符，它可能是一个，

1135
01:01:03,964 --> 01:01:06,565
没关系。你会得到一个角色

1136
01:01:06,634 --> 01:01:09,567
为此，这是一个非常好的问题。我该怎么办

1137
01:01:09,636 --> 01:01:12,537
知道一个字符串中有多少字符？再次，

1138
01:01:12,606 --> 01:01:14,973
从用户的角度来看。 s.characters.count，

1139
01:01:15,042 --> 01:01:18,243
不是s.length或某事，s.characters.count，

1140
01:01:18,312 --> 01:01:21,679
字符集中的字符数

1141
01:01:21,748 --> 01:01:26,250
对于这个字符串另外，如果我想找到第一个空格怎么办

1142
01:01:26,319 --> 01:01:29,121
在一个字符串？有一串字符串，我想找到

1143
01:01:29,189 --> 01:01:34,559
第一个空间。我会说s.characters.index（的：“”）。

1144
01:01:34,628 --> 01:01:38,030
那是给我一个string.index（的：“'）那个

1145
01:01:38,098 --> 01:01:41,032
字符集合然后我可以使用该字符串

1146
01:01:41,101 --> 01:01:43,702
该索引虽然回到我的字符串并做某事。

1147
01:01:43,771 --> 01:01:45,470
也许在那里插入东西

1148
01:01:45,539 --> 01:01:48,473
删除空格或插入后的单词

1149
01:01:48,542 --> 01:01:54,279
另一个空间。现在我将索引到字符串。

1150
01:01:54,348 --> 01:01:58,850
String是一个值类型，所以当你做let和var时，

1151
01:01:58,919 --> 01:02:02,420
如果你让你不能做附加的事情

1152
01:02:02,489 --> 01:02:06,525
字符串cuz是不可变的。大多数字符串在Swift

1153
01:02:06,594 --> 01:02:09,027
是不可变的，这使它超高性能。

1154
01:02:09,096 --> 01:02:12,964
但是如果你有一个var，你可以阅读加上等于那里

1155
01:02:13,033 --> 01:02:16,235
所以我可以在那里打个招呼它没有任何影响

1156
01:02:16,303 --> 01:02:19,304
你好，让一个因为这是不可变的，对吧？好的，

1157
01:02:19,373 --> 01:02:22,007
所以我不能这样做。我可以使用字符

1158
01:02:22,076 --> 01:02:24,876
以强大的方式操纵字符串。我可以，我不

1159
01:02:24,945 --> 01:02:27,279
有时间谈论所有这一切，这是你真正的地方

1160
01:02:27,348 --> 01:02:29,915
确实需要仔细阅读你的阅读作业。但对于

1161
01:02:29,984 --> 01:02:33,285
例如，如果我想在这里插入你的话，

1162
01:02:33,353 --> 01:02:36,621
所以它说你好，你在那里，好吧，我会得到，

1163
01:02:36,690 --> 01:02:40,425
通过做character.index（of：“”）找到第一个基础，

1164
01:02:40,494 --> 01:02:43,762
我在上一张幻灯片中显示了你。那就是

1165
01:02:43,831 --> 01:02:47,199
一个方法在字符串中调用，插入常量，

1166
01:02:47,267 --> 01:02:50,569
这个字符集的内容

1167
01:02:50,638 --> 01:02:55,040
在这个位置，这个string.index。所以，当我想要

1168
01:02:55,108 --> 01:02:58,443
一个代表“你”的字符集，我说，

1169
01:02:58,512 --> 01:03:02,080
“you”.characters，因为它是。字符，和

1170
01:03:02,149 --> 01:03:05,883
它给了我一个字符串的字符集。所以

1171
01:03:05,952 --> 01:03:09,021
这似乎有点奇怪，但事实证明是解决了

1172
01:03:09,089 --> 01:03:11,456
很不错。还有十亿其他功能，

1173
01:03:11,525 --> 01:03:12,924
在斯威夫特，许多，许多，许多，

1174
01:03:12,993 --> 01:03:15,027
我无法谈论他们。

1175
01:03:15,095 --> 01:03:18,396
注意我说如果让firstSpace，因为那可能

1176
01:03:18,465 --> 01:03:21,166
如果找不到，返回零。所以我不会在那里做

1177
01:03:21,234 --> 01:03:25,904
我不会把它插在那里是一堆其他的东西

1178
01:03:25,972 --> 01:03:28,807
检查字符串前缀的位置。

1179
01:03:28,876 --> 01:03:31,109
你可以替换subrange，当然你必须找到

1180
01:03:31,177 --> 01:03:33,044
通常你会看到的范围

1181
01:03:33,113 --> 01:03:35,480
收集字符找到你想要的范围

1182
01:03:35,549 --> 01:03:38,783
替换东西等甚至很酷的方法，如组件

1183
01:03:38,852 --> 01:03:42,020
用字符串分隔将会有一个像平静的字符串

1184
01:03:42,089 --> 01:03:45,824
分离值并获取所有值

1185
01:03:45,893 --> 01:03:48,727
把它们放在一个有趣的数组中。可以，然后呢

1186
01:03:48,796 --> 01:03:52,864
很多：字符串有几十种方法，你真的

1187
01:03:52,933 --> 01:03:55,100
需要熟悉你自己。如果你不花时间

1188
01:03:55,168 --> 01:03:57,235
熟悉字符串中的那些东西。

1189
01:03:57,304 --> 01:03:58,971
然后我保证你要写一个程序

1190
01:03:59,039 --> 01:04:01,006
你要做一些字符串解析或

1191
01:04:01,075 --> 01:04:02,641
一些东西，你要写一堆

1192
01:04:02,710 --> 01:04:04,276
代码做，然后找出有一个方法

1193
01:04:04,345 --> 01:04:05,878
做了你想要的字符串。

1194
01:04:07,514 --> 01:04:09,281
有东西在那里闭包和

1195
01:04:09,350 --> 01:04:10,516
做各种有趣的东西，所以

1196
01:04:10,584 --> 01:04:12,984
确保你注意到字符串和

1197
01:04:13,053 --> 01:04:16,754
到字符视图是字符集合。

1198
01:04:16,823 --> 01:04:21,894
好的，其他班。这是一个快速总结

1199
01:04:21,962 --> 01:04:25,130
的其他重要课程。一个是NSObject，NSObject是

1200
01:04:25,199 --> 01:04:30,902
一类。它是所有Objective-C类的根。一个iOS

1201
01:04:30,971 --> 01:04:34,305
几年前Swift出来的应用程序，

1202
01:04:34,374 --> 01:04:36,975
那里的所有课程都将从最后继承

1203
01:04:37,044 --> 01:04:40,011
NSObject的。所以NSObject有一个基本功能。你不

1204
01:04:40,080 --> 01:04:43,214
需要从NSObject子类来做一个swift 类。

1205
01:04:43,283 --> 01:04:45,850
然而，还有一些真正晦涩的功能

1206
01:04:45,919 --> 01:04:50,622
IOS在哪里期待继承自NSObject的类。

1207
01:04:52,025 --> 01:04:54,759
如果我们甚至找到他们，我会告诉你们。他们是

1208
01:04:54,828 --> 01:04:57,095
很罕见但是这只是你知道NSObject是什么。

1209
01:04:57,164 --> 01:04:58,364
对你来说真的没有意义，

1210
01:04:58,432 --> 01:05:00,965
你们都会是Swift程序员。

1211
01:05:01,034 --> 01:05:04,235
NSNumber是另一个类，它是一个通用的数字

1212
01:05:04,304 --> 01:05:08,072
持有人。这也是继承自Objective-C，你可以告诉

1213
01:05:08,141 --> 01:05:12,077
由NS在那里直到我们可以持有任何数字，

1214
01:05:12,145 --> 01:05:14,479
浮点数，小数位，你甚至可以持有一个bool，

1215
01:05:14,547 --> 01:05:16,982
因为它认为一个数字，0是false的

1216
01:05:17,050 --> 01:05:20,685
1是true的任何非零都是true的。你也可以

1217
01:05:20,754 --> 01:05:25,390
做类型转换。再次，迅速，我们将要使用

1218
01:05:25,458 --> 01:05:28,627
实际的具体数字类，如double和int

1219
01:05:28,696 --> 01:05:32,698
我们将使用它们的构造函数。做类型转换。

1220
01:05:32,766 --> 01:05:35,767
但是只要你知道NSNumber就在身边。好的，

1221
01:05:35,835 --> 01:05:38,670
日期。超级重要类任何时候你代表

1222
01:05:38,738 --> 01:05:42,674
一个日期或时间，你将要使用这个日期结构。

1223
01:05:42,743 --> 01:05:46,144
而且它有很多辅助类，

1224
01:05:46,212 --> 01:05:49,914
如日历，日期格式化程序，日期组件，如日期

1225
01:05:49,983 --> 01:05:52,551
组件将告诉你一个日期的月份。和

1226
01:05:52,620 --> 01:05:54,686
当然，这个月的日期取决于什么

1227
01:05:54,755 --> 01:05:58,123
它的日历，cuz不是每个人都使用一个日历

1228
01:05:58,191 --> 01:06:00,258
我们的确是。好吧，有很多日历

1229
01:06:00,327 --> 01:06:02,528
遍布地球，与我们不同。

1230
01:06:02,596 --> 01:06:05,697
所以任何时候你甚至考虑提出约会

1231
01:06:05,766 --> 01:06:09,568
您的UI中的任何位置都需要使用此类。

1232
01:06:09,636 --> 01:06:12,270
因为如果你想让你的应用程序工作在任何东西，但是

1233
01:06:12,339 --> 01:06:14,639
英语，你必须格式化你的日期，使用

1234
01:06:14,708 --> 01:06:19,744
DateFormatter，在你的应用程序运行的任何地方。

1235
01:06:19,813 --> 01:06:22,514
所以日期是非常重要的。你会认为日期是真的

1236
01:06:22,583 --> 01:06:25,149
容易，但不。日期实际上有很多的复杂性，

1237
01:06:25,218 --> 01:06:27,352
因为我们代表日期的所有不同的方式

1238
01:06:27,420 --> 01:06:30,989
世界。相同，类似于字符串的复杂性。和

1239
01:06:31,058 --> 01:06:35,060
那么有数据，DATA，代表一个袋子'位。

1240
01:06:35,129 --> 01:06:38,963
只是一点点，在那里的一堆。通常这可能是

1241
01:06:39,032 --> 01:06:42,066
像图像，图像的位，或

1242
01:06:42,135 --> 01:06:45,671
这样的东西你通过网络得到的东西

1243
01:06:45,739 --> 01:06:47,806
所以数据是我们如何代表这些。

1244
01:06:47,875 --> 01:06:49,875
注意，有一个struct，它是一个值类型。

1245
01:06:49,944 --> 01:06:54,045
它正确地传递给副本。和

1246
01:06:54,114 --> 01:06:56,882
您将开始在UI中查看数据，可能是第五周或

1247
01:06:56,950 --> 01:07:00,686
这个班的六个。好吧，初始化。

1248
01:07:00,754 --> 01:07:04,122
所以初始化是非常复杂的。你是

1249
01:07:04,191 --> 01:07:07,092
最终必须阅读阅读作业。

1250
01:07:07,161 --> 01:07:11,996
我会给你真正快速的亮点。在里面

1251
01:07:12,065 --> 01:07:15,500
方法，再次，我们可以让它们在类或结构上。

1252
01:07:15,569 --> 01:07:18,670
它们用于初始化我们的任何属性

1253
01:07:18,738 --> 01:07:22,674
没有初始化为平等或使用懒惰或他们是

1254
01:07:22,742 --> 01:07:25,811
选配。所有这些都被照顾，如果有的话

1255
01:07:25,879 --> 01:07:30,649
左，或多于一个，那么我们需要一个初始化器。

1256
01:07:30,718 --> 01:07:33,618
初始化它他们在脖子上是一种痛苦。

1257
01:07:33,687 --> 01:07:36,655
因为，特别是对于类。对于结构体，

1258
01:07:36,723 --> 01:07:39,023
他们不是在脖子上的痛苦。他们完全正常

1259
01:07:39,092 --> 01:07:41,727
结构，你只需要一个init，无论你想要什么参数，

1260
01:07:41,795 --> 01:07:43,328
你想要的参数并初始化你的变量。

1261
01:07:43,397 --> 01:07:46,564
这一切都很简单。但是对于课堂，还有一点点

1262
01:07:46,633 --> 01:07:49,201
复杂。现在，无论你是一个结构还是一个类，

1263
01:07:49,269 --> 01:07:51,603
你可以有多个init。他们可以有不同的

1264
01:07:51,672 --> 01:07:55,106
参数。只要你给他们足够的参数

1265
01:07:55,175 --> 01:07:58,710
能够初始化所有变量，你很好。

1266
01:07:58,779 --> 01:08:00,278
所以你可以拥有你想要的许多内容。

1267
01:08:00,347 --> 01:08:02,914
很多类有很多初始化。意义

1268
01:08:02,983 --> 01:08:04,649
他们如何被使用，如何被创造。

1269
01:08:04,718 --> 01:08:06,217
想像一些字符串。

1270
01:08:06,286 --> 01:08:07,852
String有一个需要一个double的init。

1271
01:08:07,921 --> 01:08:09,888
它有一个字符串，如果你想要另一个刺

1272
01:08:09,956 --> 01:08:12,190
制作一个字符串的副本。它需要一个init。

1273
01:08:12,259 --> 01:08:14,727
所有这些都可以与字符串进行比较。

1274
01:08:14,795 --> 01:08:16,929
或者不是所有的东西你比较字符串，但

1275
01:08:16,997 --> 01:08:18,496
很多事情你可以比较一个字符串。

1276
01:08:18,565 --> 01:08:20,766
它有一个初始化，它将作为一个参数

1277
01:08:20,834 --> 01:08:26,538
例如。调用者通过创建来执行你的init

1278
01:08:26,606 --> 01:08:29,841
其中之一。他们只是把类型和名称

1279
01:08:29,909 --> 01:08:33,211
括号和您要为该init启动的参数。所以

1280
01:08:33,280 --> 01:08:35,514
他们选择你想要的init中的哪一个

1281
01:08:35,583 --> 01:08:37,416
他们称之为那些参数。

1282
01:08:37,484 --> 01:08:40,519
到目前为止，我们在演讲中已经看到了很多例子。

1283
01:08:43,490 --> 01:08:48,192
你得到一些免费的inits。如果你是一个基层，好的，

1284
01:08:48,261 --> 01:08:50,395
你不会继承任何其他东西。

1285
01:08:50,463 --> 01:08:53,832
你得到一个没有参数的空闲init。恭喜。

1286
01:08:53,901 --> 01:08:56,401
所以这意味着，至少人们可以创造你。

1287
01:08:56,470 --> 01:08:58,169
但是，如果您有任何未初始化的vars，

1288
01:08:58,238 --> 01:09:00,405
你必须创建初始化的列表

1289
01:09:00,474 --> 01:09:05,143
他们。结构更好。他们得到一个有所有的init

1290
01:09:05,212 --> 01:09:10,181
的他们的vars。现在如果一个结构体实现了它自己的一个

1291
01:09:10,250 --> 01:09:13,452
初始化器，它停止得到这个，这是免费的。

1292
01:09:13,520 --> 01:09:15,920
如果你不做任何其他的，你只得到免费的。

1293
01:09:15,989 --> 01:09:17,022
所以就像默认的。

1294
01:09:17,091 --> 01:09:19,124
我们在演讲中也看到了这一点。

1295
01:09:19,192 --> 01:09:23,428
我们在init函数中获得了一个空闲的函数，第一个操作数。

1296
01:09:23,497 --> 01:09:26,231
我们从来没有写过init函数，我们得到了免费的。

1297
01:09:26,299 --> 01:09:30,068
它刚刚出现，我们能够称之为它。 ，所以

1298
01:09:30,137 --> 01:09:32,504
结构很好，你得到了基本的免费init

1299
01:09:32,573 --> 01:09:37,275
所有你的变种你能做些什么？我

1300
01:09:37,344 --> 01:09:40,445
好吧，开始快点，好吧。所以我们走吧。一，

1301
01:09:40,514 --> 01:09:43,382
即使该属性，您也可以设置任何属性值

1302
01:09:43,450 --> 01:09:46,185
已经设置了它的值，你可以重置别的东西。

1303
01:09:46,253 --> 01:09:50,589
你可以设置允许。所以你会有一个let

1304
01:09:50,657 --> 01:09:54,826
得到较少的x等于5.您仍然可以在init中重置它。

1305
01:09:54,895 --> 01:09:59,330
您的init允许设置let。你可以调用其他init

1306
01:09:59,399 --> 01:10:04,135
方法可以在你自己的类或你自己的结构中。你做的

1307
01:10:04,204 --> 01:10:06,972
那么说自己就是这样说的

1308
01:10:07,041 --> 01:10:10,175
init方法都是这样的init方法可以调用对方。

1309
01:10:10,244 --> 01:10:13,278
在课堂上，你可以调用super.init。

1310
01:10:13,347 --> 01:10:14,680
来自您的父类的初始化程序

1311
01:10:14,748 --> 01:10:17,516
当然，你需要让你的父类初始化。

1312
01:10:17,585 --> 01:10:19,517
现在，当我们开始讲课时，

1313
01:10:19,586 --> 01:10:22,988
我们开始谈论在我们的超级，

1314
01:10:23,057 --> 01:10:24,823
我们开始考虑继承，

1315
01:10:24,892 --> 01:10:27,859
它变得非常复杂。所以

1316
01:10:27,928 --> 01:10:31,195
让我们开始思考课堂，打破这个阶段。

1317
01:10:31,264 --> 01:10:34,699
让我们从init中开始你需要做什么

1318
01:10:34,768 --> 01:10:37,969
一类？在一个结构中，很容易你只需要

1319
01:10:38,038 --> 01:10:40,238
初始化所有未初始化的var。但

1320
01:10:40,307 --> 01:10:43,809
在一个类里你需要做什么？到......的时候

1321
01:10:43,878 --> 01:10:46,345
这样做，你必须初始化所有的vars。

1322
01:10:46,413 --> 01:10:50,048
我们知道。有两种类型的初始化器。

1323
01:10:50,117 --> 01:10:51,583
一个方便的初始化器。

1324
01:10:51,651 --> 01:10:54,753
这只适用于课堂。一个方便的初始化程序和

1325
01:10:54,822 --> 01:10:57,055
什么叫指定的初始化程序

1326
01:10:57,124 --> 01:11:00,024
指定是默认值。没有关键字就是这样

1327
01:11:00,093 --> 01:11:02,127
如果没有标记方便，那么它是一个指定的。

1328
01:11:02,195 --> 01:11:04,462
现在这里的规则进来了。

1329
01:11:04,531 --> 01:11:08,133
指定的初始化程序非常方便必须和

1330
01:11:08,201 --> 01:11:12,870
只能调用它所指定的初始化程序，

1331
01:11:12,939 --> 01:11:15,974
那就是它的立即父类，

1332
01:11:16,043 --> 01:11:19,478
这很重要。它必须调用一个父类的init

1333
01:11:19,546 --> 01:11:22,013
它必须得到指定的初始化程序。它不能调用

1334
01:11:22,082 --> 01:11:25,083
它是一个父类中的方便的初始化器。也不

1335
01:11:25,152 --> 01:11:30,222
除了那个外，它可以称之为固有链的两个类

1336
01:11:30,290 --> 01:11:32,691
上面继承了上面的一个init，

1337
01:11:32,759 --> 01:11:36,094
我们会在一秒钟内谈一谈。你必须初始化

1338
01:11:36,162 --> 01:11:39,898
在你调用该super init之前的所有属性。

1339
01:11:42,336 --> 01:11:43,435
你必须完全

1340
01:11:43,504 --> 01:11:46,037
完成你在课堂上介绍的所有内容。

1341
01:11:46,106 --> 01:11:48,740
在调用super init之前，先将它们初始化。和，

1342
01:11:48,809 --> 01:11:51,809
您必须调用super才能重新初始化或

1343
01:11:51,878 --> 01:11:54,846
改变任何一个属性的价值，显然，

1344
01:11:54,915 --> 01:11:57,816
你必须让你的父类有机会初始化

1345
01:11:57,885 --> 01:12:00,685
在您开始使用其属性之前自己。

1346
01:12:00,754 --> 01:12:03,322
否则，当单位叫super时，可能会是

1347
01:12:03,391 --> 01:12:05,557
鼓励你对自己的属性做了什么。

1348
01:12:05,626 --> 01:12:10,862
一个convenience  init只能，必须而且只能，

1349
01:12:10,931 --> 01:12:16,268
在自己的类中调用一个初始化程序，没有super。

1350
01:12:17,571 --> 01:12:18,603
只有在你自己的类里，

1351
01:12:18,672 --> 01:12:22,040
方便初始化器(convenience  init)只在你自己的类中。您可以

1352
01:12:22,109 --> 01:12:24,109
叫它另一个方便，或者你可以称它为代号，

1353
01:12:24,177 --> 01:12:25,477
但它必须在你自己的类，

1354
01:12:25,546 --> 01:12:27,712
不在你的父类。和

1355
01:12:27,781 --> 01:12:30,682
一个convenience   init必须调用它将要调用的任何init

1356
01:12:30,751 --> 01:12:33,318
本身之前它可以设置任何属性

1357
01:12:33,387 --> 01:12:37,189
值。它与一个调用进来的init有所不同

1358
01:12:37,258 --> 01:12:39,491
超级因为那个人必须做它的初始化，

1359
01:12:39,560 --> 01:12:41,426
指定一个，之前它叫super。

1360
01:12:41,495 --> 01:12:43,595
在这种情况下，你必须做convenience  ，

1361
01:12:43,664 --> 01:12:46,164
你必须先调用你另一个。

1362
01:12:46,232 --> 01:12:50,969
和调用其他所有，无论你做什么，任何

1363
01:12:51,037 --> 01:12:54,539
你必须调用的所有事情必须完成，

1364
01:12:54,608 --> 01:12:57,342
在你开始调用你自己的方法之前

1365
01:12:57,410 --> 01:12:58,309
访问属性。

1366
01:12:58,378 --> 01:12:59,844
不设置属性，但访问它们。

1367
01:12:59,913 --> 01:13:02,580
换句话说，你必须在你之前完全初始化

1368
01:13:02,649 --> 01:13:07,318
init可以开始使用你的类。好吧，

1369
01:13:07,387 --> 01:13:11,523
那是正确的：那里有很多规则，还有很多规则

1370
01:13:11,592 --> 01:13:15,260
是冲突和所有的东西。让我们让它更多

1371
01:13:15,329 --> 01:13:18,296
当我们谈论继承的时候很复杂。所以，

1372
01:13:18,365 --> 01:13:20,832
你想从你的父类获得一些，

1373
01:13:20,901 --> 01:13:24,402
哇，不是那么快。如果你不实施

1374
01:13:24,471 --> 01:13:27,439
任何指定的，你只是实现方便，

1375
01:13:27,507 --> 01:13:30,943
那么你会继承你所有的父类，

1376
01:13:31,011 --> 01:13:32,744
但是只有当你不实施它们时。

1377
01:13:32,813 --> 01:13:35,146
如果你实现了一个指定的init，

1378
01:13:35,215 --> 01:13:38,984
现在你不会继承你所有的超级班。如果你

1379
01:13:39,053 --> 01:13:43,154
覆盖所有指定的父类，

1380
01:13:43,223 --> 01:13:47,926
那么你会继承其所有的con，方便的。

1381
01:13:47,995 --> 01:13:49,861
那为什么呢那是因为你的父类，

1382
01:13:49,930 --> 01:13:52,297
当它实现这些convenience inits，

1383
01:13:52,366 --> 01:13:55,534
这取决于指定的实现，

1384
01:13:55,602 --> 01:13:57,469
所以你必须实现它们。

1385
01:13:57,538 --> 01:13:59,337
当然，你可以通过实现继承它们

1386
01:13:59,406 --> 01:14:04,008
他们也不是。所以，你继承这些的任何init

1387
01:14:04,077 --> 01:14:06,611
规则可以用来满足这些其他的任何一个，

1388
01:14:06,680 --> 01:14:09,982
我们之前谈论的其他要求

1389
01:14:10,050 --> 01:14:13,151
阶段。您可以使init需要。你只是说

1390
01:14:13,220 --> 01:14:16,187
必需的init。必要的是一个关键词，这将是

1391
01:14:16,256 --> 01:14:19,424
使它这样子类必须实现该init，好吧，

1392
01:14:19,492 --> 01:14:23,628
这是必需的。可以在这里，我们谈论了这些

1393
01:14:23,697 --> 01:14:26,664
double。如果在你的init之后加上一个问号，

1394
01:14:26,733 --> 01:14:29,534
init问号，这意味着这个init可能会失败。

1395
01:14:29,603 --> 01:14:32,871
这意味着这个init，或者当你创建这个东西，

1396
01:14:32,940 --> 01:14:35,740
将返回此类的可选版本。所以

1397
01:14:35,809 --> 01:14:37,108
我们认为这是double。

1398
01:14:37,177 --> 01:14:39,878
如果我们说双括号字符串，它会返回

1399
01:14:39,947 --> 01:14:42,214
一个可选的double。这是一个可用的init，和

1400
01:14:42,282 --> 01:14:44,316
那是因为你可以说你的double，和

1401
01:14:44,384 --> 01:14:46,451
你会像“我不能把它变成double的：失败”。

1402
01:14:46,519 --> 01:14:49,421
你可以从可用的init失败的方式就是你

1403
01:14:49,489 --> 01:14:51,255
返回零点除此以外，

1404
01:14:51,324 --> 01:14:53,758
你不要从init返回任何东西，它只是初始化，

1405
01:14:53,827 --> 01:14:55,827
但有一次你回来的东西是出来的

1406
01:14:55,896 --> 01:14:58,730
一个失败的init，你可以返回nil。所以，这里的一个例子是

1407
01:14:58,799 --> 01:15:02,968
UIImage的。 UIImaged命名查找该图像

1408
01:15:03,036 --> 01:15:05,904
xe assets。记住我移动的xe assets

1409
01:15:05,973 --> 01:15:08,806
在第一个演示开始时支持文件？

1410
01:15:08,875 --> 01:15:12,044
这看起来在那里，当然可能找不到它。

1411
01:15:12,113 --> 01:15:15,614
所以我们做如果让image = UIImage（命名为“foo”），

1412
01:15:15,683 --> 01:15:17,516
那么我们做某事，否则我们失败了，

1413
01:15:17,584 --> 01:15:22,754
该UIImage初始化程序失败。好的，任何和

1414
01:15:22,822 --> 01:15:27,259
AnyObject。没有更多的init，我们完成了init。

1415
01:15:27,327 --> 01:15:31,262
Any和AnyObject：这些是类型，特殊类型。

1416
01:15:31,331 --> 01:15:35,133
这些类型几乎完全用于向后

1417
01:15:35,202 --> 01:15:39,004
与Objective C兼容，因为目标C有一个类型

1418
01:15:39,072 --> 01:15:41,740
在它称为id，这是一种像任何，

1419
01:15:41,809 --> 01:15:46,444
AnyObject其实。所以Swift需要一些兼容性，但是

1420
01:15:46,513 --> 01:15:48,980
Swift并没有真的很好用，所以

1421
01:15:49,049 --> 01:15:52,884
我们不会，Swift是强类型的。所以你不会想

1422
01:15:52,953 --> 01:15:55,553
有一种类型，它可以是任何东西。好的，因为

1423
01:15:55,622 --> 01:15:58,022
那就是Any和AnyObject，就像什么，

1424
01:15:58,091 --> 01:16:02,928
任何类型。这是一种奇怪的类型类型的事情。

1425
01:16:02,997 --> 01:16:04,062
Any和AnyObject之间的唯一区别

1426
01:16:04,131 --> 01:16:06,197
是AnyObject只能是一个类，

1427
01:16:06,266 --> 01:16:08,900
它是一个参考类型。任何可以是任何东西，

1428
01:16:08,969 --> 01:16:12,070
参考或价值类型，这是唯一的区别。

1429
01:16:12,139 --> 01:16:14,406
那么为什么我们有这些AnyObject的东西？

1430
01:16:14,475 --> 01:16:15,841
他们会在哪里出现？好，

1431
01:16:15,909 --> 01:16:18,710
有一些方法在iOS中有一个参数

1432
01:16:18,779 --> 01:16:22,847
真的可以是任何事情。这里的一个例子是你有的时候

1433
01:16:22,916 --> 01:16:25,316
多个MVC，我们将在下周学习。

1434
01:16:25,385 --> 01:16:28,687
从一个到另一个的方式，下一个叫做segueing，

1435
01:16:28,755 --> 01:16:30,622
你从一个MVC到另一个MVC。

1436
01:16:30,690 --> 01:16:33,926
并且导致一个segue发生的事情，好的，

1437
01:16:33,994 --> 01:16:37,095
是这个方法中被称为准备的参数

1438
01:16:37,164 --> 01:16:39,031
segue叫发件人(sender)，好的，

1439
01:16:39,099 --> 01:16:42,067
就像我们在IBAction中有sender一样。所以

1440
01:16:42,136 --> 01:16:44,636
sender是造成这种变化的人，

1441
01:16:44,704 --> 01:16:46,871
那么一个按钮可能会导致发生，

1442
01:16:46,940 --> 01:16:49,507
表视图(table view)中的一行可能会导致它。一些习惯

1443
01:16:49,576 --> 01:16:53,211
你的代码片段可能导致这个MVC。

1444
01:16:53,280 --> 01:16:55,914
所以当你准备好了，你必须要做

1445
01:16:55,983 --> 01:16:59,918
能说出哪一个，那就是任何一个。所以

1446
01:16:59,987 --> 01:17:02,621
如果这是一个Swift API，他们将不会做任何。

1447
01:17:02,690 --> 01:17:05,958
他们会有一个协议，你可以成为一个segue

1448
01:17:06,026 --> 01:17:09,260
sender。而你必须实现一些

1449
01:17:09,329 --> 01:17:14,099
在这里有用的功能。但在这种情况下，

1450
01:17:14,167 --> 01:17:17,302
这是任何。它知道可选任何也因为你可以有

1451
01:17:17,371 --> 01:17:20,339
没有，中心可能是零。你会在哪里看到它？

1452
01:17:20,407 --> 01:17:25,110
你可以有一个AnyObject数组或任意数组。

1453
01:17:25,178 --> 01:17:28,113
这可能是一个数组，有双重和字符串和

1454
01:17:28,182 --> 01:17:31,283
事情混在一起现在你可能会试着用这个

1455
01:17:31,352 --> 01:17:34,786
在你的作业编号中，当你看到作业。

1456
01:17:34,855 --> 01:17:35,721
但你是不允许的

1457
01:17:35,789 --> 01:17:37,789
因为所需任务之一说明您不能使用Any

1458
01:17:37,858 --> 01:17:41,493
或AnyObject。你也不会很Swifty。

1459
01:17:41,562 --> 01:17:43,461
在Swift，如果我们想把double和

1460
01:17:43,530 --> 01:17:46,265
字符串在同一个数组中，我们使用一个枚举。

1461
01:17:46,333 --> 01:17:48,200
这就是我们对我们的操作阵列所做的那样

1462
01:17:48,268 --> 01:17:51,236
我们将在Swift中做什么，所以我们不会使用AnyObject。

1463
01:17:51,305 --> 01:17:53,171
另一件事你可以使用Any for for

1464
01:17:53,240 --> 01:17:55,374
一个cookie，对，你提供的一些数据

1465
01:17:55,442 --> 01:17:57,576
你不希望人们知道这是什么类型的。

1466
01:17:57,645 --> 01:17:59,411
而且他们会在某个时候把它交给你，

1467
01:17:59,480 --> 01:18:00,578
你会和它做一些事情

1468
01:18:00,647 --> 01:18:01,379
只有你知道是什么

1469
01:18:01,448 --> 01:18:03,514
所以你知道，一种不透明的类型，你可以使用它

1470
01:18:03,583 --> 01:18:07,986
那。我们如何使用任何类型的东西，因为我们不能

1471
01:18:08,055 --> 01:18:10,822
发送任何消息给它cuz它不是AnyType，所以

1472
01:18:10,891 --> 01:18:14,426
我们不知道它做什么的任何方法。代替，

1473
01:18:14,494 --> 01:18:18,062
我们转换它，我们转换类型Any或，或

1474
01:18:18,131 --> 01:18:23,001
AnyObject进入某些类，我们知道使用as。

1475
01:18:23,070 --> 01:18:26,205
作为一个关键词，我们作为问号，因为我们没有

1476
01:18:26,273 --> 01:18:28,073
知道我们可以转换一些东西，

1477
01:18:28,142 --> 01:18:31,844
所以这是一个可选的。如果让我们使用它。

1478
01:18:31,912 --> 01:18:33,412
所以如果我有一些变量未知，

1479
01:18:33,480 --> 01:18:36,214
哪个是任何的，所以我真的不知道是什么。

1480
01:18:36,283 --> 01:18:39,284
但我认为这可能是MyType，我不知道。

1481
01:18:39,353 --> 01:18:42,487
但我认为这可能是MyType。所以我说，

1482
01:18:42,556 --> 01:18:46,825
如果让foo =未知为MyType，

1483
01:18:46,894 --> 01:18:52,197
如果让然后在里面，foo现在是未知的，

1484
01:18:52,265 --> 01:18:56,668
但作为MyType。所以我将能够

1485
01:18:56,737 --> 01:18:59,738
发送foo消息我的磁带，我将能够发送foo

1486
01:18:59,807 --> 01:19:02,341
无论MyType如何理解，方法和vars。

1487
01:19:04,311 --> 01:19:06,478
这就是我们如何使用它。我们使用这个“as？”，它被称为

1488
01:19:06,547 --> 01:19:09,614
铸件。顺便说一句，这种方式不仅适用于AnyObject，

1489
01:19:09,683 --> 01:19:12,951
我们可以投下其他的东西。例如，如果我有一个变量

1490
01:19:13,020 --> 01:19:15,987
这是vc，它是一个类型UIViewController，

1491
01:19:16,056 --> 01:19:19,324
我可以将其分配给UI，到CalculatorViewController。

1492
01:19:19,393 --> 01:19:20,325
因为CalculatorViewController是

1493
01:19:20,393 --> 01:19:21,927
UIViewController的子类。所以

1494
01:19:21,995 --> 01:19:26,031
它是一个UIViewController，所以我可以将其分配给vc。但

1495
01:19:26,099 --> 01:19:28,933
如果我这样分配，用这个打字，

1496
01:19:29,002 --> 01:19:32,604
我不能说vc.displayValue cuz vc.displayValue，

1497
01:19:32,672 --> 01:19:36,208
displayValue是CalculatorViewController中的一个var，

1498
01:19:36,277 --> 01:19:38,643
并且vc是UIViewController类型。

1499
01:19:38,712 --> 01:19:41,246
即使它指向CalculatorViewController，

1500
01:19:41,315 --> 01:19:43,681
从Swift的角度来看，它是作为vc键入的

1501
01:19:43,750 --> 01:19:47,753
Swift是强类型的。所以如果我想发送displayValue，

1502
01:19:47,821 --> 01:19:50,655
我不得不说，如果我可以让calcVC = vc

1503
01:19:50,724 --> 01:19:55,127
作为CalculatorViewController现在我可以发送displayValue到

1504
01:19:55,195 --> 01:19:59,598
calcVC。 Cuz是你实际的类型

1505
01:19:59,667 --> 01:20:02,234
键入它的重要性，而不是它指向什么。那么你

1506
01:20:02,302 --> 01:20:04,870
必须使用它来使它成为你真正的东西

1507
01:20:04,939 --> 01:20:08,606
想用好的，我会去这里一点点。

1508
01:20:08,675 --> 01:20:11,376
如果你必须去，那就好了，只要保持安静。

1509
01:20:11,445 --> 01:20:13,778
我要谈的最后一件事是用户默认。

1510
01:20:13,847 --> 01:20:15,647
用户默认是非常轻量级的，

1511
01:20:15,716 --> 01:20:19,618
有限数据库。这是一个仍然存在的小数据库

1512
01:20:19,687 --> 01:20:21,687
在您的应用程序启动之间。这是非常好的

1513
01:20:21,756 --> 01:20:23,255
像这样的设置和东西。

1514
01:20:23,323 --> 01:20:26,424
不要把大的东西放在那里唯一可以做的事情

1515
01:20:26,493 --> 01:20:29,227
放在这个数据库里就是所谓的属性列表。

1516
01:20:29,296 --> 01:20:32,331
属性列表只是指数组的任意组合，

1517
01:20:32,399 --> 01:20:34,133
字典，字符串，日期，数据或

1518
01:20:34,201 --> 01:20:37,702
一个数字，像int，float，double，无论如何。

1519
01:20:37,771 --> 01:20:40,038
这就是属性列表。这只是概念。

1520
01:20:40,107 --> 01:20:42,707
没有实际的类型属性列表，不幸的是。

1521
01:20:42,776 --> 01:20:45,910
如果这是一个Swift API，它可能会是这样一种类型。

1522
01:20:45,979 --> 01:20:48,180
它可能是一个协议。但无论如何，没有。

1523
01:20:48,248 --> 01:20:51,883
这是Objective-C。所以，因为没有类型

1524
01:20:51,952 --> 01:20:55,287
这代表了类的鳕鱼，

1525
01:20:55,355 --> 01:20:58,823
我将显示用户默认值的API使用Any。和

1526
01:20:58,892 --> 01:21:01,593
这是它的样子。它有这个核心，设置和

1527
01:21:01,662 --> 01:21:05,931
得到。设置任何？现在任何不能真的是任何，

1528
01:21:06,000 --> 01:21:07,933
它必须是这些类型之一，字符串，字典，

1529
01:21:08,001 --> 01:21:09,601
数组，无论如何，它必须是属性列表，

1530
01:21:09,670 --> 01:21:13,004
forKey字符串。所以你只是把它，任何你想要的

1531
01:21:13,073 --> 01:21:14,506
在这个数据库中有一定的关键。

1532
01:21:14,575 --> 01:21:16,641
然后你通过说，对象的关键，和

1533
01:21:16,710 --> 01:21:19,210
它会给你一个Any。这是一个可选的任何因为

1534
01:21:19,279 --> 01:21:20,445
它可能不在数据库中，

1535
01:21:20,514 --> 01:21:23,247
在其中返回无。所以它说除了

1536
01:21:23,316 --> 01:21:27,286
它不是真的任何，它是任何只要属性列表，

1537
01:21:27,354 --> 01:21:29,521
这意味着它是这十个类别之一

1538
01:21:29,590 --> 01:21:32,123
随你。你读的方式和

1539
01:21:32,192 --> 01:21:35,427
写它，你不会通过说let来创建一个用户默认

1540
01:21:35,496 --> 01:21:37,595
x等于用户默认值与括号。

1541
01:21:37,664 --> 01:21:41,533
你说let defaults = UserDefaults.standard，所以

1542
01:21:41,601 --> 01:21:45,270
这是用户默认结构体的类型var。

1543
01:21:45,339 --> 01:21:47,572
你得到这个标准的UserDefaults和

1544
01:21:47,641 --> 01:21:49,541
那么你可以发送它像东西，

1545
01:21:49,610 --> 01:21:52,410
那个我告诉你的东西，设置任何。和这里，

1546
01:21:52,479 --> 01:21:55,446
我有三套不同的set，其中一套是double，

1547
01:21:55,515 --> 01:21:58,016
一个设置一个int数组。一个int数组是可以的

1548
01:21:58,085 --> 01:22:01,086
因为数组是属性列表的一部分。 int也是如此，

1549
01:22:01,155 --> 01:22:04,355
所以没关系这是一个属性列表。数组

1550
01:22:04,424 --> 01:22:06,424
的ints是属性列表，属性列表。那么是一个双，

1551
01:22:06,493 --> 01:22:09,061
这是这些类型之一。我只是把它们放在那里

1552
01:22:09,129 --> 01:22:12,497
然后当我把它们拿出来的时候，我用这个对象来关键。

1553
01:22:12,565 --> 01:22:14,432
实际上对于一些常见的类型，

1554
01:22:14,501 --> 01:22:17,202
像double，阵列和字典，实际上是

1555
01:22:17,271 --> 01:22:19,905
一个很好的小方法在那里给你那种类型。

1556
01:22:19,973 --> 01:22:23,441
那就是你没有得到任何回来

1557
01:22:23,510 --> 01:22:26,778
那么不得不做。因为你知道对象

1558
01:22:26,847 --> 01:22:29,547
键返回一个任何，直到你给这个Any和

1559
01:22:29,616 --> 01:22:32,217
你必须去，如果这件事情有一个double的，

1560
01:22:32,286 --> 01:22:34,286
那我得到了那会很讨厌相反，

1561
01:22:34,354 --> 01:22:36,789
它只是一个叫做double的方法

1562
01:22:36,857 --> 01:22:40,825
您。如果你失败了，我也想，

1563
01:22:40,894 --> 01:22:43,094
我不知道如果它返回一个double或一个可选的double，

1564
01:22:43,163 --> 01:22:45,930
但是你可能会返回零，你可能会没有。

1565
01:22:45,999 --> 01:22:49,201
我不记得了。但是对于字典中的数组，

1566
01:22:49,269 --> 01:22:52,804
一些有趣的事情要注意。明显，

1567
01:22:52,873 --> 01:22:56,074
在字典中的数组内的Anys，

1568
01:22:56,143 --> 01:22:59,077
那些也将是属性列表，事情

1569
01:22:59,145 --> 01:23:01,446
被归还给你。还知道字典，

1570
01:23:01,514 --> 01:23:03,915
这种方便词典，

1571
01:23:03,984 --> 01:23:07,552
这是字典永远是字典中的关键。

1572
01:23:07,621 --> 01:23:12,157
如果你有一个字典的键是说，ints。

1573
01:23:12,226 --> 01:23:14,926
我认为这是一个有效的钥匙，是的，在字典中，是的，

1574
01:23:14,995 --> 01:23:18,029
它是。那么你不会使用这种方便的方法。

1575
01:23:18,098 --> 01:23:21,867
你必须使用对象的键，然后用来转动它

1576
01:23:21,936 --> 01:23:26,971
回到一个有int键的字典。

1577
01:23:27,040 --> 01:23:29,307
保存数据库是自动保存的，所以你实际上是这样

1578
01:23:29,376 --> 01:23:31,276
不必保存它。如果你想强迫它保存，因为

1579
01:23:31,344 --> 01:23:33,144
你担心自动保存可能不会发生。

1580
01:23:33,213 --> 01:23:35,413
你会退出你的程序或东西，你可以使用这个

1581
01:23:35,482 --> 01:23:37,382
方法同步。它被称为同步默认值。

1582
01:23:37,451 --> 01:23:40,586
它将同步它。这几乎是断言。

1583
01:23:40,654 --> 01:23:44,222
对不起，最后一件事。断言只是一点点

1584
01:23:44,291 --> 01:23:48,360
Swift函数需要一个闭包作为第一个参数

1585
01:23:48,429 --> 01:23:51,596
和一个消息作为第二个参数。

1586
01:23:51,665 --> 01:23:55,400
它所做的只是执行关闭。如果这返回真，

1587
01:23:55,469 --> 01:23:58,437
它不会崩溃您的程序。如果它返回false，

1588
01:23:58,505 --> 01:24:02,006
它会崩溃您的程序并打印出该消息。所以

1589
01:24:02,075 --> 01:24:06,778
你可以知道一些验证电话。这一行

1590
01:24:06,847 --> 01:24:10,215
代码甚至不会在您的应用程序版本中执行

1591
01:24:10,284 --> 01:24:12,618
你在应用商店出货。当您构建应用程序时

1592
01:24:12,686 --> 01:24:15,086
释放，断言被完全忽视。

1593
01:24:15,155 --> 01:24:17,890
它甚至没有实际关闭，更不用说崩溃了。

1594
01:24:17,958 --> 01:24:20,592
它只是忽略它们，所以这只是一个调试的东西，

1595
01:24:20,661 --> 01:24:24,863
好的？而已！周五，

1596
01:24:24,932 --> 01:24:27,899
我们有星期五的会议，这是在正常的时候。和

1597
01:24:27,968 --> 01:24:29,568
它将是源代码管理。

1598
01:24:29,637 --> 01:24:33,471
一个非常酷的方法来管理你的代码，即使你只是

1599
01:24:33,540 --> 01:24:36,074
一个程序员自己从事一个项目。接着

1600
01:24:36,143 --> 01:24:39,010
下周我将谈谈做自定义绘图

1601
01:24:39,079 --> 01:24:42,447
在你自己的看法。多点触摸，如捏和滑动，和

1602
01:24:42,516 --> 01:24:45,450
像这样的东西。最后，多个MVC呢

1603
01:24:45,519 --> 01:24:48,119
我们可以建立一个更强大的计算器。

1604
01:24:48,188 --> 01:24:51,123
你的任务二已经出去了。已经发布。

1605
01:24:51,191 --> 01:24:54,259
它本质上增强了你的计算器很多

1606
01:24:54,328 --> 01:24:57,129
今天我讨论的事情就像元组和

1607
01:24:57,198 --> 01:24:59,831
默认值，甚至值类型。

1608
01:24:59,899 --> 01:25:01,934
各种东西所以我们会很有趣的。

1609
01:25:03,237 --> 01:25:03,935
>>更多，

1610
01:25:04,004 --> 01:25:12,510
请访问我们的standford.edu


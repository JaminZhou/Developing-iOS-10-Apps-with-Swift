1
00:00:00,401 --> 00:00:04,502
[MUSIC]

2
00:00:04,571 --> 00:00:07,372
斯坦福大学

3
00:00:07,441 --> 00:00:11,075
>> 欢迎来到斯坦福CS193P，

4
00:00:11,144 --> 00:00:15,714
那就是开发iOS应用，到2017年冬天。

5
00:00:15,782 --> 00:00:20,785
所以今天我们的主题是谈谈自定义的视图，好的，

6
00:00:20,854 --> 00:00:25,123
具体是具有自定义视图的视图。

7
00:00:25,192 --> 00:00:28,193
这将是一个更典型的演讲

8
00:00:28,262 --> 00:00:30,762
因为我会做一些幻灯片和

9
00:00:30,831 --> 00:00:32,964
向你解释这些概念，

10
00:00:33,033 --> 00:00:36,301
那么我将进行一个演示，向您展示我们如何做到这一点。

11
00:00:36,370 --> 00:00:39,104
那有什么看法？

12
00:00:39,173 --> 00:00:42,540
视图(view)是UIView的一个子类，

13
00:00:42,609 --> 00:00:45,643
这是iOS中的UIKit。

14
00:00:45,712 --> 00:00:48,313
它所做的一切都是雕刻出来

15
00:00:48,382 --> 00:00:51,883
表示屏幕上的矩形区域。

16
00:00:51,952 --> 00:00:55,019
并且该矩形区域定义坐标空间

17
00:00:55,088 --> 00:00:57,990
我们要吸收，我们会得到

18
00:00:58,058 --> 00:01:00,124
多点触摸事件，如捏和

19
00:01:00,193 --> 00:01:01,660
滑动和所有的东西。

20
00:01:01,728 --> 00:01:03,095
所以今天，

21
00:01:03,163 --> 00:01:06,131
我只会专注于这一切的绘画方面

22
00:01:06,199 --> 00:01:09,268
那么我们星期三就会开始谈论手势。

23
00:01:10,537 --> 00:01:14,439
所以这些意见，这些小的矩形区域

24
00:01:14,508 --> 00:01:17,542
以这种分层方式放在屏幕上。

25
00:01:17,611 --> 00:01:20,779
这只是意味着观点有子视图

26
00:01:20,847 --> 00:01:21,913
在他们的内部

27
00:01:21,982 --> 00:01:25,450
现在任何给定的视图只能有一个父视图，

28
00:01:25,519 --> 00:01:27,185
这就是它所包含的观点。

29
00:01:27,254 --> 00:01:29,054
但它可以有任何数量的子视图，

30
00:01:29,123 --> 00:01:30,689
所以看出来的意见。

31
00:01:30,758 --> 00:01:33,324
所以例如，在计算器上，我们已经有了

32
00:01:33,393 --> 00:01:35,493
例如，堆栈视图(stack view)，好的。

33
00:01:35,562 --> 00:01:37,195
它有很多子视图，

34
00:01:37,264 --> 00:01:38,897
我们堆叠的所有按钮。

35
00:01:38,965 --> 00:01:41,400
事实上，一些堆栈视图具有其他堆栈视图

36
00:01:41,468 --> 00:01:42,067
他们的子视图。

37
00:01:42,135 --> 00:01:44,302
然后那些堆栈视图有更多的子视图，

38
00:01:44,371 --> 00:01:45,771
这些都是按钮或者什么，好的。

39
00:01:45,839 --> 00:01:49,674
这就是我们如何构建我们的UI是这种层次结构

40
00:01:49,743 --> 00:01:52,077
收集这些矩形区域。

41
00:01:52,145 --> 00:01:56,014
现在，在非常非常非常高的顶端有一个特殊的UIView

42
00:01:56,083 --> 00:01:59,751
称为UIWindow类，我们不在iOS中处理。

43
00:01:59,820 --> 00:02:03,021
事实上，你唯一可以做任何事情的时间

44
00:02:03,090 --> 00:02:06,491
UIWindow是如果你正在构建一个可能的应用程序

45
00:02:06,560 --> 00:02:08,193
投影到投影机。

46
00:02:08,261 --> 00:02:10,328
所以你有两个屏幕，你的设备和

47
00:02:10,397 --> 00:02:11,963
那么也许一些外部投影机或

48
00:02:12,032 --> 00:02:14,199
那么你可能会关心UIWindow。

49
00:02:14,268 --> 00:02:17,069
但否则，这一切都是关于UIView的，好吗？

50
00:02:17,137 --> 00:02:19,871
我们所有的屏幕安排都是关于我们如何

51
00:02:19,940 --> 00:02:22,574
安排UIViews。

52
00:02:22,642 --> 00:02:25,444
现在这个层次结构，好的，这些矩形区域里面

53
00:02:25,512 --> 00:02:28,680
的矩形区域，几乎总是建成的

54
00:02:28,749 --> 00:02:31,316
在Interface Builder里面的Xcode，好吗？

55
00:02:31,385 --> 00:02:32,817
这就是我们如何构建堆栈视图的东西。

56
00:02:32,886 --> 00:02:34,752
我们拖了一大堆按钮

57
00:02:34,821 --> 00:02:35,920
然后我们选了他们说，

58
00:02:35,989 --> 00:02:38,890
“Embed in Stack View”。那包裹在那里

59
00:02:38,959 --> 00:02:42,094
但是我们也可以通过拖动视图来构建该层次结构

60
00:02:42,162 --> 00:02:43,929
出于公用事业，

61
00:02:43,997 --> 00:02:47,132
在其中的实用程序窗口底部，其他视图内。

62
00:02:47,200 --> 00:02:48,132
所以你可以拖动，

63
00:02:48,201 --> 00:02:51,703
通过拖放到其他视图中进行。

64
00:02:51,772 --> 00:02:53,338
可以在代码中做到这一点

65
00:02:53,407 --> 00:02:55,207
通常我们以图形方式进行。

66
00:02:55,276 --> 00:02:56,375
如果你在代码中这样做，

67
00:02:56,443 --> 00:03:00,912
构建的两个主要方法

68
00:03:00,981 --> 00:03:05,050
摧毁这个层次结构，是addSubview，好的，

69
00:03:05,119 --> 00:03:07,418
addSubview，以视图为参数。

70
00:03:07,487 --> 00:03:11,489
你把它发送到“soon-to-be"”的父视图

71
00:03:11,558 --> 00:03:12,708
换句话说，你又问一个视图，

72
00:03:12,709 --> 00:03:13,859
视图

73
00:03:13,927 --> 00:03:16,928
请将其他视图添加为自己的子视图。

74
00:03:16,996 --> 00:03:19,864
现在当你正在做相反的事情时，请看一下

75
00:03:19,933 --> 00:03:22,467
的层次结构，您不会将其发送到父视图。

76
00:03:22,536 --> 00:03:24,436
您将其发送到实际视图本身，

77
00:03:24,505 --> 00:03:27,305
基本上从这个视图层次结构中删除自己

78
00:03:27,374 --> 00:03:29,507
所以你发送removeFromSuperview

79
00:03:29,576 --> 00:03:31,977
到你想要删除的实际视图。

80
00:03:33,280 --> 00:03:35,347
现在这个层次结构何时开始了？

81
00:03:35,415 --> 00:03:37,048
我想你可以说它从UIWindow开始。

82
00:03:37,117 --> 00:03:39,517
但为了我们的目的，我们甚至没有注意到这一点。

83
00:03:39,586 --> 00:03:42,054
它从顶层视图开始

84
00:03:42,122 --> 00:03:44,956
在Interface Builder中的那个场景中。

85
00:03:45,025 --> 00:03:47,225
由我们的视图控制器控制的场景，对吧？

86
00:03:47,294 --> 00:03:49,527
我们工作的矩形区域。

87
00:03:49,596 --> 00:03:50,261
有一个顶部，

88
00:03:50,330 --> 00:03:54,499
覆盖整个空间的顶级视图。

89
00:03:54,567 --> 00:03:56,701
还有一个重要的实例变量，

90
00:03:56,770 --> 00:03:59,771
属性，在UIViewController中。

91
00:03:59,840 --> 00:04:02,907
好的，所以UIViewController的所有子类都可以得到

92
00:04:02,976 --> 00:04:03,842
这个性质。

93
00:04:03,910 --> 00:04:07,946
它被称为视图，它是一个UIView和一个顶级视图。

94
00:04:08,015 --> 00:04:12,084
而非常重要的是要明白，在MVC中，

95
00:04:12,152 --> 00:04:15,520
控制器有这个，总是有这个var

96
00:04:15,589 --> 00:04:20,459
指向其场景中该视图层次结构的最顶层。

97
00:04:22,429 --> 00:04:25,430
这个顶级视图很重要，因为例如，

98
00:04:25,499 --> 00:04:28,599
当你旋转时，它的边界改变了，

99
00:04:28,668 --> 00:04:29,801
那个顶级视图。

100
00:04:29,870 --> 00:04:32,336
而且你会在稍后学习一下

101
00:04:32,405 --> 00:04:35,606
视图的界限发生变化，有一个机制

102
00:04:35,675 --> 00:04:39,043
为其所有子视图提供改变的机会。

103
00:04:39,112 --> 00:04:40,712
所以这就是为什么当我们旋转设备时，

104
00:04:40,781 --> 00:04:43,281
顶级视图从高到高变化

105
00:04:43,350 --> 00:04:47,085
薄到宽而不高。

106
00:04:47,154 --> 00:04:49,654
这导致所有这些堆栈视图和

107
00:04:49,723 --> 00:04:52,123
其他一切都开始调整大小，

108
00:04:52,192 --> 00:04:56,361
因为他们都是这个顶级视图的子视图，好吗？

109
00:04:56,430 --> 00:04:59,497
如果要将视图添加到视图层次结构

110
00:04:59,566 --> 00:05:01,866
以编程方式，而不是拖动和

111
00:05:01,935 --> 00:05:04,502
放弃它们，那么你会需要这个视图，因为它是

112
00:05:04,571 --> 00:05:06,204
整个视图层次结构的顶部。

113
00:05:06,273 --> 00:05:07,606
你会有点工作你的方式

114
00:05:07,674 --> 00:05:09,907
以了解您想要放置该视图的位置。

115
00:05:09,976 --> 00:05:12,410
但是我们其实并没有看这个观点

116
00:05:12,479 --> 00:05:14,846
很多因为我们通常有网点，权利？

117
00:05:14,915 --> 00:05:17,982
IBOutlets  - 就像指向标签的显示器那样

118
00:05:18,051 --> 00:05:19,484
让我们访问该标签。

119
00:05:19,552 --> 00:05:20,451
那就是我们想要的，所以

120
00:05:20,520 --> 00:05:22,988
我们不必去看顶级视图

121
00:05:23,056 --> 00:05:26,290
看全部看法，好吗？

122
00:05:26,359 --> 00:05:28,059
所以这是很重要的知道，但是

123
00:05:28,128 --> 00:05:31,896
令人惊讶的是，你不会访问这么多，好的。

124
00:05:31,965 --> 00:05:33,764
这个视图会自动挂起来

125
00:05:33,833 --> 00:05:35,967
拖出View Controller时的Interface Builder。

126
00:05:36,035 --> 00:05:38,002
这只是魔术般的挂钩，

127
00:05:38,071 --> 00:05:40,071
你不用担心。

128
00:05:40,140 --> 00:05:43,241
好的，我们来谈谈UIView的初始化。

129
00:05:43,309 --> 00:05:46,378
像往常一样，当你看到上次的演讲时，

130
00:05:46,446 --> 00:05:49,981
你可能意识到，呃，初始化有很多

131
00:05:50,049 --> 00:05:54,152
当你在谈论初始化一个课程时的注意事项，

132
00:05:54,220 --> 00:05:55,170
记得我经历的所有规则吗？

133
00:05:55,171 --> 00:05:56,121
对？

134
00:05:56,189 --> 00:06:00,224
所需的方便及其继承，所有这些东西。

135
00:06:00,293 --> 00:06:02,960
所以我们尽量避免初始化器一样多

136
00:06:03,029 --> 00:06:05,963
我们可以通过做我所说的所有事情

137
00:06:06,032 --> 00:06:07,932
大约在星期三，就像设置平等或者

138
00:06:08,001 --> 00:06:10,501
甚至使用懒惰或类似的东西。

139
00:06:10,570 --> 00:06:12,170
但是如果你不能避免，

140
00:06:12,239 --> 00:06:14,873
UIView有一个有趣的初始化器情况。

141
00:06:14,942 --> 00:06:19,343
它有两个初始化器，你必须处理。

142
00:06:19,412 --> 00:06:22,513
好的，其中一个，init，与框架是争论，是

143
00:06:22,582 --> 00:06:25,549
如果您正在尝试创建视图，您将会调用它

144
00:06:25,618 --> 00:06:30,155
在代码中，你可能永远不会在这个类中，好吗？

145
00:06:30,223 --> 00:06:31,555
因为你总是会使用或

146
00:06:31,624 --> 00:06:33,425
在Interface Builder中使用Xcode。

147
00:06:33,494 --> 00:06:37,261
但是，这就是代码中的一种。

148
00:06:37,330 --> 00:06:40,097
和init这个编码器的东西，

149
00:06:40,166 --> 00:06:41,566
我将在课堂结束时谈谈，

150
00:06:41,635 --> 00:06:44,302
但早期知道并不重要。

151
00:06:44,371 --> 00:06:47,371
这就是当你的东西来时被调用的init

152
00:06:47,440 --> 00:06:48,874
Interface Builder，对吧？

153
00:06:48,942 --> 00:06:52,377
当它来自，当你建立在Xcode。

154
00:06:52,445 --> 00:06:54,312
您在Interface Builder中构建的所有内容

155
00:06:54,381 --> 00:06:56,214
基本上是编码，

156
00:06:56,283 --> 00:06:58,383
这就是这个编码业务。

157
00:06:58,451 --> 00:07:02,553
将其编码为XML文件，冻干。

158
00:07:02,622 --> 00:07:05,323
然后当你运行你的程序，那个XML文件得到

159
00:07:05,392 --> 00:07:07,591
加载了它的指示

160
00:07:07,660 --> 00:07:10,929
如何创建所有这些对象，好吗？

161
00:07:10,998 --> 00:07:12,864
而使用编码器的init是它使用的初始化器

162
00:07:12,932 --> 00:07:14,232
重新创建视图。

163
00:07:14,301 --> 00:07:17,402
所以如果你有任何需要进入初始化程序的代码，

164
00:07:17,471 --> 00:07:19,804
像你需要在你的UIView中初始化一些var，

165
00:07:19,873 --> 00:07:21,806
你必须这样做。

166
00:07:21,875 --> 00:07:23,741
覆盖这两个inits，

167
00:07:23,810 --> 00:07:26,911
其中一个是必需的init，编码器一个。

168
00:07:26,980 --> 00:07:29,780
而且我们还创建了一些这样的绿色设置

169
00:07:29,849 --> 00:07:30,615
我有方法

170
00:07:30,683 --> 00:07:33,118
而且只是从这两个方法中调用这个方法。

171
00:07:33,186 --> 00:07:35,653
这样你就可以保证你的自定义视图

172
00:07:35,722 --> 00:07:38,156
在代码中创建或在Interface Builder中创建，

173
00:07:38,224 --> 00:07:43,694
它将被正确初始化。

174
00:07:43,763 --> 00:07:46,697
如果你有vars必须被初始化，你可能不是

175
00:07:46,766 --> 00:07:49,501
当然可以使用这种机制，因为你不能

176
00:07:49,569 --> 00:07:52,337
自己调用方法，直到你初始化为止。

177
00:07:52,406 --> 00:07:55,706
所以你可能必须有这个var初始化

178
00:07:55,775 --> 00:07:58,142
有些重复在那里

179
00:07:58,211 --> 00:08:00,978
还有另外一种初始化的选择，而这个

180
00:08:01,047 --> 00:08:03,514
是用于从Interface Builder出来的任何其他对象

181
00:08:03,583 --> 00:08:05,583
这叫做awakeFromNib。

182
00:08:05,652 --> 00:08:07,018
好的，awakeFromNib。

183
00:08:07,087 --> 00:08:09,554
这被发送到每一个出来的对象

184
00:08:09,623 --> 00:08:12,491
的Interface Builder文件，好的，你编辑

185
00:08:12,559 --> 00:08:14,125
在故事板(story board)上，包括意见和

186
00:08:14,194 --> 00:08:15,426
您的View Controller就此而言。

187
00:08:15,495 --> 00:08:19,664
那么

188
00:08:19,733 --> 00:08:22,634
“你的对象必须被完全初始化”。

189
00:08:22,702 --> 00:08:26,271
这些限制不满足于此。

190
00:08:26,339 --> 00:08:28,940
但是你仍然可以把代码放在那里，你会得到，去。

191
00:08:29,009 --> 00:08:30,475
我们要学习各种各样的方法

192
00:08:30,544 --> 00:08:32,944
初始化我们整个系统的路上，

193
00:08:33,013 --> 00:08:35,514
但是基本上你如何初始化UIViews。

194
00:08:37,250 --> 00:08:40,085
好的，我们现在谈谈UIView

195
00:08:40,153 --> 00:08:43,287
作为我们将要绘制的这个矩形区域。

196
00:08:43,356 --> 00:08:45,256
所以要这样做，我们需要谈论一些类型。

197
00:08:45,324 --> 00:08:47,492
它们是您需要知道的一些非常重要的类型。

198
00:08:47,561 --> 00:08:49,627
其中一个是CGFloat。

199
00:08:49,696 --> 00:08:51,796
所以CGFloat是一个浮点值。

200
00:08:51,865 --> 00:08:54,665
你将要绘制的所有坐标

201
00:08:54,734 --> 00:08:57,668
都是浮点值，但它们不是双精度值(doubles)，

202
00:08:57,737 --> 00:09:00,238
他们不是floats，他们是CGFloats。

203
00:09:00,307 --> 00:09:01,206
所以这是一种类型，

204
00:09:01,274 --> 00:09:04,142
一个真正的类型，你必须使用所有的时间

205
00:09:04,210 --> 00:09:06,378
当你做任何图画，好吗？

206
00:09:07,347 --> 00:09:08,947
CG代表Core Graphics，

207
00:09:09,016 --> 00:09:11,916
这是“graphics float”在这里，好吗？

208
00:09:11,985 --> 00:09:15,553
还有一个CGPoint，它只是一个有两个的结构

209
00:09:15,622 --> 00:09:18,956
其中的东西，x和y，他们都是CGFloats，CGPoint

210
00:09:19,025 --> 00:09:21,993
代表你坐标系中某一点。

211
00:09:22,061 --> 00:09:24,395
再次，浮点坐标。

212
00:09:24,464 --> 00:09:27,465
还有CGSize，它代表一个程度。

213
00:09:27,534 --> 00:09:29,134
你知道，宽度和高度，好吗？

214
00:09:29,202 --> 00:09:32,370
只有它只是结构体，有两个CGFloats，宽度和

215
00:09:32,438 --> 00:09:33,805
高度，简单。

216
00:09:33,874 --> 00:09:36,775
还有CGRect，当然是一个矩形。

217
00:09:36,843 --> 00:09:39,844
它是一个具有以原点的结构体，它是CGPoint，和

218
00:09:39,913 --> 00:09:41,445
一个程度，这是一个大小。

219
00:09:41,514 --> 00:09:44,282
所以一个矩形代表一个大小，好吗？

220
00:09:44,350 --> 00:09:47,585
所以创建一个CGRect  - 实际上有很多

221
00:09:47,654 --> 00:09:48,953
初始化器为它。

222
00:09:49,021 --> 00:09:50,087
您可以创建一个起源和大小，

223
00:09:50,156 --> 00:09:52,490
你可以做一个具有高度的xy，这样的东西。

224
00:09:52,559 --> 00:09:54,792
而CGRect也有很多很酷，

225
00:09:54,861 --> 00:09:59,630
一点点便利vars和funcs和这样的东西。

226
00:09:59,699 --> 00:10:01,399
maxY，midY，那些会告诉你的事情就像左边的地方

227
00:10:01,400 --> 00:10:03,100
像minX一样，

228
00:10:03,169 --> 00:10:06,370
你的直线的边缘到顶部到左边或者底部。

229
00:10:06,439 --> 00:10:08,239
中点等

230
00:10:08,308 --> 00:10:11,976
还有很好的功能，如相交其他rect

231
00:10:12,044 --> 00:10:14,846
将返回两个矩形是否交叉。

232
00:10:14,915 --> 00:10:18,182
甚至包含一点

233
00:10:18,251 --> 00:10:20,351
在矩形内等

234
00:10:20,420 --> 00:10:22,253
所以有不少这些。

235
00:10:22,322 --> 00:10:23,587
我不能把它们全部放在幻灯片上，所以

236
00:10:23,656 --> 00:10:27,024
你会想要自己熟悉CGRect。

237
00:10:27,093 --> 00:10:28,827
因为它可能有很多东西在那里

238
00:10:28,895 --> 00:10:31,162
否则你会写你自己的代码来做。

239
00:10:32,465 --> 00:10:34,164
好的，现在我们有这些类型，

240
00:10:34,233 --> 00:10:36,734
这四种类型，我们可以开始谈论这个坐标

241
00:10:36,803 --> 00:10:39,104
系统，我们将要做我们的绘图。

242
00:10:39,172 --> 00:10:40,805
现在，最重要的是要明白，

243
00:10:40,874 --> 00:10:43,808
最简单的事情就是这个坐标的起源

244
00:10:43,877 --> 00:10:47,211
系统位于屏幕的左上方。

245
00:10:47,280 --> 00:10:50,481
这不是起源所在的笛卡尔坐标

246
00:10:50,550 --> 00:10:52,716
屏幕的左下角，因为在笛卡尔坐标

247
00:10:52,785 --> 00:10:54,986
坐标增加y意味着，但是

248
00:10:55,054 --> 00:10:57,255
在这个坐标系增加y意味着下降，

249
00:10:57,323 --> 00:10:59,156
在屏幕下，好吗？

250
00:10:59,225 --> 00:11:00,625
非常重要的是要明白这一点。

251
00:11:00,693 --> 00:11:06,063
所以你可以看到这一点我已经在那里，500,35就是这样

252
00:11:06,132 --> 00:11:11,302
从原来的左上方的500个和35下降，好吗？

253
00:11:11,371 --> 00:11:15,874
现在，我们画的这些单位是积分。

254
00:11:15,942 --> 00:11:19,043
好的，要小心，你明白单位

255
00:11:19,112 --> 00:11:21,245
这里的术语好吗？

256
00:11:21,314 --> 00:11:23,281
它在点，而不是像素。

257
00:11:23,349 --> 00:11:26,784
一个像素就像最小的可能的小灯

258
00:11:26,853 --> 00:11:29,120
可以在屏幕上打开它。

259
00:11:29,189 --> 00:11:33,023
好的，现在有些设备有很多像素

260
00:11:33,092 --> 00:11:36,394
每点 - 他们非常密集。

261
00:11:36,462 --> 00:11:39,030
这真的很棒，因为如果你画画

262
00:11:39,098 --> 00:11:41,899
平滑的曲线 - 就像字体一样

263
00:11:41,968 --> 00:11:44,568
平滑的曲线被画 - 你不会有锯齿状的边缘，

264
00:11:44,637 --> 00:11:47,204
因为有这么多小点，好吗？

265
00:11:47,273 --> 00:11:50,308
但是我们不能做，所以我们画在像素空间，

266
00:11:50,377 --> 00:11:54,111
否则，在非常密集的像素屏幕上，

267
00:11:54,180 --> 00:11:55,980
我们的形象真的很小。

268
00:11:56,049 --> 00:11:57,815
然后，在一个不重要的，这将是非常大的，

269
00:11:57,883 --> 00:11:59,217
因为像素真的很大。

270
00:11:59,285 --> 00:12:01,419
所以我们不是画像，

271
00:12:01,488 --> 00:12:03,154
我们画点，好吗？

272
00:12:03,222 --> 00:12:05,757
这是同样的点，就像这样

273
00:12:05,825 --> 00:12:06,558
字体大小

274
00:12:06,626 --> 00:12:11,162
一个12点字体，同一个字在那里，同一点，好吗？

275
00:12:12,932 --> 00:12:16,601
所以，您可以找出每个像素有多少

276
00:12:16,669 --> 00:12:19,304
点，换句话说你的屏幕是多高分辨率，

277
00:12:19,372 --> 00:12:23,508
用这个var在UIView中称为contentScaleFactor。

278
00:12:23,576 --> 00:12:25,710
这是一个CGFloat，它要么是1，2，或

279
00:12:25,778 --> 00:12:27,044
3目前。

280
00:12:27,113 --> 00:12:29,480
喜欢，iPhone 7 Plus是3。

281
00:12:29,549 --> 00:12:32,216
每个方向每点3个像素。

282
00:12:32,284 --> 00:12:37,088
老年人可能是iPhone 4？

283
00:12:37,156 --> 00:12:39,457
也许一路回到4将是1个。

284
00:12:39,525 --> 00:12:42,193
好的，一些较旧的iPad将会是1个。

285
00:12:42,262 --> 00:12:44,495
较新的iPad将是2个。

286
00:12:44,563 --> 00:12:45,863
所以，如果你做任何你必须支付的东西

287
00:12:45,864 --> 00:12:47,164
好的？

288
00:12:47,233 --> 00:12:49,033
注意点数的像素数，

289
00:12:49,101 --> 00:12:50,167
这是你需要的。

290
00:12:50,236 --> 00:12:52,770
现在好了，大部分时候你都不在乎

291
00:12:52,838 --> 00:12:55,773
因为当您使用iOS绘制字体时，

292
00:12:55,841 --> 00:12:58,642
它会自动做超级光滑的转弯，而且

293
00:12:58,711 --> 00:13:00,978
你甚至不必知道比例因子是多少。

294
00:13:01,047 --> 00:13:02,846
即使你只是画一个弧，

295
00:13:02,915 --> 00:13:06,083
它会确保你做尽可能少的锯齿。

296
00:13:06,152 --> 00:13:07,785
所以，你很少知道这一点。

297
00:13:07,853 --> 00:13:09,753
但实际上，醒来。

298
00:13:09,822 --> 00:13:11,355
你需要知道作业3，好吗？

299
00:13:11,424 --> 00:13:13,857
所以作业三，你将不得不知道这一点。

300
00:13:13,926 --> 00:13:17,027
好的，现在

301
00:13:17,096 --> 00:13:21,965
所有UIView中最重要的var都是这个：bounds。

302
00:13:22,034 --> 00:13:25,135
即使在那个真正重要的var，

303
00:13:25,204 --> 00:13:29,273
真的你关心的是大小。

304
00:13:29,342 --> 00:13:32,576
这是在你的绘图坐标系中，

305
00:13:32,645 --> 00:13:34,378
你必须画的空间。

306
00:13:34,447 --> 00:13:37,515
这基本上是您自己的图纸中您的视图的大小

307
00:13:37,584 --> 00:13:38,683
坐标系。

308
00:13:38,752 --> 00:13:40,818
所以任何时候你做任何绘图和

309
00:13:40,887 --> 00:13:43,688
你想画一些像你的观点一样广泛的东西，

310
00:13:43,757 --> 00:13:46,223
你会在这里使用bounds.size.width。

311
00:13:46,292 --> 00:13:49,560
而且你几乎总是会有你的界限

312
00:13:49,628 --> 00:13:52,897
（0，0），所以如果你想把东西放在左上角你是

313
00:13:52,966 --> 00:13:56,200
将它放在（0，0）或接近（0，0）。

314
00:13:56,268 --> 00:13:57,334
所以这个直截了当，

315
00:13:57,403 --> 00:13:59,336
正在描述该地区必须吸取的内容。

316
00:13:59,405 --> 00:14:01,839
现在这很重要，因为你显然想要，

317
00:14:01,908 --> 00:14:05,142
取决于你的大小，适当地画出自己。

318
00:14:05,211 --> 00:14:07,812
而且还有两个重要因素

319
00:14:07,880 --> 00:14:12,016
经常被有界限的学生困惑的变量，

320
00:14:12,085 --> 00:14:16,920
这是完全不同的：那是frame和center。

321
00:14:16,989 --> 00:14:20,825
所以frame和center无关

322
00:14:20,894 --> 00:14:23,994
在你绘图的地方，这是有限的。

323
00:14:24,063 --> 00:14:27,665
frame和center是你在父视图中的位置。

324
00:14:29,402 --> 00:14:32,136
所以这里是一个frame和center的图片。

325
00:14:32,205 --> 00:14:35,473
所以center是你的中心在你的父视图

326
00:14:35,542 --> 00:14:38,309
坐标系和边框(frame)是一个完整的矩形

327
00:14:38,377 --> 00:14:41,612
将你包围在你的超级视图的坐标系中。

328
00:14:41,681 --> 00:14:44,515
你可能会想，我的边框的大小将是

329
00:14:44,584 --> 00:14:47,752
与我的边界大小完全相同的大小吧？

330
00:14:47,821 --> 00:14:53,157
答案是否定的，因为视图可以旋转。

331
00:14:53,225 --> 00:14:56,194
如果你曾经旋转过这样一个绿色的视图，

332
00:14:56,262 --> 00:14:57,962
在View B中绘制的代码中，它的边界就是

333
00:14:57,963 --> 00:14:59,663
查看B.

334
00:14:59,732 --> 00:15:01,933
看起来像一个正常的矩形，其旋转的事实，

335
00:15:02,001 --> 00:15:03,934
它甚至不知道它旋转。

336
00:15:04,003 --> 00:15:06,637
但是，如果你看它的中心，或者如果你看

337
00:15:06,706 --> 00:15:10,574
封闭它的框架，看起来，它的大小不一样。

338
00:15:10,643 --> 00:15:12,193
它必须更大，因为对于Superview，View A，

339
00:15:12,194 --> 00:15:13,744
它更大

340
00:15:13,813 --> 00:15:16,547
看B看起来像钻石，对吧？

341
00:15:16,616 --> 00:15:17,915
所以它必须更大。

342
00:15:17,984 --> 00:15:22,920
所以这里的底线，从不使用框架或中心来绘制。

343
00:15:22,989 --> 00:15:25,923
边框和中心只用于定位您

344
00:15:25,992 --> 00:15:26,557
在你的父视图。

345
00:15:26,626 --> 00:15:28,126
好的，你可以使用一个。

346
00:15:28,194 --> 00:15:29,794
如果你设置中心，它会移动边框，

347
00:15:29,863 --> 00:15:31,896
如果你设置边框，它会调整中心，好的。

348
00:15:31,964 --> 00:15:32,764
他们绑在一起

349
00:15:34,801 --> 00:15:35,699
好的。

350
00:15:35,768 --> 00:15:37,735
我们如何创建视图？

351
00:15:37,804 --> 00:15:39,336
好的，因为我已经告诉过我们，我们没有真正使用

352
00:15:39,405 --> 00:15:40,571
初始化器，我们不知道，

353
00:15:40,640 --> 00:15:42,406
在代码中非常多地创建它们。

354
00:15:42,475 --> 00:15:43,474
我们通常做的是拖出它们

355
00:15:43,475 --> 00:15:44,474
好的？

356
00:15:44,543 --> 00:15:47,411
从实用程序窗口底部的对象选项板

357
00:15:47,479 --> 00:15:49,013
在Interface Builder中。

358
00:15:49,081 --> 00:15:52,316
但是，如果我建立了一个自定义视图，Paul的视图或

359
00:15:52,385 --> 00:15:56,420
有什么，不会在调色板，好的。

360
00:15:56,489 --> 00:15:58,556
Xcode没有在调色板中出现我的观点。

361
00:15:58,625 --> 00:16:01,491
相反，有一个通用视图，只是简单的UIView，和

362
00:16:01,560 --> 00:16:03,594
你会拖动它。

363
00:16:03,663 --> 00:16:05,696
但是，你会用上半部分来检查它

364
00:16:05,765 --> 00:16:07,298
右边的工具区，右边？

365
00:16:07,367 --> 00:16:09,200
你会检查它

366
00:16:09,268 --> 00:16:11,568
将其类改为不是UIView。

367
00:16:11,637 --> 00:16:14,272
它将成为你UIView的子类，所以Paul视图或

368
00:16:14,340 --> 00:16:15,673
什么，好吗？

369
00:16:15,742 --> 00:16:17,374
这是一个非常重要的一步要记住。

370
00:16:17,443 --> 00:16:19,977
当您创建自定义视图并将其拖动到您的UI中时，

371
00:16:20,046 --> 00:16:22,346
你必须将其类改为自定义类。

372
00:16:22,415 --> 00:16:24,615
我们将在演示中看到它的工作原理。

373
00:16:26,152 --> 00:16:27,385
当你在代码中创建它时，当然，

374
00:16:27,453 --> 00:16:29,319
你只是在做UIView(frame:),

375
00:16:29,388 --> 00:16:30,888
你提供边框，好吗？

376
00:16:30,957 --> 00:16:33,357
那个边框，记住，它描述了什么？

377
00:16:33,426 --> 00:16:35,826
描述这个视图在其父视图中的位置

378
00:16:35,894 --> 00:16:39,097
当它被添加时，这就是边框正在做的，好吗？

379
00:16:39,165 --> 00:16:41,232
你可以用UIView（）创建它，没有参数。

380
00:16:41,300 --> 00:16:43,234
那么它将是零宽度，零高度和

381
00:16:43,303 --> 00:16:45,903
它将在零，零，所以你甚至不会看到它。

382
00:16:45,971 --> 00:16:47,070
但是你可以稍后再来

383
00:16:47,139 --> 00:16:50,508
改变其边框和/或其中心以移动它。

384
00:16:51,944 --> 00:16:53,210
在这里，这是一个很快的例子，

385
00:16:53,279 --> 00:16:54,245
如何在代码中创建视图。

386
00:16:54,314 --> 00:16:56,413
我要创建一个UILabel。

387
00:16:56,482 --> 00:16:59,283
UILabel只是UIView的一个子类。

388
00:16:59,352 --> 00:17:01,719
并注意到在第二行，

389
00:17:01,788 --> 00:17:05,255
我只是说label = UILabel(frame:)的任何东西。

390
00:17:05,324 --> 00:17:07,992
所以我给它这个边框，20，20，150，对吧？

391
00:17:08,061 --> 00:17:10,427
然后我将文本设置为“Hello”。

392
00:17:10,496 --> 00:17:13,497
那么，如果我在UIViewController中执行这个代码，

393
00:17:13,566 --> 00:17:15,866
那么我可以把它放在这个顶级视图中，

394
00:17:15,935 --> 00:17:18,769
它看起来像这样，view.addSubview，好吗？

395
00:17:18,838 --> 00:17:20,438
它会添加子视图。

396
00:17:20,506 --> 00:17:23,540
自定义视图，为什么我需要一个自定义视图？

397
00:17:23,609 --> 00:17:25,410
或者我需要做自定义绘图或

398
00:17:25,478 --> 00:17:28,479
我需要做定制的多点触控输入，好吗？

399
00:17:28,547 --> 00:17:29,480
这些是原因

400
00:17:29,549 --> 00:17:31,682
你会创建一个自定义视图。

401
00:17:31,750 --> 00:17:34,284
所以我们会专注于绘画，而且

402
00:17:34,353 --> 00:17:36,754
绘图非常非常简单，好吗？

403
00:17:36,822 --> 00:17:39,556
有一种叫做draw的方法。

404
00:17:39,625 --> 00:17:42,626
它需要一个参数，这是一个rect。

405
00:17:42,695 --> 00:17:45,062
由于历史原因，我们有时称之为“drawrect

406
00:17:45,131 --> 00:17:47,165
但它实际上并没有调用drawrect。

407
00:17:47,233 --> 00:17:50,001
它被调用绘制，而这个参数叫做rect。

408
00:17:53,539 --> 00:17:55,907
这个画面将被系统发送给你。

409
00:17:55,975 --> 00:17:58,742
它被发送到你的UIView子类，

410
00:17:58,811 --> 00:18:01,345
你覆盖(override)它，并且它被系统发送给你

411
00:18:01,414 --> 00:18:03,447
系统希望你自己绘制。

412
00:18:03,516 --> 00:18:06,450
这是你可以绘制你的视图的唯一方法，

413
00:18:06,519 --> 00:18:09,019
是系统要求绘制的。

414
00:18:09,088 --> 00:18:13,524
没有其他方法可以在iOS中绘制。

415
00:18:13,593 --> 00:18:15,793
那么这个矩形是什么呢？

416
00:18:15,862 --> 00:18:18,462
那个矩形是你的边界的一些子区域

417
00:18:18,531 --> 00:18:19,930
它想要你绘制。

418
00:18:19,999 --> 00:18:22,533
现在，这是一个性能提升，因为可以

419
00:18:22,602 --> 00:18:25,269
忽略它，绘制你的整个视图，如果你愿意的话。

420
00:18:25,337 --> 00:18:27,438
但是像你的任务三，你可能会这样

421
00:18:27,506 --> 00:18:29,106
想注意这个矩形，因为

422
00:18:29,175 --> 00:18:32,510
你的任务三的绘制将是相当昂贵的，

423
00:18:32,579 --> 00:18:34,846
所以你想尽量少绘制。

424
00:18:36,216 --> 00:18:37,914
这就是这个绘制，很简单，

425
00:18:37,983 --> 00:18:40,117
它只是系统调用，时间让你绘制。

426
00:18:40,186 --> 00:18:41,385
这是绘制的唯一方法。

427
00:18:41,454 --> 00:18:43,855
所以真的很容易理解。

428
00:18:44,790 --> 00:18:48,325
永远不要称这种方法。

429
00:18:48,394 --> 00:18:49,827
如果你曾经打过这个方法，那是错的。

430
00:18:50,796 --> 00:18:51,895
系统调用此方法，

431
00:18:51,964 --> 00:18:54,198
该系统是唯一一个称为此方法的系统。

432
00:18:54,267 --> 00:18:56,233
那么如果你需要绘制会怎么样？

433
00:18:56,302 --> 00:18:58,468
有什么改变，你想重新绘制。

434
00:18:58,537 --> 00:19:00,638
你调用这两种方法之一，setNeedsDisplay或

435
00:19:00,706 --> 00:19:02,873
setNeedsDisplay与rect的参数。

436
00:19:02,942 --> 00:19:05,309
这就是告诉系统，嘿，系统，

437
00:19:05,378 --> 00:19:06,744
我的看法需要重新绘制。

438
00:19:06,813 --> 00:19:08,212
请让我重画。

439
00:19:08,280 --> 00:19:10,247
在未来的某个适当时候，

440
00:19:10,316 --> 00:19:11,915
它会要求你重绘。

441
00:19:11,984 --> 00:19:14,218
但是，当你最好的绘制时间比你好，

442
00:19:14,287 --> 00:19:15,486
相信我。

443
00:19:15,555 --> 00:19:17,721
和你可以通过的rect，这只是直觉

444
00:19:17,790 --> 00:19:19,723
这将被传递到你的绘制。

445
00:19:19,792 --> 00:19:22,426
所以setNeeds显示一个rect就像一个优化

446
00:19:22,494 --> 00:19:23,494
setNeedsDisplay。

447
00:19:23,563 --> 00:19:24,695
就好像我需要重绘，但是

448
00:19:24,763 --> 00:19:25,596
只有我这一部分。

449
00:19:25,665 --> 00:19:30,701
你可以把它发送给任何UIView，比如说重绘这个视图。

450
00:19:30,770 --> 00:19:33,069
通常，视图发送给自己，因为

451
00:19:33,138 --> 00:19:36,774
他们是最需要重新绘制的人，

452
00:19:36,843 --> 00:19:37,441
好的？

453
00:19:38,477 --> 00:19:39,643
好的。

454
00:19:39,712 --> 00:19:43,580
那么，我该如何实现这个draw，

455
00:19:43,649 --> 00:19:48,352
绘制，用CGRect？

456
00:19:48,421 --> 00:19:50,554
答案是，你会用路径(path)去做。

457
00:19:50,623 --> 00:19:54,057
你会创建路径，然后你会描边(stroke)

458
00:19:54,126 --> 00:19:57,161
和填充(fill)他们的形状和这样的东西。

459
00:19:57,230 --> 00:20:00,097
然后你也会使用文字和图像。

460
00:20:00,166 --> 00:20:03,134
所以这是你要绘制的主要方式

461
00:20:03,202 --> 00:20:04,167
在那里，好吗？

462
00:20:04,236 --> 00:20:06,103
所以我们会在一分钟内谈论文本和图像。

463
00:20:06,171 --> 00:20:08,171
让我们先来看一下路线图。

464
00:20:08,240 --> 00:20:09,473
实际上有两种方法。

465
00:20:09,541 --> 00:20:11,442
一个是你可以得到所谓的上下文(context)，

466
00:20:11,510 --> 00:20:14,010
一个绘图环境(context)，我会告诉你如何得到它。

467
00:20:14,079 --> 00:20:17,547
然后，您可以发送消息到该上下文，如移动到

468
00:20:17,616 --> 00:20:21,718
这一点，画一条线到这里，在这里加一个弧线，

469
00:20:21,787 --> 00:20:24,655
把一些文字放在这里，这样的事情，好吗？

470
00:20:24,724 --> 00:20:26,256
其实，我们要用不同的方式做文本，

471
00:20:26,325 --> 00:20:27,892
但是，这是一种方式。

472
00:20:27,960 --> 00:20:31,028
然后另一种方式是，你可以创建一个路径对象，

473
00:20:31,097 --> 00:20:34,798
好的，使用UIBezierPath，这是同样的事情。

474
00:20:34,867 --> 00:20:37,067
但是你会创建这个对象，你会告诉

475
00:20:37,136 --> 00:20:39,403
那个对象，好的，我想要这条路要移到这里

476
00:20:39,472 --> 00:20:41,438
然后在这里一条线，然后一个弧线到这里，好吗？

477
00:20:41,507 --> 00:20:42,606
所以你创建这个路径，和

478
00:20:42,674 --> 00:20:44,709
那么你发送消息到该路径说，好的，

479
00:20:44,777 --> 00:20:45,810
描边它

480
00:20:45,878 --> 00:20:47,744
所以这是一个微妙的区别，但你会看到。

481
00:20:47,813 --> 00:20:49,880
我们将主要关注UIBezierPath方式，

482
00:20:49,949 --> 00:20:51,415
因为它有点简单。

483
00:20:51,484 --> 00:20:53,517
所以让我们来理解这里的概念

484
00:20:53,586 --> 00:20:56,153
核心图形(Core Graphics)，这就是你所看到的CG

485
00:20:56,222 --> 00:20:57,020
这里的所有地方

486
00:20:57,089 --> 00:21:00,224
而Core Graphics的第一件事就是，

487
00:21:00,293 --> 00:21:01,391
我们需要一个上下文。

488
00:21:01,460 --> 00:21:03,927
而且该上下文可能是屏幕上的绘图上下文，

489
00:21:03,996 --> 00:21:06,062
如果我们正在打印，它可能是打印上下文，

490
00:21:06,131 --> 00:21:08,999
可能是绘制到屏幕外位图等的上下文。

491
00:21:09,067 --> 00:21:12,236
你所关心的显然是上下文

492
00:21:12,304 --> 00:21:13,937
绘制在你的drawrect里

493
00:21:14,006 --> 00:21:15,539
你可以通过调用这个函数来得到它。

494
00:21:15,608 --> 00:21:16,573
这只是一个Swift功能，

495
00:21:16,642 --> 00:21:17,975
它不在课堂上或任何东西上。

496
00:21:18,043 --> 00:21:20,511
UIGraphicsGetCurrentContext(), 和

497
00:21:20,580 --> 00:21:23,847
那将是给你一个上下文，然后你可以

498
00:21:23,916 --> 00:21:27,618
告诉它通过移动和所有的东西创建一条路径。

499
00:21:27,686 --> 00:21:30,387
你在做什么，你创建这些路径

500
00:21:30,456 --> 00:21:32,623
线条和弧线等等。

501
00:21:32,692 --> 00:21:35,359
然后在上下文中设置绘图属性，

502
00:21:35,427 --> 00:21:37,962
像你想要使用的颜色，如果你正在做的字体

503
00:21:38,031 --> 00:21:41,432
文字，行宽，这些东西。

504
00:21:41,501 --> 00:21:43,300
你把这些全部放在一起，然后你描边和填充。

505
00:21:43,369 --> 00:21:44,801
就这样，抚摸着

506
00:21:44,870 --> 00:21:47,804
实际上填充是唯一的两个指令

507
00:21:47,873 --> 00:21:49,740
导致屏幕上发生一些事情。

508
00:21:49,809 --> 00:21:50,574
但请记住，像，

509
00:21:50,642 --> 00:21:55,279
一个字体基本上只是一个非常精致的路径，

510
00:21:55,348 --> 00:21:57,614
好的，还是描边(stroke)和填充(fill)。

511
00:21:57,683 --> 00:22:00,884
所以你可以做很多的描变和填充。

512
00:22:00,953 --> 00:22:03,420
所以UIBezierPath有一个封装了所有这些

513
00:22:03,489 --> 00:22:05,956
核心图形概念成为一个对象。

514
00:22:06,025 --> 00:22:08,525
所以我有一个例子，告诉你我将如何使用

515
00:22:08,594 --> 00:22:12,929
UIBezierPath在屏幕上画一个三角形。

516
00:22:12,998 --> 00:22:14,965
首先，我要创造道路，只是说，

517
00:22:15,033 --> 00:22:16,099
path = UIBezierPath()

518
00:22:16,168 --> 00:22:17,768
还有其他的初始化器，

519
00:22:17,837 --> 00:22:18,735
我们将在演示中看到。

520
00:22:18,804 --> 00:22:21,371
但这只是创建一个空白的路径来启动。

521
00:22:21,440 --> 00:22:23,206
然后，您随着路径移动。

522
00:22:23,275 --> 00:22:25,876
所以就像我可以说，移动到，(80，

523
00:22:25,945 --> 00:22:29,480
50) 就像这个中间，这个小屏幕。

524
00:22:29,548 --> 00:22:32,949
这是小屏幕，大概160 points 宽。

525
00:22:33,018 --> 00:22:34,751
80，然后50下，好吗？

526
00:22:34,820 --> 00:22:39,556
然后我会添加一条线到140，50，看到，好吗？

527
00:22:39,625 --> 00:22:42,659
然后我会添加另外一行到10，

528
00:22:42,728 --> 00:22:45,929
在左边，我还是150下来。

529
00:22:45,998 --> 00:22:48,832
然后我要关闭路径，好的，使用close，和

530
00:22:48,901 --> 00:22:51,101
那只是关闭它回到开始。

531
00:22:51,170 --> 00:22:53,436
所以看，我做了一个三角形，好的，真的很容易。

532
00:22:53,505 --> 00:22:56,940
现在，唯一的是，这里的所有代码将会

533
00:22:57,009 --> 00:23:00,410
实际上是绘制在这里，而不是那个三角形，

534
00:23:00,479 --> 00:23:03,113
会画这个：没什么

535
00:23:03,182 --> 00:23:06,083
你会看到没有这个代码的绘图，因为我们没有

536
00:23:06,151 --> 00:23:07,117
描边或填充它。

537
00:23:07,186 --> 00:23:09,386
描边和填充是什么绘制。

538
00:23:09,455 --> 00:23:10,754
那么我们如何做描边和填充？

539
00:23:10,823 --> 00:23:13,157
那么，我们需要设置我们想要填充的颜色

540
00:23:13,226 --> 00:23:15,792
和描边。

541
00:23:15,861 --> 00:23:17,261
但在这里，我正在采取绿色和

542
00:23:17,330 --> 00:23:18,829
发送消息setFill。

543
00:23:18,897 --> 00:23:21,865
所以你实际设置你的颜色来填充

544
00:23:21,934 --> 00:23:24,601
通过发送消息到一个颜色。

545
00:23:24,670 --> 00:23:25,969
你得到一个颜色，你发送一个消息，

546
00:23:26,038 --> 00:23:27,237
设置为我的填充颜色。

547
00:23:27,306 --> 00:23:28,104
和描边相同的事情，

548
00:23:28,173 --> 00:23:28,772
将其设置为描边颜色(stroke color)。

549
00:23:28,840 --> 00:23:32,842
所以我将我的笔画颜色设置为红色，填充颜色为绿色。

550
00:23:32,911 --> 00:23:35,613
但是当我谈论像线宽等属性时，

551
00:23:35,681 --> 00:23:38,716
我发送到路径，到UIBezierPath。

552
00:23:38,784 --> 00:23:41,318
将你的行宽设置为3，好的，所以我这样做。

553
00:23:41,387 --> 00:23:45,622
现在，如果我说path.fill，现在我得到一个绿色的三角形。

554
00:23:45,691 --> 00:23:46,823
因为我的填充颜色是绿色的，

555
00:23:46,892 --> 00:23:48,859
它需要该路径，并填充它。

556
00:23:48,927 --> 00:23:50,594
这就是填充。

557
00:23:50,663 --> 00:23:53,563
同样，如果我说path.stroke，

558
00:23:53,632 --> 00:23:55,332
我周围红线

559
00:23:55,401 --> 00:23:58,802
因为我走到那里的路径得到了

560
00:23:58,871 --> 00:24:02,206
用三点宽的红线描边。

561
00:24:02,274 --> 00:24:04,841
就这样，实际上很简单。

562
00:24:04,910 --> 00:24:05,543
这就是我们绘制的。

563
00:24:07,579 --> 00:24:08,979
而且，UIBezierPath也知道如何绘制很多常见的东西

564
00:24:08,980 --> 00:24:10,380
好的？

565
00:24:10,449 --> 00:24:13,350
形状，如圆形矩形和椭圆形，以及

566
00:24:13,419 --> 00:24:16,053
这样的事情，所以你应该熟悉自己

567
00:24:16,121 --> 00:24:20,256
与UIBezierPath的API当然是。

568
00:24:20,325 --> 00:24:22,392
你可以用UIBezierPath做一个很酷的事情

569
00:24:22,461 --> 00:24:24,094
创建一个像三角形的路径，

570
00:24:24,162 --> 00:24:27,798
您可以将所有图纸剪切到该路径。

571
00:24:27,866 --> 00:24:30,367
所以你可以画出这个精美的图片

572
00:24:30,436 --> 00:24:33,003
显示通过该三角形显示的部分，

573
00:24:33,071 --> 00:24:34,938
如果你拿起我们刚刚创建的三角形路径，

574
00:24:35,007 --> 00:24:37,073
说添加剪辑。

575
00:24:37,142 --> 00:24:37,841
因为之后，

576
00:24:37,909 --> 00:24:42,012
所有的绘图只会出现在三角形的内部，

577
00:24:42,080 --> 00:24:44,381
你可以做一些非常酷的效果。

578
00:24:44,382 --> 00:24:46,683
这很有趣，

579
00:24:46,752 --> 00:24:48,485
UIBezierPath也知道如何，

580
00:24:48,554 --> 00:24:50,521
它有这个方法包含会的，

581
00:24:50,589 --> 00:24:53,389
告诉你一个点是否在路径内。

582
00:24:53,458 --> 00:24:56,126
所以如果你想做一些触摸的东西或人，那么很好

583
00:24:56,195 --> 00:24:58,962
正在触摸某物，你想做点击检测，

584
00:24:59,031 --> 00:25:00,997
基本上，他们在摸什么

585
00:25:01,066 --> 00:25:02,933
好吧，UIBezierPath里还有很多其他的东西，

586
00:25:03,001 --> 00:25:04,567
没有时间来覆盖它，你应该看看。

587
00:25:04,636 --> 00:25:06,369
好的，UIColor。

588
00:25:06,438 --> 00:25:07,972
所以UIColor，真的很简单。

589
00:25:08,040 --> 00:25:10,641
好的，有一些常见的颜色，如绿色，红色，

590
00:25:10,709 --> 00:25:11,808
黄色，紫色。

591
00:25:11,877 --> 00:25:13,610
那些在UIColor上有类型的方法。

592
00:25:13,679 --> 00:25:15,278
记住，键入方法，静态方法？

593
00:25:15,347 --> 00:25:16,046
他们是类型。

594
00:25:16,115 --> 00:25:17,247
你不需要它的一个实例。

595
00:25:17,316 --> 00:25:19,416
所以就像UIColor.green。

596
00:25:19,484 --> 00:25:22,686
但是还有一些初始化器可以让您创建颜色

597
00:25:22,755 --> 00:25:27,057
从RGB，红色，绿色，蓝色或HSB，这是色调，饱和度，

598
00:25:27,125 --> 00:25:28,575
甚至可以创建一种由图案制成的颜色。

599
00:25:28,576 --> 00:25:30,026
亮度。

600
00:25:30,095 --> 00:25:31,794
所以当你用这种颜色画的时候，

601
00:25:31,863 --> 00:25:33,296
它画在一个模式。

602
00:25:33,365 --> 00:25:34,164
好吧，就像一条真正的粗线，

603
00:25:34,232 --> 00:25:36,099
我们实际上会显示一个模式的细节，

604
00:25:36,168 --> 00:25:38,067
这是有趣的，使用UIImage，

605
00:25:38,136 --> 00:25:39,303
我稍稍谈一谈。

606
00:25:40,773 --> 00:25:43,640
当然，所有UIViews都有背景颜色。

607
00:25:43,709 --> 00:25:46,743
当我们在计算器中做了按钮时，我们看到了这一点，

608
00:25:46,812 --> 00:25:48,211
我们做了背景颜色

609
00:25:48,280 --> 00:25:50,848
很多我们的按钮是浅灰色的，我确信

610
00:25:50,916 --> 00:25:52,649
你做的作业作业其他颜色。

611
00:25:52,717 --> 00:25:54,718
好的，那只是UIView上的一个var，

612
00:25:54,786 --> 00:25:56,820
该按钮继承自UIView。

613
00:25:56,888 --> 00:25:59,155
您可以将其设置为您想要的任何UIColor。

614
00:25:59,224 --> 00:26:02,359
现在，关于颜色的一个有趣的事情就是这样

615
00:26:02,427 --> 00:26:06,163
他们可以透明，甚至半透明，好吗？

616
00:26:06,232 --> 00:26:09,299
他们完成了，你用alpha指定。

617
00:26:09,368 --> 00:26:10,900
这里有多少人知道什么是阿尔法(alpha透明度)

618
00:26:10,969 --> 00:26:11,936
当涉及到图形？

619
00:26:13,038 --> 00:26:14,137
好的，几乎没有人

620
00:26:14,206 --> 00:26:18,141
所以alpha只是0到1之间的值，0表示

621
00:26:18,210 --> 00:26:21,144
完全透明，1完全不透明。

622
00:26:21,213 --> 00:26:23,247
所以如果你有一个三角形的颜色，

623
00:26:23,315 --> 00:26:26,016
你填满绿色，那么如果它是完全不透明的，

624
00:26:26,084 --> 00:26:28,551
你看不到三角形后面的东西。

625
00:26:28,620 --> 00:26:30,787
但如果是50％，0.5 alpha，

626
00:26:30,856 --> 00:26:33,189
那么你可以看到绿色，但是

627
00:26:33,258 --> 00:26:36,927
你也可以看到背后的东西一点点。

628
00:26:36,995 --> 00:26:38,728
50％有点好吗？

629
00:26:38,797 --> 00:26:40,230
如果是零，你将看不到任何东西

630
00:26:40,298 --> 00:26:42,165
绿色，因为它将是完全透明的。

631
00:26:42,234 --> 00:26:43,267
你会一直在寻找它，所以

632
00:26:43,335 --> 00:26:45,102
你不会看到任何绿色的，好吗？

633
00:26:45,171 --> 00:26:47,304
所以，所有这一切，你可以放在该范围的任何地方，和

634
00:26:47,372 --> 00:26:49,906
创建透明颜色的方法是采取

635
00:26:49,975 --> 00:26:53,710
一个不透明的颜色说，withAlphaComponent，

636
00:26:53,779 --> 00:26:55,946
0和1之间的任意alpha。

637
00:26:56,015 --> 00:26:57,281
好的？这给了你

638
00:26:57,349 --> 00:26:58,314
一个透明或

639
00:26:58,383 --> 00:27:01,251
半透明版的颜色。

640
00:27:01,320 --> 00:27:02,352
你可以画画。

641
00:27:02,421 --> 00:27:07,557
但是，如果您在UIView中绘制透明度，

642
00:27:07,626 --> 00:27:10,927
你必须在你的UIView上设置这个var。

643
00:27:10,996 --> 00:27:13,530
这只是UIView中的一个var为false。

644
00:27:13,599 --> 00:27:15,265
好的？因为观点假定

645
00:27:15,334 --> 00:27:17,234
他们完全不透明，好吗？

646
00:27:17,302 --> 00:27:19,035
这就是性能提升。

647
00:27:19,104 --> 00:27:20,870
原来，透明度的绘图，

648
00:27:20,939 --> 00:27:23,173
你可能会想象，需要一点CPU功率

649
00:27:23,242 --> 00:27:26,042
以确定哪些像素显示通过和所有。

650
00:27:26,111 --> 00:27:28,878
因此，默认情况下，它假定您正在绘制完全不透明。

651
00:27:28,947 --> 00:27:30,480
所以如果你想用透明度绘制，

652
00:27:30,549 --> 00:27:34,050
不要忘了在这里设置不透明。

653
00:27:34,119 --> 00:27:37,921
顺便说一句，你可以让你的整个视图半透明

654
00:27:37,989 --> 00:27:39,389
通过设置其alpha。

655
00:27:39,458 --> 00:27:41,558
所以这是一个var，不是颜色，

656
00:27:41,627 --> 00:27:43,226
这是UIView中的一个var。

657
00:27:43,295 --> 00:27:44,995
你可以说，alpha 0.5，

658
00:27:45,063 --> 00:27:48,899
在您的整个视图中将是50％的透视。

659
00:27:48,968 --> 00:27:50,267
这可以使用按钮或

660
00:27:50,336 --> 00:27:52,102
任何东西，因为那些只是UIViews。

661
00:27:53,505 --> 00:27:54,071
好的？

662
00:27:56,108 --> 00:27:58,709
视图重叠时会发生什么

663
00:27:58,777 --> 00:28:00,944
我们有透明度的意见？

664
00:28:01,012 --> 00:28:04,214
那么那个我们正在谈论的子视图，

665
00:28:04,282 --> 00:28:07,951
视图的所有子视图开始按顺序重要。

666
00:28:08,019 --> 00:28:09,486
所以第一件事在子视图中，

667
00:28:09,555 --> 00:28:12,689
子视图零，这一直在后面。

668
00:28:12,758 --> 00:28:14,925
然后一切都在前面

669
00:28:14,993 --> 00:28:15,859
好吗？

670
00:28:15,927 --> 00:28:19,062
所以，任何透明度都是事情

671
00:28:19,131 --> 00:28:21,598
按顺序堆叠，你正在向下看

672
00:28:21,666 --> 00:28:24,334
透明度，一直到subview零，

673
00:28:24,403 --> 00:28:26,437
所以这是在后面，好吗？

674
00:28:28,540 --> 00:28:30,406
您也可以完全隐藏视图。

675
00:28:30,475 --> 00:28:33,043
这是非常相似的 - 几乎相同 - 说

676
00:28:33,112 --> 00:28:33,977
alpha等于零。

677
00:28:34,045 --> 00:28:35,812
这只会使视图甚至不出现，但是

678
00:28:35,881 --> 00:28:37,246
它仍将在视图层次结构中。

679
00:28:37,315 --> 00:28:39,049
它仍然在它的父视图和

680
00:28:39,118 --> 00:28:41,384
它的子视图仍然是它的子视图，但是

681
00:28:41,453 --> 00:28:43,753
这一切都将被完全隐藏。

682
00:28:43,822 --> 00:28:45,155
为什么要这样做？

683
00:28:45,224 --> 00:28:48,492
也许你有一些UI，你不想显示一个按钮

684
00:28:48,561 --> 00:28:51,060
直到用户进入某个其他字段或

685
00:28:51,129 --> 00:28:51,695
这样的东西

686
00:28:51,764 --> 00:28:52,929
但你想为这个按钮腾出空间。

687
00:28:52,998 --> 00:28:54,931
你希望它准备好出现，所以

688
00:28:55,000 --> 00:28:57,434
您将其留在视图层次结构中，但隐藏。

689
00:28:57,503 --> 00:29:00,437
好的？好的，

690
00:29:00,506 --> 00:29:01,638
我们来谈谈绘制文字。

691
00:29:01,707 --> 00:29:02,605
我们如何绘制文字？

692
00:29:02,674 --> 00:29:05,108
那么一个方法可以画出你已经知道的文字是UILabel。

693
00:29:05,177 --> 00:29:08,078
您可以创建一个UILabel并使其成为子视图

694
00:29:08,146 --> 00:29:11,280
你的视图和宾果，你有一些文字在你的看法。

695
00:29:11,349 --> 00:29:13,082
而现在，唯一的问题是，

696
00:29:13,151 --> 00:29:15,452
你绘制视图，是drawRect的东西，

697
00:29:15,521 --> 00:29:16,919
你在那里绘制

698
00:29:16,988 --> 00:29:19,589
你必须确保你绘制，如果你正在绘制

699
00:29:19,658 --> 00:29:21,725
所有这些都与您的子视图排列在一起。

700
00:29:21,794 --> 00:29:24,328
所以有时你想绘制drawRect吧？

701
00:29:24,396 --> 00:29:25,495
你想在那里实际绘制。

702
00:29:25,564 --> 00:29:28,464
而你所做的那种方式就是一个叫做“

703
00:29:28,533 --> 00:29:30,833
NSAttributedString，好吗？

704
00:29:30,902 --> 00:29:34,504
所以NSAttributedString不是一个字符串。

705
00:29:34,573 --> 00:29:37,607
它不是以任何方式实际上与字符串相关，而且

706
00:29:37,676 --> 00:29:40,844
它甚至不是一个旧的Objective-C的NSString

707
00:29:40,912 --> 00:29:43,813
由ints在其中索引的样式字符串

708
00:29:43,882 --> 00:29:47,650
Swift的一个由string.index索引，不幸的是。

709
00:29:47,719 --> 00:29:49,486
这不是那些，这是自己的事情。

710
00:29:49,555 --> 00:29:50,220
好的？

711
00:29:50,289 --> 00:29:52,790
它与旧的NSString非常接近，

712
00:29:52,858 --> 00:29:55,725
不如现代弦一样紧密。

713
00:29:55,794 --> 00:29:58,695
但无论如何，一个字符串是一个字符串，

714
00:29:58,764 --> 00:30:00,864
您可以使用字符串或NSString。

715
00:30:00,933 --> 00:30:04,267
这些角色有属性，颜色和

716
00:30:04,335 --> 00:30:06,370
字体和类似的东西，好吗？

717
00:30:06,438 --> 00:30:07,337
这很简单，

718
00:30:07,406 --> 00:30:08,772
你创建这些字符串之一

719
00:30:08,841 --> 00:30:11,708
你只需将其发送到消息画面，它将绘制

720
00:30:11,777 --> 00:30:15,045
那个字符串在那一点在它的左上角。

721
00:30:16,948 --> 00:30:17,997
那么你甚至可以找出需要的大小

722
00:30:17,998 --> 00:30:19,047
好的？

723
00:30:19,117 --> 00:30:22,352
通过将消息大小发送到归因的字符串来绘制它。

724
00:30:23,455 --> 00:30:24,954
好的？现在有一件事了

725
00:30:25,023 --> 00:30:26,422
关于归属字符串的那种，

726
00:30:26,491 --> 00:30:31,928
它真的是一个老式的API，

727
00:30:31,997 --> 00:30:36,065
var，甚至没有工作，使它变得不可变。

728
00:30:36,134 --> 00:30:38,368
所以如果你想要一个可变的归因字符串，归因

729
00:30:38,437 --> 00:30:40,236
字符串，你会改变它的属性和

730
00:30:40,305 --> 00:30:43,005
改变它的文字，你需要有一个不同的类叫

731
00:30:43,074 --> 00:30:47,010
NSMutableAttributedString。

732
00:30:47,078 --> 00:30:48,945
所以这样的事情，如设置属性，和事情，

733
00:30:49,014 --> 00:30:50,380
不适用于归因的字符串。

734
00:30:50,449 --> 00:30:53,917
你有一个可变的归因字符串。

735
00:30:53,986 --> 00:30:56,486
现在，你可以，如果你有一个归因的字符串，mutable或

736
00:30:56,555 --> 00:30:59,422
不，你可以收回它里面的字符串

737
00:30:59,491 --> 00:31:03,493
作为使用var字符串的字符串对象，或

738
00:31:03,561 --> 00:31:05,128
可变字符串在可变的情况下。

739
00:31:06,632 --> 00:31:07,763
这有点混乱，因为，

740
00:31:07,832 --> 00:31:10,333
当然，你习惯了var，让字符串是如何的

741
00:31:10,402 --> 00:31:13,970
可变或不可变，但这是如何让字符串回来。

742
00:31:14,039 --> 00:31:15,872
但是我们来谈谈你如何设置属性。

743
00:31:15,941 --> 00:31:19,142
所以你通过传入这个字典来设置属性，

744
00:31:19,211 --> 00:31:20,043
称为属性。

745
00:31:20,112 --> 00:31:23,113
您可以设置属性或添加属性到什么

746
00:31:23,182 --> 00:31:26,282
已经在那里，这个字典，String：Any，

747
00:31:26,351 --> 00:31:28,985
字符串只是一个关键，这样告诉你什么

748
00:31:29,054 --> 00:31:32,422
属性就像它是一种字体，或者一种颜色，或者是什么。

749
00:31:32,491 --> 00:31:33,723
然后任何是，

750
00:31:33,792 --> 00:31:35,258
它可能是一种字体，它可能是一种颜色，

751
00:31:35,327 --> 00:31:38,161
取决于关键是什么，这就是为什么它是一个任何在那里，

752
00:31:38,230 --> 00:31:40,464
因为它可以是各种各样的东西。

753
00:31:40,532 --> 00:31:42,799
这里确实很重要的是范围。

754
00:31:42,868 --> 00:31:43,500
你看到那个范围？

755
00:31:43,568 --> 00:31:47,270
星期三我跟你说的不是范围，

756
00:31:47,339 --> 00:31:48,938
这是NSRange。

757
00:31:49,007 --> 00:31:53,042
NSRange是该字符串中的整数索引范围，

758
00:31:53,111 --> 00:31:55,512
归因于字符串。

759
00:31:55,581 --> 00:31:57,881
旧样式整数，而不是string.index。

760
00:31:57,950 --> 00:32:01,117
所以这在使用时会造成很大的麻烦

761
00:32:01,186 --> 00:32:03,653
归结于Swift世界的字符串。

762
00:32:03,722 --> 00:32:07,156
我的建议是你使用这种方法或

763
00:32:07,225 --> 00:32:09,792
这个var相当于String，称为utf16。

764
00:32:09,861 --> 00:32:12,462
utf16会给你回来的内容

765
00:32:12,531 --> 00:32:14,197
一个String.UTF16View。

766
00:32:14,265 --> 00:32:17,634
这是一个字符的集合，它不是真的

767
00:32:17,703 --> 00:32:21,304
像人物一样的集合，但它是一种表示

768
00:32:21,373 --> 00:32:24,975
的字符串作为不同的16位Unicode字符。

769
00:32:25,043 --> 00:32:27,510
哪个更加一致，其实我认为是正确的

770
00:32:27,579 --> 00:32:30,280
对齐，NSString的作用。

771
00:32:30,348 --> 00:32:32,616
唯一的问题是，它得到的东西，

772
00:32:32,684 --> 00:32:35,351
这个返回，仍然被String.Index索引。

773
00:32:35,420 --> 00:32:38,588
所以你必须说什么是startIndex，偏移五个，

774
00:32:38,657 --> 00:32:41,124
那种那种在那里移动的企业。

775
00:32:41,193 --> 00:32:44,093
而且，你不能通过一个String.Index的范围

776
00:32:44,162 --> 00:32:45,228
这个setAttribute。

777
00:32:45,297 --> 00:32:48,364
所以你必须从String.Index转换，

778
00:32:48,433 --> 00:32:50,466
你先进了多少，

779
00:32:50,535 --> 00:32:54,003
当您制作这些NSRanges时，返回一个整数。

780
00:32:54,072 --> 00:32:55,571
所以我很抱歉说这很难。

781
00:32:55,640 --> 00:32:57,240
我不会真的要求你这样做，

782
00:32:57,308 --> 00:32:58,374
这在作业中。

783
00:32:58,443 --> 00:33:00,176
部分是因为它，这是一种痛苦的脖子。

784
00:33:00,245 --> 00:33:02,445
我不想让你花你宝贵的作业

785
00:33:02,514 --> 00:33:03,179
时间工作。

786
00:33:03,248 --> 00:33:05,315
但是只要知道，如果你开始使用这个，

787
00:33:05,384 --> 00:33:08,919
你会有这个不幸的断开。

788
00:33:08,987 --> 00:33:11,087
而且我一直希望每次iOS出来，

789
00:33:11,156 --> 00:33:13,723
他们会出来一个归因的字符串，而不是NS，但是

790
00:33:13,792 --> 00:33:16,225
归因的字符串，与字符串匹配。

791
00:33:16,294 --> 00:33:18,161
但他们还没有做到。

792
00:33:18,230 --> 00:33:21,230
做得很复杂，我可以想象，所以。

793
00:33:21,299 --> 00:33:23,600
那么你可以设置一些这些属性呢？

794
00:33:23,668 --> 00:33:26,302
所以有些东西像NSForegroundColorAttributeN-

795
00:33:26,371 --> 00:33:28,471
嗯，这是你如何设置文本的颜色。

796
00:33:28,540 --> 00:33:31,241
还有NSBackgroundColorAttributeName

797
00:33:31,309 --> 00:33:34,343
哪些字体具有前景和背景，但是

798
00:33:34,412 --> 00:33:35,612
不用太担心

799
00:33:35,680 --> 00:33:36,413
NSStrokeWidth所以

800
00:33:36,481 --> 00:33:39,082
你可以绘制你的文字的很粗细。

801
00:33:39,150 --> 00:33:42,585
NSFontAttributeName，您可以在其中提供一个字体。

802
00:33:42,654 --> 00:33:44,187
还有大约15个其它，

803
00:33:44,255 --> 00:33:46,957
你可以去看看他们所有的文档。

804
00:33:47,025 --> 00:33:48,024
但是说到字体，

805
00:33:48,092 --> 00:33:50,259
如果你想设置你要绘制的字体，

806
00:33:50,328 --> 00:33:51,127
你如何做到这一点？

807
00:33:51,196 --> 00:33:54,297
那么，在iOS中，字体是非常重要的。

808
00:33:54,366 --> 00:33:57,100
不要低估字体的力量

809
00:33:57,168 --> 00:33:58,001
一个很酷的UI。

810
00:33:58,069 --> 00:33:58,935
看看所有这些UI。

811
00:33:59,004 --> 00:34:01,971
看看字体，大小，

812
00:34:02,040 --> 00:34:04,774
所有的东西都是。

813
00:34:04,843 --> 00:34:08,377
那么，我们如何获得一个好的字体，以便我们的UI将看起来不错？

814
00:34:08,446 --> 00:34:10,914
嗯，我们要用这个非常重要的静态

815
00:34:10,983 --> 00:34:11,881
方法在UIFont。

816
00:34:11,950 --> 00:34:14,551
所以你发送给UIFont，该类，

817
00:34:14,620 --> 00:34:17,720
称为PreferredFont forTextStyle，好吗？

818
00:34:17,789 --> 00:34:20,457
所以你可以指定文本样式，这是一种

819
00:34:20,525 --> 00:34:23,360
喜欢，你将要使用这个文本的环境是什么，

820
00:34:23,428 --> 00:34:25,461
它是什么样的文字？

821
00:34:25,530 --> 00:34:28,531
所以大概八个左右。

822
00:34:28,600 --> 00:34:30,300
但其中三个就像一个标题。

823
00:34:30,369 --> 00:34:31,334
这将成为一个标题。

824
00:34:31,402 --> 00:34:34,404
所以这将是一个更大胆的字体，有一点可能。

825
00:34:34,473 --> 00:34:37,540
那么身体字体就是这样，这是用户的数据。

826
00:34:37,608 --> 00:34:38,575
所以在邮件中，

827
00:34:38,643 --> 00:34:41,110
这将是他们实际打字的消息

828
00:34:41,179 --> 00:34:43,346
也许 - 虽然它可能是一个多字体。

829
00:34:43,414 --> 00:34:46,682
但是，然后脚注只是一个小小的文字，

830
00:34:46,751 --> 00:34:48,151
你看，从底部？

831
00:34:48,220 --> 00:34:51,121
所以我真的鼓励你，当你使用一个字体，

832
00:34:51,190 --> 00:34:53,756
尝试找到一个能奏效的文字风格，好吗？

833
00:34:53,825 --> 00:34:55,291
因为它会同步和

834
00:34:55,360 --> 00:34:57,060
与所有其他应用程序兼容，

835
00:34:57,128 --> 00:34:59,395
因为他们使用这些首选字体。

836
00:34:59,464 --> 00:35:02,132
而且，顺便说一句，如果用户进入“设置”和“

837
00:35:02,201 --> 00:35:04,367
设置他们的字体大小真的很大，

838
00:35:04,436 --> 00:35:06,802
这些会自动变大，好吗？

839
00:35:06,871 --> 00:35:10,207
而且，如果您有自动布局工作，

840
00:35:10,275 --> 00:35:13,743
一切都会扩大或收缩，好吗？

841
00:35:13,812 --> 00:35:15,378
还有系统字体。

842
00:35:15,446 --> 00:35:17,580
不要在首选字体之间混淆

843
00:35:17,649 --> 00:35:21,751
系统字体。

844
00:35:21,819 --> 00:35:24,020
首选字体是用户的内容。

845
00:35:25,290 --> 00:35:28,157
那就是那里的区别。

846
00:35:28,226 --> 00:35:29,626
现在，大部分的东西，再一次，

847
00:35:29,694 --> 00:35:31,160
你甚至不会设置代码。

848
00:35:31,229 --> 00:35:33,196
你会在Interface Builder中设置它

849
00:35:33,264 --> 00:35:34,997
小检查窗口，对吧？

850
00:35:35,066 --> 00:35:37,700
你会设置，首选的字体和

851
00:35:37,769 --> 00:35:39,736
系统字体可以在那里设置。

852
00:35:39,804 --> 00:35:44,474
如果你想使用像Helvetica Bold 13这样的特定字体

853
00:35:44,543 --> 00:35:46,843
点，你可以这样做。

854
00:35:46,911 --> 00:35:48,011
我不推荐它，

855
00:35:48,079 --> 00:35:51,114
但是UIFontDescriptor是一个重要的知道的类

856
00:35:51,183 --> 00:35:52,299
这是你想要的那种字体，

857
00:35:52,300 --> 00:35:53,416
为了那个原因。

858
00:35:53,485 --> 00:35:54,417
那个特殊的字体。

859
00:35:54,486 --> 00:35:57,153
所以，你知道，一些应用程序，排版是他们做的。

860
00:35:57,222 --> 00:35:59,622
所以他们需要能够做特定的字体。

861
00:35:59,691 --> 00:36:02,358
好的，那就是文字。

862
00:36:02,427 --> 00:36:03,993
如何显示一张图像？

863
00:36:04,062 --> 00:36:06,829
所以图像，再次，你，我们有一个像UILabel的东西。

864
00:36:06,898 --> 00:36:07,897
它被称为UIImageView。

865
00:36:07,966 --> 00:36:10,033
你可以使一个图像成为一个子视图

866
00:36:10,101 --> 00:36:12,369
你的意见，如果你想有一个图像在那里。

867
00:36:12,437 --> 00:36:15,171
但是，再一次，有时你想要控制

868
00:36:15,240 --> 00:36:17,373
在你的绘制，你的drawRect。

869
00:36:17,442 --> 00:36:19,742
我们用UIImage对象来做，可以吗？

870
00:36:19,811 --> 00:36:21,578
当我在说话的时候，我已经真正的告诉过你了

871
00:36:21,647 --> 00:36:23,846
可用的初始化器如何创建UIImage。

872
00:36:23,915 --> 00:36:27,016
你只是把它放在你的xcassets文件

873
00:36:27,084 --> 00:36:28,884
在Interface Builder中。

874
00:36:28,953 --> 00:36:32,622
然后你说UIImage命名，它得到它的名字。

875
00:36:32,691 --> 00:36:34,457
如果找不到它，则返回nil。

876
00:36:34,526 --> 00:36:37,193
所以这是你会获得图像的第一种方式

877
00:36:37,262 --> 00:36:38,661
你的应用程序放在xcassets中。

878
00:36:38,729 --> 00:36:39,863
但还有其他方法可以做到。

879
00:36:39,931 --> 00:36:42,665
你可以从一个文件中获取它，就像你有一个.jpg文件一样。

880
00:36:42,734 --> 00:36:44,800
当然，我没有向你展示如何获取文件。

881
00:36:44,869 --> 00:36:46,369
所以你不知道该怎么做。

882
00:36:46,438 --> 00:36:48,471
但是，你可以这样做。

883
00:36:48,540 --> 00:36:51,240
您也可以从原始数据，原始JPG数据或

884
00:36:51,309 --> 00:36:53,977
你通过互联网或从URL或

885
00:36:54,046 --> 00:36:55,711
有事情，你可以做到这一点。

886
00:36:55,780 --> 00:36:58,548
你甚至可以通过绘制所有这些路径的东西来做到这一点。

887
00:36:58,616 --> 00:37:01,150
你可以使用这个UIGraphicsBeginImageContext

888
00:37:01,219 --> 00:37:02,652
对于一定大小的区域。

889
00:37:02,721 --> 00:37:05,188
然后你可以使用UIBezierpath绘图或

890
00:37:05,257 --> 00:37:08,191
获取图形上下文，无论在哪里绘制。

891
00:37:08,260 --> 00:37:10,960
然后有一个EndImageContext。

892
00:37:11,029 --> 00:37:13,396
它会捕获它，并为您创建一个小图像。

893
00:37:13,465 --> 00:37:15,265
这是另一种做法。

894
00:37:15,333 --> 00:37:18,168
所以一旦你有一个形象，好的，你从任何一个

895
00:37:18,236 --> 00:37:20,836
这些来源，你可以把它画在drawRect里面

896
00:37:20,905 --> 00:37:24,307
通过点画或点画。

897
00:37:24,375 --> 00:37:28,878
或者实际上，我认为这可能是绘制空间点，

898
00:37:28,947 --> 00:37:30,546
不在atPoint：。

899
00:37:30,615 --> 00:37:35,385
并且drawIn space rect和drawAsPatternIn space rect。

900
00:37:35,454 --> 00:37:37,820
那些你会想到什么，对吧？

901
00:37:37,889 --> 00:37:40,023
draw atPoint将其绘制在左上方

902
00:37:40,092 --> 00:37:42,091
角落，它绘制它的自然大小。

903
00:37:42,160 --> 00:37:45,694
draw inRect将缩放到适合内部

904
00:37:45,763 --> 00:37:48,164
您提供的矩形。

905
00:37:48,233 --> 00:37:50,332
并且drawAsPattern将要平铺它。

906
00:37:50,401 --> 00:37:52,067
所以大概这是一个小小的形象

907
00:37:52,136 --> 00:37:53,869
你正在画一个纹理或某物。

908
00:37:53,938 --> 00:37:56,306
它会重复一遍

909
00:37:56,374 --> 00:37:59,342
过来填补矩形，好吗？

910
00:37:59,410 --> 00:38:01,110
我会修复这张幻灯片并转贴。

911
00:38:01,179 --> 00:38:05,748
好的，有一件事要注意UIView。

912
00:38:05,817 --> 00:38:07,917
当UIView改变大小时，

913
00:38:07,986 --> 00:38:11,587
默认情况下，您不需要重绘。

914
00:38:11,656 --> 00:38:13,556
它做的是，相信它或

915
00:38:13,625 --> 00:38:17,293
不是，拿你绘制的东西，抓住像素，和

916
00:38:17,362 --> 00:38:20,229
延伸它们以适应新的边界。

917
00:38:20,298 --> 00:38:22,465
好的，现在，这通常不是你想要的。

918
00:38:22,533 --> 00:38:24,667
通常，你想要的是，如果我的范围改变，

919
00:38:24,736 --> 00:38:28,170
请我重新刷新我的新界面，好吗？

920
00:38:28,239 --> 00:38:30,039
那么这是如何控制的？

921
00:38:30,108 --> 00:38:33,042
它通过UIView中的这个var控件称为contentMode。

922
00:38:33,110 --> 00:38:36,245
而contentMode可以是left，right，top，

923
00:38:36,314 --> 00:38:38,014
bottom，topRight，topLeft。

924
00:38:38,083 --> 00:38:40,150
这基本上是说，拿我的位和

925
00:38:40,218 --> 00:38:42,618
把它们推到左边你知道，

926
00:38:42,687 --> 00:38:44,621
其中一个点，中心或右边。

927
00:38:44,690 --> 00:38:46,656
不要触摸，不要与他们做任何事情，

928
00:38:46,724 --> 00:38:48,123
只是把它们移动到新的界限。

929
00:38:48,192 --> 00:38:50,560
那么这可能会切断你画的东西

930
00:38:50,628 --> 00:38:52,928
像这样，取决于边界有多少变化。

931
00:38:52,997 --> 00:38:54,630
喜欢旋转时，你知道，

932
00:38:54,699 --> 00:38:56,699
边界变化很大一点。

933
00:38:56,768 --> 00:38:58,334
还有缩放比例。

934
00:38:58,403 --> 00:39:00,703
这是默认的scaleToFill。

935
00:39:00,772 --> 00:39:03,873
那就是说，把我的一些东西拿走，

936
00:39:03,942 --> 00:39:05,241
缩放它来填充。

937
00:39:05,310 --> 00:39:07,243
如果我想要，我可以保留宽高比。

938
00:39:07,311 --> 00:39:08,044
虽然，再次，

939
00:39:08,113 --> 00:39:10,079
这可能会削减一些东西。

940
00:39:10,148 --> 00:39:13,215
但是你想要的是真正的重绘。

941
00:39:13,284 --> 00:39:15,518
如果将contentMode设置为.redraw，

942
00:39:15,587 --> 00:39:18,221
那么当你的边界发生变化时，你的画面就会成为

943
00:39:18,289 --> 00:39:22,892
称为 - 你的drawRect，用rect参数绘制。

944
00:39:22,960 --> 00:39:25,194
所以在你的任务三，你会想这样做。

945
00:39:25,263 --> 00:39:26,429
你可以这样做

946
00:39:26,498 --> 00:39:28,264
您可以通过设置该变量在代码中执行此操作。

947
00:39:28,332 --> 00:39:30,433
但是你也可以在Interface Builder中做，可以吗？

948
00:39:30,501 --> 00:39:32,569
在“实用程序”窗口中，在“检查器”预览中。

949
00:39:32,637 --> 00:39:35,905
只是，我认为这是最好的一个，contentMode。

950
00:39:35,974 --> 00:39:39,776
好吧，我是，我要离开这里的幻灯片

951
00:39:39,844 --> 00:39:42,245
我会告诉你什么发生了。

952
00:39:42,313 --> 00:39:45,147
我现在要做这个演示，我现在要做

953
00:39:45,216 --> 00:39:48,084
一个自定义视图，一个FaceView，一个绘制一张脸的UIView。

954
00:39:48,152 --> 00:39:50,920
然后星期三，我会谈谈手势。

955
00:39:50,988 --> 00:39:53,055
我们会添加一些手势来控制我们的脸。

956
00:39:53,124 --> 00:39:55,658
我会开始谈论多个MVC，

957
00:39:55,726 --> 00:39:58,794
我将在下周完成多个MVC。

958
00:39:58,863 --> 00:40:01,964
你的任务三要求你做多个MVC，所以

959
00:40:02,033 --> 00:40:04,500
我不会让它到期，直到下周一的一个星期，

960
00:40:04,569 --> 00:40:06,802
因为你需要下周一的讲座。

961
00:40:06,871 --> 00:40:10,306
不过，我可能会派出作业，写作，

962
00:40:10,375 --> 00:40:12,909
周三，因为这个任务的很大一部分

963
00:40:12,977 --> 00:40:15,478
正在绘制您自己的自定义视图，你一定知道

964
00:40:15,547 --> 00:40:18,080
你需要知道的一切

965
00:40:18,149 --> 00:40:19,983
所以你可以从视图开始吧

966
00:40:20,051 --> 00:40:22,418
那么下星期一，你可以开始做多个MVC。

967
00:40:22,486 --> 00:40:25,354
你还会有一个整星期，直到下个星期一，

968
00:40:25,423 --> 00:40:27,156
要做到这一点，好的。

969
00:40:27,225 --> 00:40:28,858
本周没有星期五部分

970
00:40:30,061 --> 00:40:33,562
好的，就像这个课程中的大多数演示一样，

971
00:40:33,631 --> 00:40:36,666
我要从头开始，好的。

972
00:40:36,735 --> 00:40:38,101
我们要做一个全新的应用程序

973
00:40:38,170 --> 00:40:39,836
这里没有更多的计算器。

974
00:40:39,905 --> 00:40:41,603
所以我可以点击这里打开我的计算器。

975
00:40:41,672 --> 00:40:45,508
相反，我要回到这里创建一个新的项目。

976
00:40:45,576 --> 00:40:47,576
好的，它将是单一视图应用程序，

977
00:40:47,645 --> 00:40:48,877
正如我告诉你，他们都会是。

978
00:40:48,946 --> 00:40:51,747
我会打电话给这个FaceIt，好的。

979
00:40:51,816 --> 00:40:53,449
而且，起初只是画一张脸，但是

980
00:40:53,517 --> 00:40:55,184
最终会做得更多。

981
00:40:55,253 --> 00:40:58,654
而且，还没有核心数据或测试的东西，所以

982
00:40:58,723 --> 00:41:00,790
我会在这里做FaceIt。

983
00:41:00,859 --> 00:41:02,191
它会说你想要哪里？

984
00:41:02,260 --> 00:41:04,360
我会把它放在计算器的同一个地方，

985
00:41:04,428 --> 00:41:05,094
在我的开发人员

986
00:41:05,163 --> 00:41:06,228
我不会使用SCM。

987
00:41:06,297 --> 00:41:06,963
但是当然，

988
00:41:07,032 --> 00:41:09,165
那些来到星期五的人来了，

989
00:41:09,234 --> 00:41:10,633
你会知道如何使用它。

990
00:41:10,702 --> 00:41:13,603
这里是我的新应用程序。

991
00:41:13,671 --> 00:41:15,538
而且我也要做我的标准的事情，

992
00:41:15,607 --> 00:41:17,706
在哪里我会拿这些支持文件和

993
00:41:17,775 --> 00:41:18,841
将他们赶出我们的路。

994
00:41:18,910 --> 00:41:22,444
所以他们不会分心我们每次我们看

995
00:41:22,513 --> 00:41:24,513
导航员在这里。

996
00:41:24,582 --> 00:41:27,783
因为我们不需要这个演示。

997
00:41:27,852 --> 00:41:32,154
所以就像我们所做的一切，我们有一个看法。

998
00:41:32,223 --> 00:41:35,324
这是我们的观点的故事板。

999
00:41:35,392 --> 00:41:37,393
糟糕，不是那么小。

1000
00:41:37,462 --> 00:41:39,862
当然，我们有我们的控制器。

1001
00:41:39,931 --> 00:41:41,530
我会把它从控制器中删除，

1002
00:41:41,599 --> 00:41:43,800
像往常一样

1003
00:41:43,868 --> 00:41:47,303
而这一次，我们要从这里开始吧

1004
00:41:47,372 --> 00:41:50,539
通过构建一个自定义的UIView，定制UIView子类。

1005
00:41:50,608 --> 00:41:52,274
现在，我们这样做的方式是我们建造的方式

1006
00:41:52,343 --> 00:41:53,176
CalculatorBrain。

1007
00:41:53,245 --> 00:41:54,811
我们去这里，新的文件，对吧。

1008
00:41:54,879 --> 00:41:58,714
这就是我们将新文件添加到我们的项目中。

1009
00:41:58,783 --> 00:41:59,716
但这一次，为了

1010
00:41:59,784 --> 00:42:02,985
CalculatorBrain我们选择了Swift File，因为它，你知道，

1011
00:42:03,053 --> 00:42:04,186
这不是UI的事情。

1012
00:42:04,255 --> 00:42:06,288
它没有继承任何iOS类。

1013
00:42:06,357 --> 00:42:09,391
但现在我们要选择Cocoa Touch Class，因为

1014
00:42:09,460 --> 00:42:12,461
它将成为Cocoa Touch UIKit类的子类。

1015
00:42:12,530 --> 00:42:13,463
所以我们点击。

1016
00:42:13,531 --> 00:42:16,165
它说，你想要什么是一个子类？

1017
00:42:16,234 --> 00:42:18,401
我们想要UIView，但你可以看到其他的东西。

1018
00:42:18,469 --> 00:42:19,902
UIViewController和

1019
00:42:19,971 --> 00:42:21,337
其他的事情，我们将在本季度稍后学习。

1020
00:42:21,405 --> 00:42:23,673
但这是UIView的一个子类。

1021
00:42:23,742 --> 00:42:25,607
我会叫它FaceView，

1022
00:42:25,676 --> 00:42:28,177
因为这是一个画面的观点。

1023
00:42:28,246 --> 00:42:29,912
好的，这是一个好名字。

1024
00:42:29,981 --> 00:42:31,714
好的，所以我们点击这里。

1025
00:42:31,782 --> 00:42:33,382
它说，你想把它放在哪里？

1026
00:42:33,451 --> 00:42:35,618
我们通常要小心把它放在同一个位置

1027
00:42:35,687 --> 00:42:37,052
地方就像其他一切。

1028
00:42:37,121 --> 00:42:38,521
你不需要它在Supporting Files，和

1029
00:42:38,589 --> 00:42:40,422
你不想在这个顶级的项目级别。

1030
00:42:40,491 --> 00:42:42,858
你想要这个文件夹在这里，

1031
00:42:42,927 --> 00:42:44,560
这里有你所有的东西。

1032
00:42:44,629 --> 00:42:46,462
所以我们会这样做

1033
00:42:46,531 --> 00:42:48,397
好的，所以这里是我们的FaceView。

1034
00:42:48,466 --> 00:42:51,567
你可以在FaceView中看到，我们得到这个。

1035
00:42:51,636 --> 00:42:54,970
哪个是我们的绘制，好吧，draw与rect。

1036
00:42:55,039 --> 00:42:57,340
请注意，它被注释掉。

1037
00:42:57,408 --> 00:42:59,041
那是因为

1038
00:42:59,110 --> 00:43:03,145
性能上的原因，iOS不想询问

1039
00:43:03,214 --> 00:43:05,214
实际上没有做任何绘制。

1040
00:43:05,283 --> 00:43:06,816
因为它必须保留一个后备店

1041
00:43:06,884 --> 00:43:09,818
他们有记忆商店和所有这些东西。

1042
00:43:09,887 --> 00:43:11,921
所以默认情况下这个被评论了。

1043
00:43:11,989 --> 00:43:13,956
但是，我们的FaceView当然会绘制。

1044
00:43:14,025 --> 00:43:15,458
它会画一张脸。

1045
00:43:15,527 --> 00:43:18,227
所以我们要对它进行评论。

1046
00:43:19,396 --> 00:43:22,331
好的，现在我们在这里有一个FaceView，

1047
00:43:22,400 --> 00:43:23,432
它没有画任何东西。

1048
00:43:23,501 --> 00:43:26,803
但我实际上想简要地回到我们的故事板，而且

1049
00:43:26,871 --> 00:43:28,938
将FaceView放在故事板中。

1050
00:43:29,007 --> 00:43:32,875
这真的很简单，但我想向你展示。

1051
00:43:32,943 --> 00:43:33,976
如果我们下到这个底部的对象调色板，

1052
00:43:33,977 --> 00:43:35,010
然后再次，

1053
00:43:35,080 --> 00:43:36,512
我们有我们的按钮和

1054
00:43:36,580 --> 00:43:38,481
标签，你知道我可以永远在这里搜索。

1055
00:43:38,550 --> 00:43:40,316
这里没有FaceView。

1056
00:43:40,385 --> 00:43:43,252
但是我可以在这里向下走

1057
00:43:43,320 --> 00:43:44,420
你会看到这个。

1058
00:43:44,489 --> 00:43:47,023
它实际上几乎在底部，它是View。

1059
00:43:47,091 --> 00:43:49,291
看，它代表一个矩形区域绘制

1060
00:43:49,360 --> 00:43:51,293
并按照承诺收到事件。

1061
00:43:51,362 --> 00:43:54,063
所以我可以选这个人把他拖出去。

1062
00:43:54,132 --> 00:43:58,568
好的，把他放在这个视图控制器里面。

1063
00:43:58,636 --> 00:44:00,402
并记住这个视图中的顶级视图

1064
00:44:00,471 --> 00:44:02,738
控制器是一个var称为视图(view)。

1065
00:44:02,807 --> 00:44:04,807
好的，一个非常重要的var

1066
00:44:04,876 --> 00:44:08,010
现在，我想要这个视图来填补整个空间。

1067
00:44:08,079 --> 00:44:11,314
所以我实际上会用蓝色的划线

1068
00:44:11,382 --> 00:44:15,518
让这个东西适合整个空间，你看到吗？

1069
00:44:15,586 --> 00:44:18,988
现在，好的，我也想把Ctrl拖动到

1070
00:44:19,056 --> 00:44:21,590
我们在计算器上做的边缘还记得吗？

1071
00:44:21,659 --> 00:44:23,992
但实际上很难做到这一点，因为我想要它

1072
00:44:24,061 --> 00:44:25,795
一路走到边缘。

1073
00:44:25,863 --> 00:44:29,131
但是由于我使用蓝线，我可以使用一个非常酷的

1074
00:44:29,200 --> 00:44:31,067
功能在这里，这个按钮。

1075
00:44:31,135 --> 00:44:33,068
你在右下角看到这个按钮？

1076
00:44:33,137 --> 00:44:34,603
它解决了自动布局问题。

1077
00:44:34,672 --> 00:44:35,705
如果你点击，

1078
00:44:35,773 --> 00:44:39,942
其中一个选择是重新建立约束。

1079
00:44:40,011 --> 00:44:43,779
那就是系统说，我会做出你的限制

1080
00:44:43,848 --> 00:44:45,914
你根据你做的蓝线。

1081
00:44:45,983 --> 00:44:47,483
所以我会看看你的蓝线。

1082
00:44:47,552 --> 00:44:49,752
由于我所有的边缘都使用蓝线，

1083
00:44:49,821 --> 00:44:52,354
如果我说重置建议的约束，

1084
00:44:52,423 --> 00:44:54,957
它会把这些东西挂在边缘。

1085
00:44:55,026 --> 00:44:56,592
因为这是我想要的。

1086
00:44:56,661 --> 00:45:00,128
现在我可以通过点击这里来检查它给了我什么

1087
00:45:00,197 --> 00:45:01,730
尺寸检查器。

1088
00:45:01,799 --> 00:45:02,998
如果你向下俯视

1089
00:45:03,067 --> 00:45:05,400
尺寸检查器，您可以看到所有的限制。

1090
00:45:05,469 --> 00:45:07,536
并且看看，完美的左边距到父视图，

1091
00:45:07,605 --> 00:45:08,738
这里的领先空间。

1092
00:45:08,806 --> 00:45:10,640
非常好，全部是我想要的。

1093
00:45:10,708 --> 00:45:13,943
所以在这里，我已经得到了我所有的自动布局一点击。

1094
00:45:14,011 --> 00:45:16,412
这将是可能做得相当多。

1095
00:45:16,481 --> 00:45:17,846
如果你使用那些蓝线

1096
00:45:17,915 --> 00:45:19,882
你说重置为建议的限制，

1097
00:45:19,951 --> 00:45:21,617
通常它至少会接近。

1098
00:45:21,686 --> 00:45:24,987
然后你可以调整它没有得到的那些。

1099
00:45:25,056 --> 00:45:27,656
现在，另一件关键的事情我必须在这里做

1100
00:45:27,725 --> 00:45:30,559
这是当前是一个UIView。

1101
00:45:30,628 --> 00:45:33,496
如果我在这里去看这个督察，

1102
00:45:33,564 --> 00:45:37,299
这是身份检查员，你可以看到

1103
00:45:37,368 --> 00:45:41,637
所选的东西的类是UIView。

1104
00:45:41,706 --> 00:45:43,372
所以无论我把我的draw，

1105
00:45:43,441 --> 00:45:44,406
它永远不会被调通用。

1106
00:45:44,475 --> 00:45:47,476
因为这不是一个FaceView，它是一个UIView。

1107
00:45:47,545 --> 00:45:51,847
但是我可以点击这里，下来选择FaceView。

1108
00:45:51,915 --> 00:45:55,518
现在我已经把它做成了一个FaceView。

1109
00:45:55,586 --> 00:45:57,119
我把所有的代码都放在这里。

1110
00:45:57,120 --> 00:45:58,653
那么现在，

1111
00:45:58,723 --> 00:45:59,488
就是这样，

1112
00:45:59,556 --> 00:46:02,158
这就是我需要做的，将自定义视图放入我的UI。

1113
00:46:02,226 --> 00:46:03,825
想要放置自定义视图是非常常见的

1114
00:46:03,894 --> 00:46:04,426
在UI中。

1115
00:46:04,495 --> 00:46:07,830
所以这就是为什么这么简单。

1116
00:46:07,899 --> 00:46:11,767
现在我们需要做的就是在我们的FaceView中，

1117
00:46:11,836 --> 00:46:14,636
写出绘制的代码 - 画我们的脸。

1118
00:46:14,705 --> 00:46:16,538
那么我们要做什么来画一张脸？

1119
00:46:16,607 --> 00:46:20,243
嗯，我现在要在这一轮上画这种表情脸

1120
00:46:20,311 --> 00:46:23,779
圈一个头，两眼，一点微笑。

1121
00:46:23,848 --> 00:46:25,614
好的，一个很简单的脸。

1122
00:46:25,682 --> 00:46:28,584
而且，我们开始画我们脸上的头骨，

1123
00:46:28,653 --> 00:46:30,253
这种脸的头像。

1124
00:46:31,556 --> 00:46:33,456
我刚开始这样做就画在这里。

1125
00:46:33,524 --> 00:46:36,758
我要使用UIBezierPath来做这些。

1126
00:46:36,827 --> 00:46:39,528
所以我实际上甚至不需要得到上下文。

1127
00:46:39,597 --> 00:46:41,864
该UI获取图形，获取上下文，甚至不要这样做。

1128
00:46:41,933 --> 00:46:43,499
只需自动使用UIBezierPath

1129
00:46:43,568 --> 00:46:44,833
知道你在上下文。

1130
00:46:44,902 --> 00:46:46,902
所以你不必做任何事情。

1131
00:46:46,971 --> 00:46:48,637
那么我该怎么办呢？

1132
00:46:48,706 --> 00:46:51,874
我需要想到我的脸多大。

1133
00:46:51,942 --> 00:46:54,543
我想要我的脸，如果我在横屏或竖屏，我也

1134
00:46:54,611 --> 00:46:57,613
希望我的脸能够适配两边，

1135
00:46:57,682 --> 00:46:58,481
高度或宽度。

1136
00:46:58,549 --> 00:46:59,248
你知道我的意思？

1137
00:46:59,317 --> 00:47:02,451
因为我总是希望脸部完全适合那里。

1138
00:47:02,519 --> 00:47:06,522
所以我要让我的头脑半径，所以就这样

1139
00:47:06,590 --> 00:47:10,559
是我的头骨的半径，好的，等于最小。

1140
00:47:10,628 --> 00:47:11,927
还有这个很好的最小，

1141
00:47:11,996 --> 00:47:14,129
你看到那个最小的功能呢？

1142
00:47:14,198 --> 00:47:16,799
它是通用类型的数组。

1143
00:47:16,868 --> 00:47:18,200
T的数组，那就是T.

1144
00:47:18,268 --> 00:47:19,368
它会采取任何类型。

1145
00:47:19,437 --> 00:47:20,836
它会比较两件事情，

1146
00:47:20,905 --> 00:47:22,572
返回最低的。

1147
00:47:22,640 --> 00:47:25,808
所以我要得到我的限制，

1148
00:47:25,876 --> 00:47:30,412
bounds.size.width和我的bounds.size.height。

1149
00:47:30,481 --> 00:47:32,814
然后我要把它除以2，因为它是半径，

1150
00:47:32,883 --> 00:47:33,915
不是直径

1151
00:47:33,984 --> 00:47:35,618
那么现在看看我在做什么

1152
00:47:35,686 --> 00:47:38,954
我只是这样做，使我的脑袋的半径将是

1153
00:47:39,023 --> 00:47:41,424
较小的宽度或高度。

1154
00:47:41,492 --> 00:47:43,392
那么，我想要脑袋在哪里呢？

1155
00:47:43,461 --> 00:47:44,860
嗯，我希望它在中心是正确的。

1156
00:47:44,929 --> 00:47:51,700
那我可以说，让脑袋中心等于我的中心？

1157
00:47:51,769 --> 00:47:53,736
好的，那是一种方法，可以这么说吗？

1158
00:47:53,805 --> 00:47:55,838
这是一个var，有什么问题吗？

1159
00:47:55,906 --> 00:47:58,241
不，我看到摇头 - 为什么不这样呢？

1160
00:48:00,511 --> 00:48:01,077
是吗？

1161
00:48:04,215 --> 00:48:07,483
他说，因为它将从左上角开始。

1162
00:48:07,551 --> 00:48:08,684
不完全的。

1163
00:48:08,753 --> 00:48:10,419
有人想把这个刺伤吗？

1164
00:48:12,490 --> 00:48:16,558
这是因为中心，而它是这个视图的中心，

1165
00:48:16,627 --> 00:48:18,995
它在错误的坐标系中。

1166
00:48:19,063 --> 00:48:21,330
这个中心位于我的superview坐标系统

1167
00:48:21,398 --> 00:48:22,464
我正在画画。

1168
00:48:22,533 --> 00:48:24,099
我需要在我的坐标系中。

1169
00:48:24,168 --> 00:48:26,268
所以在这里实际上可以做两件事情。

1170
00:48:26,336 --> 00:48:28,804
一个我可以使用这个很酷的功能在视图中调用

1171
00:48:28,872 --> 00:48:31,640
转换将转换一个点

1172
00:48:31,709 --> 00:48:33,509
从一个坐标系到另一个坐标系。

1173
00:48:33,577 --> 00:48:37,045
所以我可以下去这一个好吧

1174
00:48:37,114 --> 00:48:39,481
从视图转换CGPoint，和

1175
00:48:39,550 --> 00:48:44,353
我可以将这个点中心从我的超级视图中转换出来。

1176
00:48:46,290 --> 00:48:48,423
好的，所以只要使用中心，我可以转换它。

1177
00:48:48,492 --> 00:48:51,526
那会好的，因为我把它转换了

1178
00:48:51,595 --> 00:48:53,462
一个坐标系，我的父视图，我的。

1179
00:48:55,032 --> 00:48:56,298
那可能是一点点

1180
00:48:56,366 --> 00:48:57,733
读这个代码的人就像，

1181
00:48:57,802 --> 00:48:59,135
嗯，他们为什么这样做？

1182
00:48:59,203 --> 00:49:03,505
一个更简单的方法可能就是创建

1183
00:49:03,574 --> 00:49:08,944
一个点，一个CGPoint，这是我的边界midX，这是我的

1184
00:49:09,013 --> 00:49:14,850
X的中间，看，这是一个rect，我的边界在midY。

1185
00:49:14,919 --> 00:49:17,453
好的。

1186
00:49:17,521 --> 00:49:18,687
所以我只是创造了一个中心点，

1187
00:49:18,688 --> 00:49:19,854
这就说得通了？

1188
00:49:19,923 --> 00:49:22,525
更直接地在那里

1189
00:49:22,593 --> 00:49:24,860
好的，所以现在我有半径和中心。

1190
00:49:24,929 --> 00:49:26,494
现在我需要画一个圆圈。

1191
00:49:26,563 --> 00:49:27,629
那么我如何画一个圆圈？

1192
00:49:27,698 --> 00:49:29,865
我会用UIBezierPath这样做。

1193
00:49:29,934 --> 00:49:33,002
所以我要说让路径等于UIBezierPath。

1194
00:49:33,071 --> 00:49:34,836
现在，当我们看看构造函数

1195
00:49:34,905 --> 00:49:38,807
UIBezierPath在这里你可以看到我们可以画一个弧。

1196
00:49:38,876 --> 00:49:40,342
这其实是我要使用的。

1197
00:49:40,411 --> 00:49:42,611
我们可以画一个椭圆形，这很酷，

1198
00:49:42,679 --> 00:49:44,346
除了论证是一个直觉，和

1199
00:49:44,414 --> 00:49:45,614
我有中心和半径。

1200
00:49:45,682 --> 00:49:47,983
所以我不能，我真的不想用椭圆形。

1201
00:49:48,052 --> 00:49:48,984
我们可以画一个矩形

1202
00:49:49,052 --> 00:49:51,186
我想要一个圈子，所以这不是很好。

1203
00:49:51,255 --> 00:49:52,121
或圆角。

1204
00:49:52,190 --> 00:49:53,355
我其实想要圈子，

1205
00:49:53,423 --> 00:49:55,090
不是任何一种矩形，好吗？

1206
00:49:55,158 --> 00:49:57,560
所以我会在这里使用这一个画一个弧。

1207
00:49:57,628 --> 00:50:01,263
它只需要一个中心点，它画一个弧线。

1208
00:50:01,332 --> 00:50:03,966
我会把这个弧线全部画出来

1209
00:50:04,035 --> 00:50:06,101
做一个圈子好吗？

1210
00:50:06,169 --> 00:50:06,835
那么这是如何工作的？

1211
00:50:06,904 --> 00:50:09,070
在这里，我要做一些更多的空间。

1212
00:50:09,139 --> 00:50:11,807
好的，所以它想知道弧的中心。

1213
00:50:11,876 --> 00:50:14,309
那是我的脑袋中心，对吧？

1214
00:50:14,378 --> 00:50:16,478
它想知道弧的半径，好吧，

1215
00:50:16,547 --> 00:50:19,080
这就是我的脑袋半径，这很容易。

1216
00:50:19,149 --> 00:50:20,749
它想知道起始角度。

1217
00:50:20,817 --> 00:50:24,052
所以这是它将要开始扫视的角度。

1218
00:50:24,121 --> 00:50:24,920
我要选择0，

1219
00:50:24,989 --> 00:50:30,526
角度0直接向右移动。

1220
00:50:31,662 --> 00:50:32,861
好的，所以如果你正在看屏幕，

1221
00:50:32,930 --> 00:50:35,830
直到右边，这是0。

1222
00:50:35,899 --> 00:50:37,099
而且是弧度，

1223
00:50:37,167 --> 00:50:40,235
有多少人知道弧度是衡量角度的？

1224
00:50:40,304 --> 00:50:41,269
好的，大多数人

1225
00:50:41,338 --> 00:50:43,138
所以弧度而不是度数，

1226
00:50:43,207 --> 00:50:45,908
我们测量我们要多少弧度。

1227
00:50:45,976 --> 00:50:49,244
半径从零开始一直到两个pi。

1228
00:50:49,313 --> 00:50:50,412
绕圈子

1229
00:50:50,481 --> 00:50:53,949
从零开始，然后它会绕过，pi超过两个，

1230
00:50:54,018 --> 00:50:56,852
pi，你知道，然后pi是180度和

1231
00:50:56,921 --> 00:50:59,521
那么大概到两个pi是360度。

1232
00:50:59,590 --> 00:51:02,191
所以这是弧度，所以这个角度必须是弧度

1233
00:51:02,259 --> 00:51:03,592
我想一路走来。

1234
00:51:03,661 --> 00:51:05,761
所以是2倍pi。

1235
00:51:05,830 --> 00:51:08,163
我们知道Double.pi是pi。

1236
00:51:08,232 --> 00:51:10,766
然后顺时针是否我会画弧

1237
00:51:10,835 --> 00:51:12,301
顺时针或另一种方式。

1238
00:51:12,370 --> 00:51:14,336
没关系，因为我要一路走来

1239
00:51:14,405 --> 00:51:16,171
无论如何，回到原点。

1240
00:51:16,240 --> 00:51:17,706
所以我只会说错误。

1241
00:51:17,775 --> 00:51:19,841
在那里你逆时针走。

1242
00:51:19,910 --> 00:51:22,110
现在，我在这里发出了一个警告，一个错误。

1243
00:51:22,179 --> 00:51:22,845
我们来看看那个错误。

1244
00:51:22,913 --> 00:51:26,147
它说什么，它说二进制运算符*（而且是

1245
00:51:26,216 --> 00:51:29,485
指向这个小乘数在这里）不能

1246
00:51:29,553 --> 00:51:32,121
应用于“Int”和“Double”。

1247
00:51:32,189 --> 00:51:33,489
为什么说呢

1248
00:51:34,959 --> 00:51:36,759
UIBezierPath的这些参数，

1249
00:51:36,827 --> 00:51:39,428
浮点参数就像一个startAngle和

1250
00:51:39,497 --> 00:51:42,531
endAngle，你觉得应该是什么类型的？

1251
00:51:45,836 --> 00:51:47,803
没有人？

1252
00:51:47,872 --> 00:51:50,472
我听说有人低声说，是的，CGFloat。

1253
00:51:50,541 --> 00:51:52,541
所有绘图必须是CGFloat。

1254
00:51:52,610 --> 00:51:56,011
Double.pi，那是一个CGFloat？

1255
00:51:56,080 --> 00:51:57,045
不，这是一个double。

1256
00:51:57,114 --> 00:51:59,214
两个是CGFloat？

1257
00:51:59,283 --> 00:52:00,382
那可能是

1258
00:52:00,450 --> 00:52:02,784
但是Swift将不得不推测它是一个CGFloat。

1259
00:52:02,853 --> 00:52:05,187
现在，Swift对这是什么感到困惑

1260
00:52:05,256 --> 00:52:07,122
应该是因为它知道这个参数

1261
00:52:07,191 --> 00:52:08,724
应该是一个CGFloat，但是

1262
00:52:08,793 --> 00:52:10,425
你乘的东西是double。

1263
00:52:10,494 --> 00:52:12,628
所以Swift不知道在这里推断什么。

1264
00:52:12,697 --> 00:52:15,264
不知道是否将其称为Double或

1265
00:52:15,332 --> 00:52:16,265
一个CGFloat。

1266
00:52:16,333 --> 00:52:20,302
所以在这里修复，幸运的是，CGFloat有一个pi。

1267
00:52:22,105 --> 00:52:23,439
就像double。

1268
00:52:23,507 --> 00:52:26,308
现在，大家都快乐，因为Swift知道如何

1269
00:52:26,377 --> 00:52:29,745
将此文字解释为CGFloat。

1270
00:52:29,813 --> 00:52:32,247
而对于EndAngle来说，这个参数现在是CGFloat。

1271
00:52:32,316 --> 00:52:33,114
所以现在大家都很高兴

1272
00:52:33,183 --> 00:52:36,151
只是抱怨说我们还没有使用路径。

1273
00:52:36,220 --> 00:52:37,519
好的？

1274
00:52:37,587 --> 00:52:39,554
非常好，所以现在我们得到了这个弧。

1275
00:52:39,623 --> 00:52:42,558
让我们设置一些关于路径的东西，就像它的线宽一样

1276
00:52:42,626 --> 00:52:45,193
例如，我们将设置一个很好的，相当粗的行，

1277
00:52:45,262 --> 00:52:48,330
5的宽度，这就是这个意思，

1278
00:52:48,398 --> 00:52:50,432
5.0，5 pt 的宽。

1279
00:52:50,501 --> 00:52:52,334
然后让我们设置颜色。

1280
00:52:52,403 --> 00:52:56,171
所以我会得到UIColor，让我们说，蓝色和

1281
00:52:56,240 --> 00:53:00,743
我们会说set，顺便说一下setFill和setStroke

1282
00:53:00,811 --> 00:53:02,110
还有一套。

1283
00:53:02,179 --> 00:53:04,346
设置设置填充和描边。

1284
00:53:04,415 --> 00:53:06,482
这里我们只需要设置笔画颜色，但是

1285
00:53:06,550 --> 00:53:09,351
我只想说一下，让你了解一下。

1286
00:53:09,420 --> 00:53:13,521
而现在我可以说路径描边好吧

1287
00:53:13,590 --> 00:53:15,924
它会描边那个路径。

1288
00:53:15,992 --> 00:53:17,025
所以我们来看看这个样子。

1289
00:53:17,094 --> 00:53:19,495
我们来这里做iPhone 7。

1290
00:53:21,899 --> 00:53:24,600
所以希望这会画我们的脑袋。

1291
00:53:35,979 --> 00:53:37,145
我们去，一个脑袋。

1292
00:53:37,214 --> 00:53:38,647
呃，第一次，优秀。

1293
00:53:38,715 --> 00:53:42,083
好的，现在我不喜欢那个样子

1294
00:53:42,152 --> 00:53:44,419
很多因为它一直到边缘和

1295
00:53:44,488 --> 00:53:46,555
有一条粗线实际上被切断了一点。

1296
00:53:46,623 --> 00:53:49,057
所以我想移动一点，所以我们会这样做。

1297
00:53:49,126 --> 00:53:51,794
我们来回转，从肖像(portrait 竖屏)到风景(landscape 横屏)。

1298
00:53:54,731 --> 00:53:57,032
不好，不好

1299
00:53:57,101 --> 00:53:58,734
好的，为什么会这样呢？

1300
00:53:58,802 --> 00:53:59,234
这是做的

1301
00:53:59,303 --> 00:54:00,401
那就是那个内容

1302
00:54:00,470 --> 00:54:01,904
正在谈论的模式的事情，对吧？

1303
00:54:01,972 --> 00:54:05,307
当它去另一个时，它不是叫我的画

1304
00:54:07,744 --> 00:54:11,113
绑定的大小就在那里，所以它只是缩放位。

1305
00:54:11,181 --> 00:54:12,547
所以我们来解决这两个问题，

1306
00:54:12,616 --> 00:54:15,784
让我们来一点点，让我们来解决这些问题。

1307
00:54:15,853 --> 00:54:18,887
为了解决这个问题，我们要回去

1308
00:54:18,956 --> 00:54:22,024
故事板，并在这里点击我们的观点。

1309
00:54:22,092 --> 00:54:23,459
让我们摆脱这个。

1310
00:54:23,527 --> 00:54:28,029
好的，点击我们的View，然后转到Utilities。

1311
00:54:28,098 --> 00:54:30,866
使用属性检查器检查并查看，

1312
00:54:30,934 --> 00:54:34,603
第一个，内容模式，填充量表。

1313
00:54:34,671 --> 00:54:37,605
每次边界改变它的比例到比特填充

1314
00:54:37,674 --> 00:54:40,375
我们想要重绘。

1315
00:54:40,444 --> 00:54:42,777
我们也可能使用中心，但是

1316
00:54:42,846 --> 00:54:45,280
我实际上想要重绘，因为如果我的边界更小

1317
00:54:45,349 --> 00:54:47,148
例如，我想画我的脸较小。

1318
00:54:47,217 --> 00:54:49,951
我不想被切断。

1319
00:54:50,020 --> 00:54:51,052
好的，所以有重绘。

1320
00:54:51,121 --> 00:54:53,588
那固定那个，那很容易解决。

1321
00:54:53,657 --> 00:54:56,725
如何使这个东西有点小？

1322
00:54:56,793 --> 00:55:02,631
为了做到这一点，我实际上会创建一个名为scale的变量。

1323
00:55:02,699 --> 00:55:06,268
这是一个绘画的东西，所以它是一个CGFloat。

1324
00:55:06,336 --> 00:55:09,871
我要设置它说0.9和

1325
00:55:09,940 --> 00:55:11,406
这意味着90％。

1326
00:55:11,475 --> 00:55:13,574
我要做的只有我的半径

1327
00:55:13,643 --> 00:55:15,777
将其乘以该比例。

1328
00:55:15,846 --> 00:55:17,780
所以我的半径乘以0.9或

1329
00:55:17,848 --> 00:55:21,450
90％应该放大一点点。

1330
00:55:21,518 --> 00:55:23,585
种类从边缘90％。

1331
00:55:23,653 --> 00:55:29,358
所以我们来看看这两个事情是否得到修复。

1332
00:55:33,864 --> 00:55:34,929
所以90％可以的。

1333
00:55:34,998 --> 00:55:40,235
显然，这是在90％，旋转也是。

1334
00:55:40,303 --> 00:55:42,204
所以我们在这里开始很好，

1335
00:55:42,273 --> 00:55:43,405
事情似乎工作正常。

1336
00:55:43,474 --> 00:55:45,974
好的，那我们下一步要做什么呢？

1337
00:55:46,043 --> 00:55:47,943
嗯，我们想画眼睛

1338
00:55:48,012 --> 00:55:50,579
一个嘴和这样的东西，我想开始思考

1339
00:55:50,647 --> 00:55:52,814
一点关于我的内部架构。

1340
00:55:52,883 --> 00:55:55,817
我很喜欢有一些私人功能的想法，

1341
00:55:55,886 --> 00:55:58,454
像给我脑袋的路径。

1342
00:56:00,257 --> 00:56:04,526
并返回一个UIBezierPath

1343
00:56:04,595 --> 00:56:06,562
然后我可以描边。

1344
00:56:06,630 --> 00:56:08,130
然后我会有同样的事情，给我的眼睛的路径

1345
00:56:08,199 --> 00:56:09,464
给我一条嘴巴的路径

1346
00:56:09,533 --> 00:56:10,398
你看到我的意思？

1347
00:56:10,467 --> 00:56:11,466
我会得到所有这些。

1348
00:56:11,535 --> 00:56:14,436
所以我可以把这个代码放在这里

1349
00:56:14,505 --> 00:56:16,505
为脑袋创造了这条路

1350
00:56:16,573 --> 00:56:19,941
我只是把它放在这里，我只是返回这个路径。

1351
00:56:20,010 --> 00:56:24,412
然后，在这里，而不是说路径。

1352
00:56:24,481 --> 00:56:27,883
我命名 pathForSkull()。stroke()。

1353
00:56:27,951 --> 00:56:29,784
你看到了吗？

1354
00:56:29,853 --> 00:56:32,087
现在，另一件事是skullRadius和

1355
00:56:32,156 --> 00:56:34,756
skullCenter，我想要所有其他的东西像眼睛

1356
00:56:34,825 --> 00:56:38,059
和所有人的嘴相对于这一点。

1357
00:56:38,128 --> 00:56:40,462
所以如果我把我的头脑小我需要眼睛变小，

1358
00:56:40,531 --> 00:56:42,730
嘴巴变得越来越小，一切都在移动。

1359
00:56:42,799 --> 00:56:44,232
所以我要用这两个人，

1360
00:56:44,301 --> 00:56:46,801
我要做他们而不是局部变量绘制，

1361
00:56:46,870 --> 00:56:51,707
我要把它们移出来，使它们变成私有的vars。

1362
00:56:51,775 --> 00:56:55,410
具体来说，它们将是私有的计算变量。

1363
00:56:55,479 --> 00:56:58,346
所以我只是要把他们以前和

1364
00:56:58,415 --> 00:57:01,516
我只是要回来，所以不管我是谁

1365
00:57:01,585 --> 00:57:04,386
在任何给定的时间，边界都是skullRadius，

1366
00:57:04,455 --> 00:57:07,989
那个var  - 当然我们必须键入，所以CGFloat  - 那个

1367
00:57:08,058 --> 00:57:11,459
skullRadius总是要按照边界进行匹配，好吗？

1368
00:57:11,528 --> 00:57:12,794
因为每次我要求它，

1369
00:57:12,862 --> 00:57:15,396
我会用这个小功能重新计算它。

1370
00:57:15,465 --> 00:57:16,631
和skullCenter相同的东西，

1371
00:57:16,700 --> 00:57:19,133
我会说私人var skullCenter，

1372
00:57:19,202 --> 00:57:23,037
这也是一个CGFloat，没有一个是CGPoint，而且

1373
00:57:23,106 --> 00:57:24,807
它将被计算。

1374
00:57:27,511 --> 00:57:29,010
现在你有一件事在这里注意到，

1375
00:57:29,079 --> 00:57:31,746
我不记得我是否在其他演讲中介绍了这个

1376
00:57:31,815 --> 00:57:34,549
你注意到，我不是说到这里。

1377
00:57:34,618 --> 00:57:36,818
看，我不会放下来。

1378
00:57:36,887 --> 00:57:39,554
嗯，我没有设置，因为你不能设置

1379
00:57:39,623 --> 00:57:40,955
脑袋中心。

1380
00:57:41,024 --> 00:57:43,458
脑袋中心永远是我界限的中心

1381
00:57:43,526 --> 00:57:44,559
我无法设定

1382
00:57:44,628 --> 00:57:46,662
然后如果你只有一个得到，

1383
00:57:46,730 --> 00:57:48,363
原来你不需要得到。

1384
00:57:48,432 --> 00:57:50,198
因为它有点多余。

1385
00:57:50,267 --> 00:57:54,202
所以你在这里得到这个更好看的代码。

1386
00:57:54,271 --> 00:57:55,604
所以现在我们有skullRadius和

1387
00:57:55,672 --> 00:57:58,006
skullCenter可用于我们所有的方法。

1388
00:57:58,074 --> 00:58:00,675
所以我们所有的其他路径，像眼睛的路径

1389
00:58:00,744 --> 00:58:02,443
所有这些东西都可以使用它们。

1390
00:58:02,512 --> 00:58:03,311
所以让我们开始吧。

1391
00:58:03,380 --> 00:58:05,714
让我们做一个眼睛的路，怎么样

1392
00:58:05,782 --> 00:58:07,916
所以在私有(private)的func，pathForEye。

1393
00:58:07,984 --> 00:58:10,852
现在其实可能是眼睛的路径

1394
00:58:10,921 --> 00:58:13,287
对于左眼和右眼几乎相同。

1395
00:58:13,356 --> 00:58:17,125
所以我要在这里创建一个叫Eye的小类型

1396
00:58:18,128 --> 00:58:19,428
只是一个小枚举。

1397
00:58:21,665 --> 00:58:26,601
而且这只是左眼和右眼

1398
00:58:26,670 --> 00:58:28,537
私有枚举眼(private enum Eye)。

1399
00:58:28,605 --> 00:58:35,844
我们来看看眼睛是左边的情况，好的。

1400
00:58:35,912 --> 00:58:38,713
所以我的意思是使用枚举是非常好的

1401
00:58:38,782 --> 00:58:40,549
只是为了代表像这样的简单的东西。

1402
00:58:40,617 --> 00:58:43,451
你不必一直在做方法

1403
00:58:43,520 --> 00:58:44,419
相关值。

1404
00:58:44,488 --> 00:58:45,820
我们在这里没有任何关联的值。

1405
00:58:45,889 --> 00:58:49,057
我们只是将其表示为在该API中指定的方式，

1406
00:58:49,125 --> 00:58:54,228
哪个眼睛我们想要的路径，UIBezierPath，for。

1407
00:58:54,297 --> 00:58:57,766
所以，顺便说一句，我也想有一些常数

1408
00:58:57,834 --> 00:59:01,069
告诉我眼睛相对于中心的位置

1409
00:59:01,137 --> 00:59:04,038
嘴在哪里，眼睛有多大。

1410
00:59:04,107 --> 00:59:07,075
所以为了节省一点时间在这里，我要去

1411
00:59:07,143 --> 00:59:11,913
在这里真正快速地输入底部的那些。

1412
00:59:11,982 --> 00:59:13,581
看看我打了多快。

1413
00:59:13,650 --> 00:59:14,716
顺便说一句，我们怎么做

1414
00:59:16,253 --> 00:59:20,188
常量在swift我们只是创建一个结构，我们做

1415
00:59:20,257 --> 00:59:25,193
静态static let它是我们所有的常量和

1416
00:59:25,262 --> 00:59:28,463
这真的很酷，它将它们组合在一起。

1417
00:59:28,532 --> 00:59:29,697
像这里我有比率(Ratios)，

1418
00:59:29,766 --> 00:59:33,634
这是所有颅骨半径和所有这些之间的比例

1419
00:59:33,703 --> 00:59:36,271
我想做的事情像眼睛的偏移和嘴巴。

1420
00:59:37,240 --> 00:59:38,473
还可以输入它们。

1421
00:59:38,541 --> 00:59:40,608
你看到这些是类型的常量。

1422
00:59:40,677 --> 00:59:42,811
我可以把类型放在那里，因为它们只是vars，

1423
00:59:42,880 --> 00:59:45,580
它们是这个结构体上的静态变量。

1424
00:59:45,649 --> 00:59:46,948
好的。我们没有任何存储空间

1425
00:59:47,016 --> 00:59:47,481
在这个结构中。

1426
00:59:47,550 --> 00:59:48,483
没有任何方法。

1427
00:59:48,552 --> 00:59:50,318
它只是用于这里的常数。

1428
00:59:50,387 --> 00:59:54,523
现在，我将在这里使用这些常数

1429
00:59:54,591 --> 00:59:56,191
我会用颅骨半径和

1430
00:59:56,259 --> 00:59:59,360
中心在这里计算眼睛的路径。

1431
00:59:59,429 --> 01:00:00,295
那我该怎么办呢？

1432
01:00:00,363 --> 01:00:03,331
首先我需要眼睛的中心。

1433
01:00:03,400 --> 01:00:05,901
现在，我要创建一个函数来计算

1434
01:00:05,969 --> 01:00:06,902
眼睛的中心。

1435
01:00:06,970 --> 01:00:09,337
但是我只需要使用pathForEye。

1436
01:00:09,406 --> 01:00:13,108
所以我实际上会把它放在pathForEye里面。

1437
01:00:13,176 --> 01:00:16,277
所以我要在这里创建一个函数centerOfEye。

1438
01:00:16,346 --> 01:00:18,746
请快速输入，以节省一些时间。

1439
01:00:18,815 --> 01:00:20,015
我会通过它。

1440
01:00:20,083 --> 01:00:23,051
和centerOfEye，看看它是如何在pathForEye。

1441
01:00:23,120 --> 01:00:25,954
这是完全合法的，有些人可能正在使用

1442
01:00:26,023 --> 01:00:27,855
那个策略在你的任务中两个。

1443
01:00:27,924 --> 01:00:30,225
我想我提到了一个提示，你可以做到这一点。

1444
01:00:30,294 --> 01:00:33,160
它所做的一切就是把它放在里面，

1445
01:00:33,229 --> 01:00:34,729
因为它不需要其他地方。

1446
01:00:34,797 --> 01:00:36,564
所以现在，我的代码的读者不必担心这一点

1447
01:00:36,633 --> 01:00:37,899
事情被别的地方叫了，

1448
01:00:37,968 --> 01:00:39,267
什么是语义可能在那里

1449
01:00:39,336 --> 01:00:41,702
他们已经知道它只用于这个好的，

1450
01:00:41,771 --> 01:00:44,239
这里的空间很小，所以这是一个很好的方法

1451
01:00:44,308 --> 01:00:46,842
安排您的代码，使其更易读。

1452
01:00:48,245 --> 01:00:49,510
那么centerOfEye如何工作？

1453
01:00:49,579 --> 01:00:51,279
它需要眼睛，和

1454
01:00:51,348 --> 01:00:54,782
它只是通过拍摄颅骨半径来获得眼睛的偏移

1455
01:00:54,851 --> 01:00:56,584
将其除以这些常数之一，

1456
01:00:56,653 --> 01:00:59,287
颅骨半径与眼睛偏移之间的比例，

1457
01:00:59,356 --> 01:01:01,322
这是多少它会抵消眼睛。

1458
01:01:01,391 --> 01:01:03,991
现在我会像我一样把眼睛的眼睛和眼睛相同

1459
01:01:04,060 --> 01:01:04,726
到两边。

1460
01:01:05,963 --> 01:01:09,230
所以我们脸上的鼻子之间的界线

1461
01:01:09,299 --> 01:01:11,332
两眼会变成等边三角形，否则，

1462
01:01:11,401 --> 01:01:13,134
不是很平衡。

1463
01:01:13,203 --> 01:01:13,935
可能会更宽一点，但是

1464
01:01:14,004 --> 01:01:19,040
同样的距离上升，因为它出来到两边。

1465
01:01:19,109 --> 01:01:20,709
我将从eyeCenter处于中心开始。

1466
01:01:20,710 --> 01:01:22,310
之后

1467
01:01:22,378 --> 01:01:24,145
我从眼睛的中心开始，并且

1468
01:01:24,214 --> 01:01:26,080
然后我会一直移动它。

1469
01:01:26,149 --> 01:01:27,515
好的。所以在这里我正在移动它。

1470
01:01:27,584 --> 01:01:30,352
注意up是减去眼睛偏移，

1471
01:01:30,420 --> 01:01:34,222
因为y减少了，y增加了。

1472
01:01:34,291 --> 01:01:38,793
而对于x，我要添加眼睛偏移或

1473
01:01:38,862 --> 01:01:41,129
减去眼睛偏移，

1474
01:01:41,197 --> 01:01:43,164
取决于它是左眼还是右眼。

1475
01:01:43,233 --> 01:01:46,234
所以对于左眼，我要减去眼睛偏移。

1476
01:01:46,303 --> 01:01:48,437
而对于右眼，我要添加眼睛偏移。

1477
01:01:49,506 --> 01:01:50,371
好的？

1478
01:01:50,440 --> 01:01:51,773
大家都明白这点

1479
01:01:51,842 --> 01:01:52,974
在那里建造，我希望。

1480
01:01:54,144 --> 01:01:55,343
好的，然后它返回中心点。

1481
01:01:55,412 --> 01:01:57,044
所以现在我有眼睛的中心。

1482
01:01:57,113 --> 01:01:58,880
所以使用眼睛的中心，

1483
01:01:58,948 --> 01:02:02,084
我可以说让眼睛半径等于脑袋半径

1484
01:02:05,321 --> 01:02:10,024
除以该比例，

1485
01:02:10,093 --> 01:02:16,364
这是skullRadiusToEyeRadius。

1486
01:02:16,432 --> 01:02:18,766
好的，这就是我要做的。

1487
01:02:18,835 --> 01:02:21,469
我会让eyeCenter刚刚

1488
01:02:21,538 --> 01:02:23,137
等于centerOfEye，无论哪个眼睛。

1489
01:02:23,206 --> 01:02:25,306
眼睛在这里。

1490
01:02:25,375 --> 01:02:28,510
所以我只是在这里调用这个小函数。

1491
01:02:30,981 --> 01:02:33,681
所以我有这两件事情。

1492
01:02:33,750 --> 01:02:35,583
所以我可以创建另一个圆。

1493
01:02:35,652 --> 01:02:39,087
所以我要让路径相等UIBezierPath和

1494
01:02:39,156 --> 01:02:40,555
再次做那个弧

1495
01:02:40,623 --> 01:02:42,190
这里的中心是眼睛中心。

1496
01:02:42,258 --> 01:02:44,492
半径是眼睛半径。

1497
01:02:44,560 --> 01:02:46,461
起始角度仍为零。

1498
01:02:46,529 --> 01:02:49,530
然后端角依然是CGFloat.pi * 2，顺时针方向，

1499
01:02:49,599 --> 01:02:50,264
没关系。

1500
01:02:50,333 --> 01:02:52,400
这次我会走另一回事。

1501
01:02:52,469 --> 01:02:54,769
好的，所以有我的路径。

1502
01:02:54,838 --> 01:02:58,439
让我们再次设置path.lineWidth等于5.0。

1503
01:02:58,508 --> 01:03:00,341
开始厌倦打字了。

1504
01:03:00,410 --> 01:03:01,876
这可能不是一件好事。

1505
01:03:01,945 --> 01:03:03,145
然后让我们返回路径。

1506
01:03:04,848 --> 01:03:06,013
好的。就是这样了。

1507
01:03:06,082 --> 01:03:07,949
这样就可以获得左眼的路径

1508
01:03:08,018 --> 01:03:11,052
右眼。

1509
01:03:11,120 --> 01:03:14,356
我们会说pathForEye，左眼，描边。

1510
01:03:15,959 --> 01:03:19,561
好吧，pathForEye，右眼，描边。

1511
01:03:21,131 --> 01:03:22,964
好的，我希望大家对这个事实很满意

1512
01:03:23,033 --> 01:03:24,866
我正在调用一个方法，取这个返回值，和

1513
01:03:24,934 --> 01:03:26,201
立即发送消息。

1514
01:03:29,339 --> 01:03:30,271
所以，我们来看看这是怎么回事。

1515
01:03:30,340 --> 01:03:31,239
我们来看看我们是否有这个权利。

1516
01:03:39,282 --> 01:03:40,348
看那个。

1517
01:03:40,417 --> 01:03:41,415
第一次。

1518
01:03:41,484 --> 01:03:42,884
今天真的很好

1519
01:03:42,953 --> 01:03:45,186
好的，所以有两条线，他们看起来不错。

1520
01:03:45,255 --> 01:03:46,621
你知道什么会很酷吗？

1521
01:03:46,690 --> 01:03:48,957
如果我们可以睁开眼睛，闭上眼睛。

1522
01:03:50,460 --> 01:03:52,760
那么我们怎么能睁开眼睛呢？

1523
01:03:52,829 --> 01:03:54,229
这样呢，我们来这里，就像我们这样做

1524
01:03:54,230 --> 01:03:55,630
闭眼

1525
01:03:55,698 --> 01:03:58,633
var scale，通知我离开了var public。

1526
01:03:58,701 --> 01:04:00,568
规模化，让使用我的脸的人，

1527
01:04:00,637 --> 01:04:02,236
他们可以控制面部的大小。

1528
01:04:02,305 --> 01:04:03,505
我不介意

1529
01:04:03,573 --> 01:04:06,107
而且，我也会打开眼睛，这将是

1530
01:04:06,176 --> 01:04:08,409
一个bool，这将开始是false的。

1531
01:04:08,478 --> 01:04:10,344
我们要做我们的路径，

1532
01:04:10,413 --> 01:04:13,314
看看这个var，看看这个var的值。

1533
01:04:13,383 --> 01:04:15,583
还有眼睛打开或关闭。

1534
01:04:15,651 --> 01:04:18,052
所以，我回到这里走在路上。

1535
01:04:18,121 --> 01:04:21,322
所以，如果眼睛是开放的，那么我们就会做我们的事情

1536
01:04:21,391 --> 01:04:23,925
已经在这里做这个事了。

1537
01:04:23,994 --> 01:04:26,027
好的，因为这是我们到目前为止所做的。

1538
01:04:26,096 --> 01:04:27,962
但如果眼睛闭上眼睛，

1539
01:04:28,031 --> 01:04:29,497
那么我想要的路径是不同的。

1540
01:04:29,566 --> 01:04:31,099
所以，看看我要在这里做什么

1541
01:04:31,168 --> 01:04:37,172
让路径是一个UIBezierPath，没有初始值。

1542
01:04:39,075 --> 01:04:42,744
好的，然后我把它放在这里，我要把它放在这里

1543
01:04:42,812 --> 01:04:44,212
这是允许的。

1544
01:04:44,281 --> 01:04:46,147
换句话说， Swift很聪明地知道，

1545
01:04:46,216 --> 01:04:49,417
你创建了一个let，它只能被初始化一次。

1546
01:04:49,486 --> 01:04:52,019
但是你有条件地在这里初始化它，

1547
01:04:52,088 --> 01:04:54,356
因为现在我要说路径相等。

1548
01:04:54,424 --> 01:04:56,257
对于封闭的情况，我只是要做

1549
01:04:56,326 --> 01:04:58,793
一个开始空白的贝塞尔路径。

1550
01:04:58,862 --> 01:05:00,662
然后我要搬到，直到，

1551
01:05:00,730 --> 01:05:04,032
为闭合眼睛做一点水平线。

1552
01:05:04,100 --> 01:05:07,435
所以，我要说path.move(to:)来移

1553
01:05:07,504 --> 01:05:12,974
一点，CGPoint，我们在这里使用这个构造函数。

1554
01:05:13,043 --> 01:05:18,512
不是那个，我们来用，这个，CGFloat。

1555
01:05:18,581 --> 01:05:20,548
而我们要移动的那一点我们会去

1556
01:05:20,617 --> 01:05:24,652
eyeCenter x减去eyeRadius。

1557
01:05:24,720 --> 01:05:26,087
所以，我们要移动到眼睛的中心

1558
01:05:26,156 --> 01:05:29,023
用眼睛备份。

1559
01:05:29,092 --> 01:05:31,092
我们会在eyeCenter.y。

1560
01:05:31,161 --> 01:05:32,994
所以，我们将在eyeCenter和

1561
01:05:33,063 --> 01:05:34,229
我们会画一条水平线

1562
01:05:34,298 --> 01:05:36,664
我们会移动到它的左侧。

1563
01:05:36,733 --> 01:05:41,303
然后我们要在右边添加一行。

1564
01:05:41,371 --> 01:05:47,008
那么另一个CGPoint就是这个了。

1565
01:05:47,076 --> 01:05:49,543
而这一个将会是eyeCenter.x

1566
01:05:49,612 --> 01:05:51,779
加上eyeRadius。

1567
01:05:51,848 --> 01:05:56,184
还在眼睛中心吗，好吗？

1568
01:05:56,253 --> 01:05:57,685
合理？

1569
01:05:57,754 --> 01:05:59,087
那里还有两个括号。

1570
01:06:00,256 --> 01:06:01,089
大家看到我在那里做了什么？

1571
01:06:01,158 --> 01:06:03,758
但我只是想确保你明白这一点

1572
01:06:03,827 --> 01:06:04,759
let path

1573
01:06:04,827 --> 01:06:08,129
只要这样，你就不必在这里说等于

1574
01:06:08,198 --> 01:06:12,867
仍然只能初始化一次，不会改变它。

1575
01:06:12,936 --> 01:06:14,135
因为它仍然是一个有效的let。

1576
01:06:15,671 --> 01:06:17,305
那我们来看看吧。

1577
01:06:25,015 --> 01:06:26,815
好的，闭上眼睛。

1578
01:06:26,883 --> 01:06:28,148
好，好吗

1579
01:06:28,217 --> 01:06:29,350
他们闭着眼睛

1580
01:06:29,419 --> 01:06:31,386
我们可以回到这里，将其设置为true。

1581
01:06:31,454 --> 01:06:34,522
再次，我们应该睁开眼睛。

1582
01:06:35,992 --> 01:06:37,158
问题？

1583
01:06:37,227 --> 01:06:39,894
所以，问题是人们做什么时候做一个习惯

1584
01:06:39,962 --> 01:06:42,931
当他们抽出自己的东西时，这样看？

1585
01:06:42,999 --> 01:06:45,900
换句话说，当他们不使用这种内置的东西

1586
01:06:45,969 --> 01:06:48,502
像按钮和这样的东西，这取决于

1587
01:06:48,571 --> 01:06:50,471
他们提供的内容。

1588
01:06:50,540 --> 01:06:53,107
但是很多时候，也许他们没有画弧

1589
01:06:53,175 --> 01:06:56,277
也许他们正在绘制图像和文字吗？

1590
01:06:56,346 --> 01:06:59,380
他们正在铺设他们想要的水平或

1591
01:06:59,449 --> 01:07:02,349
在某种方向上，他们可以做或可能正在做的

1592
01:07:02,418 --> 01:07:05,553
文字沿曲线，你可以用这个例子来做。

1593
01:07:05,622 --> 01:07:06,721
那就是这样的事情。

1594
01:07:06,790 --> 01:07:08,456
你可能看不到这样的原始图纸。

1595
01:07:08,525 --> 01:07:10,091
我们正在做原始绘图，因为它很简单

1596
01:07:10,160 --> 01:07:13,328
我想告诉你怎么做。

1597
01:07:13,396 --> 01:07:14,796
但是有些应用程序正在绘制

1598
01:07:14,865 --> 01:07:16,530
你可以把你的手指和绘画的应用程序。

1599
01:07:16,599 --> 01:07:18,799
他们会明确地做到这一点，

1600
01:07:18,868 --> 01:07:20,868
你们中有些人可能会做你最后的项目。

1601
01:07:20,937 --> 01:07:23,138
好的，无论如何，我们的眼睛。

1602
01:07:23,206 --> 01:07:25,873
所以，我们已经有了我们的眼睛，我们有了我们的脑袋。

1603
01:07:25,942 --> 01:07:26,607
我们的嘴怎么样？

1604
01:07:26,676 --> 01:07:28,409
我们必须得到嘴巴，所以让我们去做。

1605
01:07:28,478 --> 01:07:30,144
我们也会在那里做同样的事情。

1606
01:07:30,213 --> 01:07:34,882
我会有一个私人的func pathForMouth和

1607
01:07:34,951 --> 01:07:38,453
它将成为UIBezierPath。

1608
01:07:38,521 --> 01:07:40,154
那么，我该怎么做嘴

1609
01:07:40,223 --> 01:07:41,956
其实，我要开始画嘴

1610
01:07:42,025 --> 01:07:42,991
一个矩形，

1611
01:07:43,059 --> 01:07:45,426
只是为了告诉你我会把它放在屏幕上。

1612
01:07:45,494 --> 01:07:47,795
然后我们转一下，我们将使用贝塞尔曲线，

1613
01:07:47,864 --> 01:07:49,130
其实是要画嘴巴了。

1614
01:07:49,199 --> 01:07:51,832
那么我该怎么做呢？

1615
01:07:51,901 --> 01:07:54,468
首先，我要计算

1616
01:07:54,537 --> 01:07:57,638
嘴巴的宽度，高度

1617
01:07:57,707 --> 01:08:00,307
嘴巴和嘴巴的偏移 - 偏移向下

1618
01:08:00,376 --> 01:08:03,411
从中间的脸 - 使用更多的这些

1619
01:08:03,480 --> 01:08:05,980
ratios比率

1620
01:08:06,049 --> 01:08:07,214
所以，我只是计算嘴巴，宽度，

1621
01:08:07,283 --> 01:08:09,350
高度和偏移量。

1622
01:08:09,418 --> 01:08:11,619
现在，我要用它来创建矩形

1623
01:08:11,688 --> 01:08:13,354
我要放嘴巴

1624
01:08:13,423 --> 01:08:18,993
让我们这样做，让嘴巴等于

1625
01:08:19,061 --> 01:08:21,462
必须被嘴巴偏移。

1626
01:08:21,531 --> 01:08:23,831
它将会是宽度和高度，所以让我们这样做。

1627
01:08:23,899 --> 01:08:28,602
所以，CGRect我们将在这里使用这个构造函数，

1628
01:08:28,671 --> 01:08:32,573
CGFloat，我们将做脑袋的中心点x

1629
01:08:32,642 --> 01:08:36,511
减去嘴宽，除以2。

1630
01:08:36,580 --> 01:08:39,514
那就是因为我们显然想要嘴巴

1631
01:08:39,582 --> 01:08:42,450
集中在那里，然后为y，

1632
01:08:42,518 --> 01:08:46,354
我们将使用skullCenter.y加上mouthOffset。

1633
01:08:47,523 --> 01:08:48,389
而且再加上，

1634
01:08:48,458 --> 01:08:52,093
因为加表示在我们的绘图系统中下移。

1635
01:08:52,162 --> 01:08:57,932
而宽度只是mouthWidth和

1636
01:08:58,001 --> 01:09:00,368
高度是mouthHeight。

1637
01:09:00,437 --> 01:09:04,005
让我这样更容易阅读。

1638
01:09:12,649 --> 01:09:13,414
每个人都明白我是谁

1639
01:09:13,483 --> 01:09:14,948
在那里用mouse rect？

1640
01:09:15,017 --> 01:09:16,383
我们只是画这个rect。

1641
01:09:16,452 --> 01:09:19,720
所以，我可以说让路径相等UIBezierPath。

1642
01:09:19,789 --> 01:09:21,355
BezierPath知道如何做一个rect。

1643
01:09:21,424 --> 01:09:23,724
这是在这里。

1644
01:09:23,793 --> 01:09:29,531
rect是我们的嘴，让我们回到那个路径。

1645
01:09:30,700 --> 01:09:32,433
所以现在我们已经有了一条路径。

1646
01:09:32,501 --> 01:09:34,102
我们下来吧

1647
01:09:34,170 --> 01:09:38,139
命名 pathForMouth().stroke().

1648
01:09:38,208 --> 01:09:40,909
我们来看看这个是什么样的。

1649
01:09:48,851 --> 01:09:49,917
好的，很好

1650
01:09:49,986 --> 01:09:51,352
所以，我们有一个嘴巴。

1651
01:09:51,421 --> 01:09:53,721
金达看起来像一个机器人的脸。

1652
01:09:53,790 --> 01:09:57,024
我们希望它有一个很好的曲线，微笑或皱眉。

1653
01:09:57,092 --> 01:09:59,527
所以，我们必须开始思考一下我们会怎么样

1654
01:09:59,596 --> 01:10:03,297
代表这是微笑还是皱眉。

1655
01:10:03,366 --> 01:10:07,669
所以我要介绍另一个var，在顶部，

1656
01:10:07,737 --> 01:10:09,736
在这里，就像我拥有的​​眼睛一样开放。

1657
01:10:09,805 --> 01:10:15,109
我会有一个var，我会叫它mouthCurvature 和

1658
01:10:15,178 --> 01:10:17,445
使它成为double。

1659
01:10:17,513 --> 01:10:21,015
我会设置它，让我们说1.0和

1660
01:10:21,083 --> 01:10:25,553
我的语义将会是这样的

1661
01:10:25,622 --> 01:10:30,491
1.0是充满笑容，而负1.0是满脸皱眉。

1662
01:10:30,560 --> 01:10:33,093
这将是公有(public)的，这将是

1663
01:10:33,162 --> 01:10:35,963
有人在使用我的公共API时

1664
01:10:36,032 --> 01:10:39,299
FaceView告诉我这口应该多少微笑。

1665
01:10:39,368 --> 01:10:41,836
好的，这里的嘴曲率。

1666
01:10:41,904 --> 01:10:43,270
而且我已经这样定义了。

1667
01:10:43,339 --> 01:10:46,073
它是公开的，我记录了它。

1668
01:10:46,142 --> 01:10:48,242
所以人们可以把它设置为任何他们想要的。

1669
01:10:48,311 --> 01:10:50,043
所以我现在要用这个来做。

1670
01:10:50,112 --> 01:10:52,713
现在有一件事我把它定义为double，

1671
01:10:52,782 --> 01:10:55,983
你知道我现在并不是在做绘图

1672
01:10:56,052 --> 01:10:58,152
我只是在概念上谈论什么曲率。

1673
01:10:58,221 --> 01:11:01,722
所以，我需要转换这个有意义的CGFloat，

1674
01:11:01,791 --> 01:11:03,824
然后用它来画这个嘴巴。

1675
01:11:03,893 --> 01:11:05,459
那么我该怎么办呢？

1676
01:11:05,528 --> 01:11:08,562
我要这样做的方式是让我们得到这个

1677
01:11:08,631 --> 01:11:12,033
在这里，我会告诉你，在我们这里的矩形上。

1678
01:11:14,170 --> 01:11:15,803
我会使用所谓的贝塞尔曲线，

1679
01:11:15,871 --> 01:11:17,639
有多少人知道贝塞尔曲线是什么？

1680
01:11:18,908 --> 01:11:20,474
只有一个人！

1681
01:11:20,543 --> 01:11:23,777
我的天哪，好吧，贝塞尔曲线就是这样

1682
01:11:23,846 --> 01:11:27,114
两个端点之间的两个端点之间，但是

1683
01:11:27,183 --> 01:11:30,050
还有另外两个点称为控制点。

1684
01:11:30,119 --> 01:11:31,518
你可以想像，

1685
01:11:31,587 --> 01:11:34,188
认为这一行从一开始就开始，

1686
01:11:34,256 --> 01:11:36,957
开始前往其中一个控制点。

1687
01:11:37,026 --> 01:11:39,693
随着它接近，它开始向另一个方向前进。

1688
01:11:39,762 --> 01:11:41,395
随着它接近那个，它开始前进

1689
01:11:41,464 --> 01:11:42,596
结束了，好的。

1690
01:11:42,665 --> 01:11:45,032
所以，控制点种类拉上线

1691
01:11:45,101 --> 01:11:46,234
给它一些曲线。

1692
01:11:46,302 --> 01:11:48,335
你可以把这些控制点放在任何你想要的地方。

1693
01:11:48,404 --> 01:11:50,571
显然，我们会把我们这样的。

1694
01:11:50,639 --> 01:11:53,774
所以，我的开始就是在这个中间

1695
01:11:53,843 --> 01:11:56,110
我的目标是在这里。

1696
01:11:56,179 --> 01:11:58,378
所以我们将在这里画一条线。

1697
01:11:58,447 --> 01:12:00,047
我的两个控制点都要去

1698
01:12:00,115 --> 01:12:04,752
在他下巴的两旁，

1699
01:12:04,821 --> 01:12:06,087
线路将从这里开始，从这个开始。

1700
01:12:06,088 --> 01:12:07,354
所以

1701
01:12:07,424 --> 01:12:08,322
Whoop。开始去

1702
01:12:08,391 --> 01:12:09,090
另一个。

1703
01:12:09,158 --> 01:12:11,192
Whoop。来这里回来并做一点微笑。

1704
01:12:11,261 --> 01:12:14,228
如果我把我的控制点移动到

1705
01:12:14,297 --> 01:12:15,129
顶部，然后哎。

1706
01:12:15,198 --> 01:12:15,897
这将是一个皱眉

1707
01:12:17,700 --> 01:12:19,033
大家都明白了。

1708
01:12:19,101 --> 01:12:19,967
所以我需要四点。

1709
01:12:20,036 --> 01:12:21,702
开始，结束和两个控制点。

1710
01:12:21,770 --> 01:12:22,570
我们来做那些

1711
01:12:24,507 --> 01:12:25,973
开始很容易，

1712
01:12:26,042 --> 01:12:28,442
这只是左边缘的中间，好的。

1713
01:12:28,510 --> 01:12:31,912
所以我可以说开始是CGPoint。

1714
01:12:31,981 --> 01:12:36,116
再次，我们将会做这样的CGPoint。

1715
01:12:36,185 --> 01:12:41,655
这将是嘴巴，我们的小嘴巴，

1716
01:12:41,724 --> 01:12:46,193
MinX，这是左边缘，最小X和

1717
01:12:46,262 --> 01:12:51,499
mouthRect.midY，这是嘴巴的一半。

1718
01:12:51,567 --> 01:12:55,136
结束将是CGPoint。

1719
01:12:55,205 --> 01:12:56,871
这个float。

1720
01:12:56,940 --> 01:13:00,575
而这个将会是口头的

1721
01:13:00,643 --> 01:13:03,377
在另一边的mouthly.midY。

1722
01:13:03,446 --> 01:13:04,712
所以两端，开始和结束，

1723
01:13:04,780 --> 01:13:06,981
就在我嘴巴中间的两边。

1724
01:13:07,050 --> 01:13:09,483
所以现在我需要这两个控制点。

1725
01:13:09,552 --> 01:13:12,519
对于控制点我需要考虑多远

1726
01:13:12,588 --> 01:13:13,887
他们会成为。

1727
01:13:13,956 --> 01:13:16,190
这取决于嘴曲率。

1728
01:13:16,258 --> 01:13:19,059
我想要的更多的笑容，他们需要的越远。

1729
01:13:19,128 --> 01:13:21,929
我想要的越多，他们越需要。

1730
01:13:21,998 --> 01:13:25,666
所以我要创建另一个名为smileOffset的东西。

1731
01:13:25,735 --> 01:13:28,703
这将是一个CGFloat，因为它会成为

1732
01:13:28,771 --> 01:13:32,173
我在这里绘制的东西。

1733
01:13:32,241 --> 01:13:38,512
我会让它等于mouthCurvature，

1734
01:13:38,581 --> 01:13:44,718
这是一个double乘以mouth rect.height. 。

1735
01:13:44,787 --> 01:13:47,988
所以我会把这些控制点一直下移

1736
01:13:48,057 --> 01:13:51,959
如果我完全微笑，嘴巴的整个高度。

1737
01:13:52,027 --> 01:13:54,261
现在，这行代码有一些问题。

1738
01:13:54,330 --> 01:13:56,563
一个是，如果你在这里看这些事情，

1739
01:13:56,632 --> 01:13:59,300
这就是说你不能double乘以float。

1740
01:13:59,368 --> 01:14:01,536
这是一个float，这是一个double。

1741
01:14:01,604 --> 01:14:04,238
所以我必须把它转换成一个float

1742
01:14:04,306 --> 01:14:07,008
通过使用CGFloat的构造函数。

1743
01:14:07,076 --> 01:14:10,077
幸运的是，它有一个double的构造函数。

1744
01:14:10,146 --> 01:14:13,914
这里的另一件事是微笑偏移必须在之间，

1745
01:14:13,983 --> 01:14:15,249
你知道，1是sorry，

1746
01:14:15,318 --> 01:14:18,485
嘴角曲率必须在1到-1之间。

1747
01:14:18,554 --> 01:14:20,020
所以我要执行这个。

1748
01:14:20,089 --> 01:14:22,789
因为我不希望这个路径曲率是五，和

1749
01:14:22,858 --> 01:14:23,891
现在他正在微笑

1750
01:14:23,960 --> 01:14:26,160
大家知道，在地板上就是这样。

1751
01:14:26,229 --> 01:14:26,960
下巴在地板上。

1752
01:14:27,029 --> 01:14:27,795
我们不想要

1753
01:14:27,863 --> 01:14:29,664
所以我要用min和max来做这个。

1754
01:14:29,732 --> 01:14:33,067
mouth curvature大于-1

1755
01:14:33,136 --> 01:14:36,236
小于。

1756
01:14:36,305 --> 01:14:38,972
这将限制在-1和

1757
01:14:39,041 --> 01:14:39,774
1之间

1758
01:14:41,310 --> 01:14:42,143
大家都明白了吗?

1759
01:14:42,211 --> 01:14:46,047
我只是使用min和max来做那个。

1760
01:14:46,115 --> 01:14:48,549
并注意到它是自动的

1761
01:14:48,618 --> 01:14:50,584
使这些是double，这是好的。

1762
01:14:50,653 --> 01:14:53,087
所以min和max的结果是double，

1763
01:14:53,156 --> 01:14:54,789
正在转换为CGFloat。

1764
01:14:54,857 --> 01:14:55,656
工作正常

1765
01:14:56,859 --> 01:14:58,993
好的，所以现在我有那个微笑偏移了，

1766
01:14:59,061 --> 01:15:00,961
我可以说我的控制点有多远。

1767
01:15:01,030 --> 01:15:04,465
所以我要let cp1，这是控制点一，它会

1768
01:15:04,533 --> 01:15:08,402
要微笑偏移时间，嘴巴直立下来。

1769
01:15:08,470 --> 01:15:10,871
我要做两个控制点

1770
01:15:10,939 --> 01:15:14,242
从嘴的边缘的三分之一的方式。

1771
01:15:15,611 --> 01:15:16,977
有道理吗?

1772
01:15:17,046 --> 01:15:19,513
我们想要低头，我们想要点

1773
01:15:19,582 --> 01:15:21,982
是从每一边的三分之一。

1774
01:15:22,051 --> 01:15:23,583
所以cp1会在左边。

1775
01:15:23,652 --> 01:15:27,188
这将是一个CGPoint。

1776
01:15:27,256 --> 01:15:29,189
再来一次

1777
01:15:29,258 --> 01:15:35,196
所以这个将是start.x。

1778
01:15:35,265 --> 01:15:37,364
开始是我们在这里开始的地方。

1779
01:15:37,433 --> 01:15:40,434
加上mouthRect.width除以三

1780
01:15:40,503 --> 01:15:42,637
所以我要走三分之一的路。

1781
01:15:42,705 --> 01:15:47,441
然后y是一个start.y加上微笑偏移

1782
01:15:47,510 --> 01:15:50,211
如果口曲率为负，则可能为负。

1783
01:15:50,279 --> 01:15:52,246
微笑偏移可能为负，意味着上升。

1784
01:15:52,315 --> 01:15:53,881
所以，这将是一个皱眉。

1785
01:15:53,949 --> 01:15:56,116
或者它可以是积极的，然后它会下降。

1786
01:15:56,185 --> 01:15:59,786
那么cp2几乎完全一样，所以我会复制和

1787
01:15:59,855 --> 01:16:01,288
粘贴它，cp2。

1788
01:16:01,356 --> 01:16:04,858
就在这里，我们要走到尽头

1789
01:16:04,927 --> 01:16:08,295
通过mouthRect.width返回。

1790
01:16:08,364 --> 01:16:11,732
但是它仍然在同一水平，因为我们

1791
01:16:11,801 --> 01:16:15,002
想要下来，走过去，然后回来。

1792
01:16:15,070 --> 01:16:16,704
所以现在我们有这些控制点和

1793
01:16:16,772 --> 01:16:19,973
开始和结束，现在我们可以在路上画。

1794
01:16:20,042 --> 01:16:21,842
所以我们只是在这里走Bézier路径。

1795
01:16:21,910 --> 01:16:25,479
我们首先离开这里，以便我们可以看到它。

1796
01:16:25,548 --> 01:16:31,285
而且我要告诉我们去CGPoint的路径，

1797
01:16:31,353 --> 01:16:35,155
这是开始，实际上，

1798
01:16:35,224 --> 01:16:38,658
你甚至不需要这样做。

1799
01:16:38,727 --> 01:16:40,328
你只是说，开始。

1800
01:16:41,831 --> 01:16:45,098
然后，我们要画一条曲线，addCurve，

1801
01:16:45,167 --> 01:16:47,901
它增加了一个贝塞尔曲线。

1802
01:16:47,970 --> 01:16:48,736
我们要结束了。

1803
01:16:48,805 --> 01:16:54,341
控制点是cp1，另一个是cp2。

1804
01:16:54,409 --> 01:16:54,976
所以让我们来看看。

1805
01:17:04,320 --> 01:17:06,820
好的，优秀的，所以我们mouth curvature是1.0，

1806
01:17:06,889 --> 01:17:08,722
我们有一个很好的大笑容。

1807
01:17:08,791 --> 01:17:10,891
好的，我们真的不想再这样广场了，

1808
01:17:10,960 --> 01:17:13,127
矩形，所以我们会摆脱这个。

1809
01:17:13,196 --> 01:17:15,763
我们可以通过创建一个空的贝塞尔来做到这一点

1810
01:17:15,831 --> 01:17:16,931
曲线开始。

1811
01:17:16,999 --> 01:17:21,502
此外，我们希望路径的lineWidth为5.0。

1812
01:17:21,570 --> 01:17:23,704
一个很好，甚至数量。

1813
01:17:23,773 --> 01:17:25,606
让我们继续检查其他一些事情。

1814
01:17:25,675 --> 01:17:28,375
让我们看看嘴里是否减去0.5。

1815
01:17:28,444 --> 01:17:31,912
让我们看看这是否给我们一个轻微的皱眉。

1816
01:17:31,981 --> 01:17:33,447
应该给我们一个轻微的皱眉，对吧。

1817
01:17:40,156 --> 01:17:42,690
整齐，好的

1818
01:17:42,759 --> 01:17:45,392
好的，我要显示的最后一件事是什么

1819
01:17:45,461 --> 01:17:47,094
有一点有点痛苦

1820
01:17:47,162 --> 01:17:49,296
每次我想检查mouthCurvature，

1821
01:17:49,365 --> 01:17:50,698
我必须去运行应用程序

1822
01:17:50,766 --> 01:17:52,299
返回，改变它，运行。

1823
01:17:52,368 --> 01:17:53,934
或者每次眼睛睁开眼睛，闭上眼睛。

1824
01:17:54,002 --> 01:17:57,204
来来回回。

1825
01:17:57,273 --> 01:18:00,007
在Interface Builder中，好吗？

1826
01:18:00,076 --> 01:18:01,141
我可以看到一个按钮

1827
01:18:01,210 --> 01:18:02,976
当我改变它在Interface Builder中的东西。

1828
01:18:03,045 --> 01:18:06,013
如果我可以有一个检查员，它不会更冷

1829
01:18:06,081 --> 01:18:06,947
在Interface Builder中，

1830
01:18:07,016 --> 01:18:09,382
那会让我检查这些东西。

1831
01:18:09,451 --> 01:18:10,584
那么当然我们可以这么做

1832
01:18:10,653 --> 01:18:12,753
我们如何做到这一点

1833
01:18:12,821 --> 01:18:16,357
我们去这里，我们只是让这个IBDesignable，好的。

1834
01:18:17,793 --> 01:18:21,428
如果将IBDesignable放在顶端的UIView前面，

1835
01:18:21,497 --> 01:18:26,400
那么当你转到你的故事板，在顶部，你是

1836
01:18:26,469 --> 01:18:29,703
会在这里看到，编译代码，将其集成到

1837
01:18:29,772 --> 01:18:32,639
界面生成器，并显示给您。

1838
01:18:32,708 --> 01:18:35,809
好的，现在不幸的是我们没有这里的督察

1839
01:18:35,878 --> 01:18:37,778
这使我们能够检查这些东西。

1840
01:18:37,847 --> 01:18:39,346
但是我们也可以做到这一点。

1841
01:18:39,415 --> 01:18:40,514
回到FaceView这里。

1842
01:18:40,583 --> 01:18:41,715
我要说

1843
01:18:41,784 --> 01:18:45,352
例子使规模IBInspectable。

1844
01:18:46,922 --> 01:18:51,525
让我们把眼睛打开IBInspectable。

1845
01:18:51,593 --> 01:18:56,030
让我们来看看

1846
01:18:56,098 --> 01:18:57,831
让我们在这里添加一些其他的东西。

1847
01:18:57,900 --> 01:19:00,601
IBinspectable lineWidth 。

1848
01:19:00,669 --> 01:19:03,703
所以要做到这一点，我们不可能有5.0这里，

1849
01:19:03,772 --> 01:19:05,572
我们必须添加一个var。

1850
01:19:05,641 --> 01:19:10,677
所以我们要添加一个IBInspectable var。

1851
01:19:10,746 --> 01:19:13,513
这将是线宽，这是一个CGFloat。

1852
01:19:13,582 --> 01:19:17,784
我们将在5.0开始，但我们可以改变它。

1853
01:19:17,853 --> 01:19:20,420
所以现在我们可以去那里有5.0的地方。

1854
01:19:20,489 --> 01:19:23,557
我们只是改变它来使用这个var。

1855
01:19:25,594 --> 01:19:27,728
我们也可以做颜色。

1856
01:19:27,796 --> 01:19:32,065
IBInspectable var的颜色，它是一个UI颜色。

1857
01:19:32,134 --> 01:19:36,003
好的，我们现在就开始像蓝色那样。

1858
01:19:36,071 --> 01:19:37,771
所以我们看到UIColor.blue，

1859
01:19:37,840 --> 01:19:39,539
我们将使用这个var。

1860
01:19:39,608 --> 01:19:40,741
好的，我们给你一个蓝色的颜色。

1861
01:19:40,809 --> 01:19:44,911
我只是要说颜色，来设定颜色。

1862
01:19:44,980 --> 01:19:47,847
好的，所以基本上它是把所有的东西在我的应用程序和

1863
01:19:47,916 --> 01:19:50,383
只是使它们不仅可配置，

1864
01:19:50,452 --> 01:19:53,653
作为公共变量，也可以检查。

1865
01:19:53,722 --> 01:19:56,089
所以让我们回到我们的故事板，看看是否有效。

1866
01:19:56,158 --> 01:19:58,191
果然，你马上看到顶部，

1867
01:19:58,260 --> 01:20:02,696
脸部视图，刻度，眼睛是否开放，线宽，

1868
01:20:02,765 --> 01:20:05,132
颜色，嘴角曲率现在可以检查。

1869
01:20:05,201 --> 01:20:07,901
所以让我们闭上眼睛。

1870
01:20:07,970 --> 01:20:12,606
让我们的嘴曲率为0.5。

1871
01:20:12,675 --> 01:20:16,176
让我们让颜色变成橙色。

1872
01:20:16,244 --> 01:20:18,712
我们让线宽为2。

1873
01:20:18,781 --> 01:20:22,115
我们让比例为0.5。

1874
01:20:22,184 --> 01:20:26,252
再次使规模变成0.9，无论如何。

1875
01:20:26,321 --> 01:20:29,422
现在，另一个有趣的事情就像是你

1876
01:20:29,491 --> 01:20:31,458
正在这里检查一个UIButton。

1877
01:20:31,527 --> 01:20:34,194
当你运行它将要使用

1878
01:20:34,263 --> 01:20:36,664
这些设置作为初始设置。

1879
01:20:37,667 --> 01:20:39,299
你真的在编辑这个，

1880
01:20:39,368 --> 01:20:41,167
就像你会编辑任何其他东西一样，

1881
01:20:41,236 --> 01:20:43,771
任何其他自定义视图，看到它出现这样。

1882
01:20:45,941 --> 01:20:46,673
了解了吗？

1883
01:20:46,742 --> 01:20:49,242
现在有一件你必须做的事情

1884
01:20:49,311 --> 01:20:54,414
一个IBInspectable是你必须明确地键入你不能

1885
01:20:54,483 --> 01:20:55,816
让Swift推断它。

1886
01:20:55,884 --> 01:20:59,386
因为Swift可以推断，Interface Builder不能。

1887
01:21:00,956 --> 01:21:03,023
它没有推理引擎。

1888
01:21:03,091 --> 01:21:05,925
所以总是确保你把实际的类型

1889
01:21:05,994 --> 01:21:10,029
在所有IBInspectables。

1890
01:21:10,098 --> 01:21:11,965
好的，就是这样！

1891
01:21:12,034 --> 01:21:13,367
我们要做的是我们要在我们的MVC中添加一个模型。

1892
01:21:13,368 --> 01:21:14,701
下次，

1893
01:21:14,770 --> 01:21:16,770
我们要开始把手势放在这里。

1894
01:21:16,839 --> 01:21:20,707
然后我们将开始谈论多个MVC。

1895
01:21:20,776 --> 01:21:31,384
>>更多，请访问我们的stanford.edu。


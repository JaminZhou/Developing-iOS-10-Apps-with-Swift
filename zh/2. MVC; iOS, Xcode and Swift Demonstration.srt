1
00:00:00,401 --> 00:00:04,869
[MUSIC]

2
00:00:04,938 --> 00:00:07,906
斯坦福大学。 >>所以，

3
00:00:07,974 --> 00:00:12,577
欢迎参加斯坦福 CS193P 课程

4
00:00:12,646 --> 00:00:17,115
2017 年冬季学期。所以今天我要给

5
00:00:17,184 --> 00:00:20,918
另外一个简单的幻灯片MVC，这个

6
00:00:20,987 --> 00:00:24,355
我们将用来构建我们所有的设计方法

7
00:00:24,424 --> 00:00:27,825
iOS应用程式然后我将继续演示我们

8
00:00:27,894 --> 00:00:31,196
周一开始我们要实际将MVC并入

9
00:00:31,265 --> 00:00:33,931
计算器。它也将成为一个机会

10
00:00:34,000 --> 00:00:38,870
我向您展示了许多其他酷炫的Swift，语言特性。

11
00:00:38,939 --> 00:00:42,373
那么什么是MVC？模型视图控制器，那是什么？

12
00:00:42,442 --> 00:00:46,477
基本上，它开始是我们分裂的一种方式

13
00:00:46,546 --> 00:00:51,182
我们的应用程序中的所有代码分为三个不同的阵营。

14
00:00:51,251 --> 00:00:54,453
这三个不同的阵营是模范阵营，model

15
00:00:54,521 --> 00:00:59,057
是你的应用程序的“什么”，所以你的应用程序是什么。所以，

16
00:00:59,126 --> 00:01:02,261
在计算器的情况下，我是计算器的大脑，

17
00:01:02,329 --> 00:01:04,496
我是计算的东西，这是模型(model)，

18
00:01:04,564 --> 00:01:08,500
而这是一个UI独立的部分。我的应用程序是什么，

19
00:01:08,569 --> 00:01:10,569
不是如何显示或类似的东西。

20
00:01:10,637 --> 00:01:13,838
显示的是控制器(controller)的工作。所以

21
00:01:13,907 --> 00:01:16,508
控制器(controller)决定如何独立于此UI

22
00:01:16,577 --> 00:01:18,610
模型，并显示在你的屏幕上

23
00:01:18,679 --> 00:01:21,580
与用户交互。这就是控制器的工作。

24
00:01:21,648 --> 00:01:25,683
这是它的显示方式。模型是什么。

25
00:01:25,752 --> 00:01:27,352
控制器是如何显示的。

26
00:01:27,421 --> 00:01:31,723
视图是控制器的仆从，好吗？

27
00:01:31,792 --> 00:01:34,726
控制器用来完成工作的事情，

28
00:01:34,795 --> 00:01:39,231
几乎总是这些东西在视图中是通用的，

29
00:01:39,299 --> 00:01:42,968
像UIButton或UIScrollView这样的东西好吗？

30
00:01:43,037 --> 00:01:45,303
来自苹果或其他地方的事情，

31
00:01:45,372 --> 00:01:48,306
甚至你写的东西，你一般都试图写它们

32
00:01:48,375 --> 00:01:52,010
是相当通用的可重用UI的东西。控制器是

33
00:01:52,079 --> 00:01:56,214
尝试使用这些通用的东西来构建一个特定的UI。

34
00:01:56,283 --> 00:01:59,551
现在，MVC的关键在于管理通信

35
00:01:59,620 --> 00:02:02,220
在这些阵营之间，因为我们不管理

36
00:02:02,289 --> 00:02:03,488
那个沟通，

37
00:02:03,557 --> 00:02:06,224
我们也可以把它们全部放在大阵营中。

38
00:02:06,293 --> 00:02:08,726
而且他们都可以互相交谈，但是他们想要。所以

39
00:02:08,795 --> 00:02:09,627
如果我们要三个阵营，

40
00:02:09,696 --> 00:02:11,230
我们必须考虑他们如何沟通。

41
00:02:11,298 --> 00:02:14,799
所以我在这里使用这种路标形象，好的，

42
00:02:14,868 --> 00:02:17,669
道路，就像一条路中间的路线

43
00:02:17,737 --> 00:02:21,406
在他们之间帮助你可视化什么是允许的

44
00:02:21,475 --> 00:02:22,740
在沟通方面。

45
00:02:22,809 --> 00:02:25,677
所以，让我们来谈谈这里的每个边界

46
00:02:25,745 --> 00:02:29,280
这些营地。我们从控制器开始谈话

47
00:02:29,349 --> 00:02:31,783
模型，好的。控制器可以通话

48
00:02:31,852 --> 00:02:34,920
该模型？绝对可以对模型说什么

49
00:02:34,989 --> 00:02:38,590
该模式公开允许自己说。所以，

50
00:02:38,658 --> 00:02:41,893
这是一个绿色的箭头。路上是一条虚线的白线。

51
00:02:41,962 --> 00:02:43,428
你可以去那里所有你想要的。

52
00:02:43,497 --> 00:02:44,930
你可以看到为什么会这样。

53
00:02:44,998 --> 00:02:48,300
控制器的工作是将该模型放到屏幕上。

54
00:02:48,369 --> 00:02:50,702
它必须能够一下子与它说话。所以没有

55
00:02:50,770 --> 00:02:53,238
控制器对模型的限制。和

56
00:02:53,307 --> 00:02:56,741
同样，控制器也没有限制

57
00:02:56,810 --> 00:02:59,912
说话的观点，因为视图是控制者的

58
00:02:59,980 --> 00:03:02,480
仆从。对，所以你必须能够告诉你的仆从

59
00:03:02,549 --> 00:03:04,917
怎么做没有限制现在，

60
00:03:04,985 --> 00:03:07,285
这些控制器之间的连接

61
00:03:07,354 --> 00:03:10,255
一个观点，我们称之为网点。你已经看到一个

62
00:03:10,324 --> 00:03:13,058
计算器，我们创建了一个outlet，如果你还记得，

63
00:03:13,127 --> 00:03:15,426
它被称为display，对吧？

64
00:03:15,495 --> 00:03:18,162
它是我们控制器中的一个实例变量。请记住

65
00:03:18,231 --> 00:03:20,265
我们星期一看到的ViewController类，

66
00:03:20,333 --> 00:03:24,069
这是我们星期一建立的MVC的控制器。

67
00:03:24,138 --> 00:03:26,238
而display  var，是一个outlet，

68
00:03:26,306 --> 00:03:30,508
在我们看来，它刚刚连接到UILabel。的UILabel

69
00:03:30,577 --> 00:03:34,045
是控制器在视图中的其中一个。好的，

70
00:03:34,114 --> 00:03:38,450
所以你已经看到了这一点。模型和视图

71
00:03:38,518 --> 00:03:43,355
永远不会说话。双橙线在那里

72
00:03:43,424 --> 00:03:46,892
没有交叉在这里。这使得完美

73
00:03:46,961 --> 00:03:50,128
感觉因为模型完全是UI独立的，

74
00:03:50,197 --> 00:03:53,064
而视图完全是UI。这就是所有的观点。

75
00:03:53,133 --> 00:03:54,299
所以他们没什么可说的，

76
00:03:54,367 --> 00:03:58,170
这两个人，好吗？他们完全是，你知道，

77
00:03:58,238 --> 00:04:00,372
不同的营地，没有任何意义的谈话。

78
00:04:00,440 --> 00:04:03,574
由控制器来管理通信

79
00:04:03,643 --> 00:04:08,113
这两个。所以，你们之间永远不要沟通

80
00:04:08,181 --> 00:04:13,018
两个阵营，好吗？这个观点怎么回事

81
00:04:13,087 --> 00:04:16,288
它的控制器？可以看出，那些仆从可以说话

82
00:04:16,357 --> 00:04:18,890
到它的控制器？现在这是你会清楚的

83
00:04:18,959 --> 00:04:21,993
想要因为仆从要与控制器合作，但是

84
00:04:22,062 --> 00:04:23,895
这里有一点问题。

85
00:04:23,964 --> 00:04:26,498
因为这些东西在视图中是通用的。

86
00:04:26,566 --> 00:04:30,035
他们是像UIButton这样的东西。 UIButton发货

87
00:04:30,104 --> 00:04:33,338
来自苹果去年。它对计算器一无所知，

88
00:04:33,407 --> 00:04:37,843
那UIButton怎么能和计算器交谈？那我们可以

89
00:04:37,911 --> 00:04:41,513
做到这一点我们只需要以盲目的方式来实现

90
00:04:41,582 --> 00:04:43,815
我们不知道我们正在谈论的事情的阶级。

91
00:04:43,884 --> 00:04:47,385
结构化的方式，让我们可以清楚地了解什么

92
00:04:47,454 --> 00:04:50,189
沟通正在发生。所以你已经看到一个盲人

93
00:04:50,257 --> 00:04:51,957
视图之间的结构化通信

94
00:04:52,025 --> 00:04:54,926
控制器。这是目标动作，好的。所以

95
00:04:54,995 --> 00:04:57,529
控制器可以将目标放在自身上

96
00:04:57,598 --> 00:05:00,665
通过基本创建一种与IBAction作用的方法，

97
00:05:00,734 --> 00:05:05,303
记得从星期一起然后你只是控制拖动

98
00:05:05,372 --> 00:05:08,006
这让UIButton的观点说，

99
00:05:08,074 --> 00:05:11,509
基本上连接到该目标。现在每一个

100
00:05:11,578 --> 00:05:14,279
UIButton想要和控制器交谈的时间，

101
00:05:14,348 --> 00:05:17,382
它只是发送目标动作。就这样

102
00:05:17,451 --> 00:05:21,920
超级简单的盲目结构化通信从视野来看

103
00:05:21,989 --> 00:05:26,425
回到控制器。但是，这有点太简单了

104
00:05:26,493 --> 00:05:30,128
这些仆从可能想做的所有沟通。

105
00:05:30,197 --> 00:05:32,697
例如，有时候，视图中的东西想要

106
00:05:32,766 --> 00:05:34,799
与控制器同步。

107
00:05:34,868 --> 00:05:37,903
或者它想知道控制器的意图

108
00:05:37,972 --> 00:05:41,239
正在使用。我们来看一下滚动视图的例子(scroll view)

109
00:05:41,308 --> 00:05:43,108
好的，滚动视图(scroll view)，

110
00:05:43,177 --> 00:05:44,709
当它滚动时，

111
00:05:44,778 --> 00:05:46,444
可能会问控制器，

112
00:05:46,513 --> 00:05:48,914
我应该允许用户在这里滚动吗？要么

113
00:05:48,982 --> 00:05:51,750
他们可能只是想告诉控制器，嘿，用户

114
00:05:51,819 --> 00:05:55,486
向下滚动这些通知和

115
00:05:55,555 --> 00:05:58,957
关于它是否可以做的事情的问题，他们是最终的

116
00:05:59,026 --> 00:06:01,760
在我从这里开始的这些话中

117
00:06:01,828 --> 00:06:03,996
“会”，“应该”，“做”。喜欢，

118
00:06:04,064 --> 00:06:07,399
我应该滚动到这里吗？我会在这里滚动，

119
00:06:07,468 --> 00:06:08,800
如果滚动视图即将滚动。和

120
00:06:08,869 --> 00:06:11,637
然后在滚动视图完成后，我已经滚动到这里。

121
00:06:11,705 --> 00:06:14,373
那么那种沟通。

122
00:06:14,441 --> 00:06:16,641
而我们的沟通工作方式，

123
00:06:16,710 --> 00:06:19,377
我们不能只是做这个简单的一个方法来控制拖动

124
00:06:19,446 --> 00:06:22,380
而是使用所谓的代理(delegate)。我会说

125
00:06:22,449 --> 00:06:25,984
更多关于未来讲座的代理(delegate)。但基本上

126
00:06:26,053 --> 00:06:29,788
一个代理(delegate)的想法是，这是一个var的视图，所以

127
00:06:29,857 --> 00:06:34,192
像一个var滚动视图。这是一种特殊的类型;那

128
00:06:34,261 --> 00:06:37,295
类型称为协议(protocol)。我知道你很多，

129
00:06:37,364 --> 00:06:38,664
即使你有面向对象的经验，

130
00:06:38,732 --> 00:06:40,699
也许你没有协议(protocol)的经验。但

131
00:06:40,768 --> 00:06:42,000
基本上，协议(protocol)是一种方式

132
00:06:42,069 --> 00:06:45,804
说这个类型，这个我在说的话，

133
00:06:45,873 --> 00:06:49,908
它响应一定的方法。我不知道是什么

134
00:06:49,977 --> 00:06:52,344
分类是，我不知道是否是一个视图控制器，

135
00:06:52,413 --> 00:06:53,678
我不知道是什么，但是

136
00:06:53,747 --> 00:06:56,215
我知道它会像意志一样对这些方法做出回应

137
00:06:56,283 --> 00:06:58,783
滚动，滚动，应该滚动，

138
00:06:58,852 --> 00:07:01,420
这些方法。这就是我所了解的。所以

139
00:07:01,488 --> 00:07:05,423
控制器，它注册听这些方法，

140
00:07:05,492 --> 00:07:08,994
然后它将自己设置为视图中的委托(delegate)。

141
00:07:09,062 --> 00:07:10,862
好的，我们也会看到这个动作

142
00:07:10,931 --> 00:07:13,097
现在不用担心太多了，但我们可以这样做

143
00:07:13,166 --> 00:07:15,534
在他们同意的情况下有结构化的沟通。

144
00:07:15,602 --> 00:07:18,136
视图，这个通用对象是同意的

145
00:07:18,205 --> 00:07:20,605
向控制器发送某些消息，

146
00:07:20,674 --> 00:07:23,208
不是控制器可以是任何类型和

147
00:07:23,277 --> 00:07:26,144
仍然是为了控制它的观点

148
00:07:26,213 --> 00:07:30,616
现在有一种特殊的交流方式

149
00:07:30,684 --> 00:07:34,686
和由于视图不能拥有而产生的控制器

150
00:07:34,755 --> 00:07:38,356
它显示的数据。这是什么意思？这意味着你

151
00:07:38,425 --> 00:07:41,460
不想在你的视图类里面，并记住，查看

152
00:07:41,528 --> 00:07:43,928
类似滚动视图，按钮等等

153
00:07:43,997 --> 00:07:46,531
你不想在那里有数据

154
00:07:46,600 --> 00:07:49,701
您显示的数据。我给你一个例子。

155
00:07:49,770 --> 00:07:51,870
我们来说说你的整个iPod音乐库，

156
00:07:51,939 --> 00:07:54,640
假设你有数十万首歌曲在那里。

157
00:07:54,708 --> 00:07:58,410
好的，所以我想在屏幕上列出它们。所以

158
00:07:58,479 --> 00:08:02,314
我将在我的视图中使用一个通用项目，称为表视图(table view)。

159
00:08:02,383 --> 00:08:04,783
表视图(table view)只是显示了一大串长的东西

160
00:08:04,852 --> 00:08:08,320
它可以列出一百万项长，好吗？所以

161
00:08:08,388 --> 00:08:11,422
如果我真的不得不把我的整个iPod库和

162
00:08:11,491 --> 00:08:13,592
把它放在一个var的值中

163
00:08:13,660 --> 00:08:17,696
表视图(table view)显示它，这将是可笑的。

164
00:08:17,764 --> 00:08:20,131
不仅仅是从性能的角度来看，而是

165
00:08:20,200 --> 00:08:22,000
现在我有两个iPad的副本，或者

166
00:08:22,069 --> 00:08:25,003
我的iPod音乐库，一个在这个表视图里面，和

167
00:08:25,072 --> 00:08:27,973
一个在我的手机的某个数据库。那很糟糕，在哪里

168
00:08:28,041 --> 00:08:30,742
他们可能会失去同步，管理同步，

169
00:08:30,811 --> 00:08:32,644
如果我有多个应用程序呢？啊，

170
00:08:32,713 --> 00:08:36,481
这是一个混乱，所以视图从来不想拥有这些数据，好吗？

171
00:08:36,550 --> 00:08:38,483
那么怎么会得到数据呢？

172
00:08:38,551 --> 00:08:41,486
我有10万首歌曲，我需要在这张表中显示，

173
00:08:41,555 --> 00:08:45,123
怎么会这样做？那么它会使用另一个

174
00:08:45,191 --> 00:08:49,227
这些基于协议的vars，好的，称为数据源(data source)。

175
00:08:49,296 --> 00:08:51,496
数据源有不同的方法，

176
00:08:51,565 --> 00:08:54,666
这不是应该的，应该是，它是多少项目

177
00:08:54,735 --> 00:08:59,904
这条数据？给我这个位置的数据。和

178
00:08:59,973 --> 00:09:03,508
那又是一个var控制器

179
00:09:03,576 --> 00:09:06,444
设置在表视图中，让我们说，它指向它

180
00:09:06,513 --> 00:09:08,380
所以现在每次表视图都想要数据时，

181
00:09:08,448 --> 00:09:11,182
它询问控制器。而控制器几乎

182
00:09:11,251 --> 00:09:14,886
总是转过身来问问这个模型，给我那个数据。

183
00:09:14,955 --> 00:09:17,789
现在这也允许像桌面视图那样显示

184
00:09:17,857 --> 00:09:21,760
十万件。它一次只能在屏幕上显示10个，

185
00:09:21,828 --> 00:09:25,163
所以它只要求10并显示它们。如果你滚动

186
00:09:25,232 --> 00:09:28,167
到别的地方，会要求10点。

187
00:09:28,235 --> 00:09:31,135
它只是保持它的显示。所以

188
00:09:31,204 --> 00:09:34,105
它传输的数据少得多，只有你的数据

189
00:09:34,174 --> 00:09:37,642
实际观看，10万首歌曲中有10首。所以是这样的

190
00:09:37,711 --> 00:09:40,779
在内存使用方面，效率更高

191
00:09:40,848 --> 00:09:42,848
一切。现在你可能有点害怕，

192
00:09:42,917 --> 00:09:44,749
喜欢，每一次我会滚动，

193
00:09:44,818 --> 00:09:45,583
我会要求的

194
00:09:45,652 --> 00:09:48,152
这个数据。但请记住，模型

195
00:09:48,221 --> 00:09:51,290
iPod的音乐库可能是一个SQL数据库

196
00:09:51,358 --> 00:09:54,626
什么东西，可以提供超快的数据。

197
00:09:54,695 --> 00:09:58,564
这就是作为一个模型的工作，作为数据的来源，

198
00:09:58,632 --> 00:10:02,167
好的？所以这通常不是你的性能瓶颈。

199
00:10:02,236 --> 00:10:03,936
我们稍后会谈谈性能

200
00:10:04,004 --> 00:10:06,104
顺便。通常性能瓶颈是

201
00:10:06,173 --> 00:10:08,707
画在屏幕上。事情就像获取数据

202
00:10:08,776 --> 00:10:12,243
数据库，忘记了。在屏幕上绘制要慢得多

203
00:10:12,312 --> 00:10:14,880
然后过网络甚至更慢。

204
00:10:14,949 --> 00:10:17,082
所以这些事情往往主宰了性能

205
00:10:17,150 --> 00:10:20,418
你的应用程序好的，所以不用担心。所以无论如何，所以

206
00:10:20,487 --> 00:10:23,021
这是几个例子，我们如何结构化

207
00:10:23,090 --> 00:10:25,056
从通用对象传回给我

208
00:10:25,125 --> 00:10:30,696
控制器。现在呢对不起，一个声明就是这样

209
00:10:30,764 --> 00:10:33,198
把你所有的三个阵营都放在你的脑海里，

210
00:10:33,266 --> 00:10:37,035
是控制器解释和格式化

211
00:10:37,103 --> 00:10:40,939
其模式为其意见。他们的观点是通用的，他们

212
00:10:41,007 --> 00:10:43,175
真的不知道如何处理任何特定的模型。

213
00:10:43,243 --> 00:10:46,011
控制者知道两者，这是其工作的一部分。

214
00:10:46,079 --> 00:10:47,846
所以很多次我会说，

215
00:10:47,915 --> 00:10:50,882
控制器的工作就是做到这一点，你会像，

216
00:10:50,951 --> 00:10:53,886
是的，我记得他说的。好的，现在是什么

217
00:10:53,954 --> 00:10:56,422
关于与控制器通信的模型？

218
00:10:57,991 --> 00:11:02,060
现在这样也不会发生，因为模型是

219
00:11:02,129 --> 00:11:04,796
UI独立它什么都不知道

220
00:11:04,865 --> 00:11:07,298
UI，所以没有办法可以和UI的人聊天

221
00:11:07,367 --> 00:11:11,803
控制器好吗？那么发生什么，虽然，如果模型

222
00:11:11,871 --> 00:11:15,741
变化，数据变化？那个控制器需要知道，

223
00:11:15,809 --> 00:11:18,243
因为在这种情况下想要更新屏幕。

224
00:11:18,311 --> 00:11:20,813
那么我们这样做的方式就是一个模型

225
00:11:20,881 --> 00:11:24,049
有点像电台，好吗？该模型

226
00:11:24,117 --> 00:11:26,985
基本上都有一个广播电台，并播放了

227
00:11:27,054 --> 00:11:31,289
广播电台，嘿，我改变了，或者关于我这个改变了。和

228
00:11:31,358 --> 00:11:34,926
则控制器调谐到该无线电台。和

229
00:11:34,995 --> 00:11:38,997
当它听到一个广播，它询问模型有什么变化

230
00:11:39,066 --> 00:11:42,400
那绿色的箭头在那里，你看到了吗？可以，然后呢

231
00:11:42,469 --> 00:11:45,670
这就是我们要使用的模式，那就是机制

232
00:11:45,739 --> 00:11:49,141
我们将用来获取更改模型的内容

233
00:11:49,210 --> 00:11:52,610
通知我们的控制器。有人问，可以

234
00:11:52,679 --> 00:11:55,347
观看电台？答案是，

235
00:11:55,415 --> 00:11:58,216
是的，可能可以。它不一定会违反

236
00:11:58,285 --> 00:12:01,052
MVC ,.但问题是通用视图不会知道

237
00:12:01,121 --> 00:12:03,888
无论如何，哪个电台都要调整，所以真的是这样

238
00:12:03,957 --> 00:12:07,726
不是一个问题。好的，所以一个像这样的MVC，

239
00:12:07,795 --> 00:12:11,897
真的不是，像你的整个应用程序不是一个大的MVC。

240
00:12:11,965 --> 00:12:15,166
每个MVC都可以控制iPhone上的一个屏幕

241
00:12:15,235 --> 00:12:18,103
甚至可能是在iPhone上的屏幕的子部分

242
00:12:18,172 --> 00:12:19,338
一个iPad也许有两个或

243
00:12:19,406 --> 00:12:23,442
三个MVC控制屏幕上发生了什么，所以

244
00:12:23,510 --> 00:12:25,977
我们如何建立一个大的应用程序？一个应用程序，你知道吗

245
00:12:26,046 --> 00:12:29,214
它正在构建一个Instagram应用程序。我必须有MVC

246
00:12:29,283 --> 00:12:32,117
发布，我必须有MVC进行图像编辑

247
00:12:32,186 --> 00:12:35,653
我可以做我的棕褐色调。我必须有一个MVC

248
00:12:35,722 --> 00:12:37,856
滚动浏览最新的帖子。

249
00:12:37,925 --> 00:12:40,793
我的意思是，我需要各种各样的MVC。这些东西怎么样，怎么样

250
00:12:40,861 --> 00:12:43,696
我们把它们结合在一起吗？好吧，看起来像这样。

251
00:12:45,466 --> 00:12:50,235
MVC，当其他MVC指向他们时，它始终如一

252
00:12:50,304 --> 00:12:54,573
另一个MVC的观点的一部分。所以看看这三个

253
00:12:56,076 --> 00:12:58,242
在右下角的MVC。

254
00:12:58,311 --> 00:13:01,579
你看到这三个MVC？看到这个MVC，这个紫色

255
00:13:01,648 --> 00:13:05,049
一？看看它们如何指向他们，就好像它们是一部分

256
00:13:05,118 --> 00:13:09,655
它的看法。你看到了吗没有其他箭头指向

257
00:13:09,723 --> 00:13:12,725
从一个控制器到另一个MVC，除了

258
00:13:12,793 --> 00:13:16,394
通过MVC的这个视图。

259
00:13:16,463 --> 00:13:21,599
让我帮你做更具体的为什么。

260
00:13:21,668 --> 00:13:24,136
假设我有一个应用程序，它是一个日历应用程序，它是

261
00:13:24,205 --> 00:13:27,973
告诉我一年，好的，我一年的价值

262
00:13:28,042 --> 00:13:31,743
日历条目。那么，在一个小屏幕上，几乎不会

263
00:13:31,811 --> 00:13:34,212
能够告诉我12个月，更不用说日子了

264
00:13:34,281 --> 00:13:36,715
事情对吗？所以有几个月的这张照片。

265
00:13:36,783 --> 00:13:40,352
所以这是一年MVC，让我们说，在我的日历应用程序。所以

266
00:13:40,420 --> 00:13:42,821
我点击了几个月之一，我想要一些更多的细节。

267
00:13:42,890 --> 00:13:45,623
而那一年，MVC走出了路

268
00:13:45,692 --> 00:13:49,761
提出一个MVC，显示一个月的所有日子，好吗？

269
00:13:49,830 --> 00:13:53,031
那个月MVC是一个完全独立的MVC，

270
00:13:53,100 --> 00:13:55,833
你看这个MVC的一些看法呢？

271
00:13:55,902 --> 00:13:58,136
因为年MVC显示了几个月。

272
00:13:58,205 --> 00:14:00,438
你想看看它，它试图放大它，

273
00:14:00,507 --> 00:14:03,808
它与另一个MVC。同样的事情，在这个月，

274
00:14:03,877 --> 00:14:06,745
如果我点击一天，那么MVC会离开这个月

275
00:14:06,814 --> 00:14:11,983
方式。放一天MVC，显示我所有的约会，

276
00:14:12,052 --> 00:14:15,721
一天中，MVC将是MVC的一部分

277
00:14:15,790 --> 00:14:19,157
月MVC，好吧，有意义吗？所以这就是为什么，

278
00:14:19,226 --> 00:14:21,860
这是MVC之间唯一的关系

279
00:14:21,929 --> 00:14:24,662
这个视图边界。现在可以有其他的沟通，

280
00:14:24,731 --> 00:14:26,798
然而。在这里看

281
00:14:26,867 --> 00:14:29,634
这个MVC，紫色的一个在中间的顶部，

282
00:14:29,703 --> 00:14:32,905
它与一些与某些模型相同的模型进行通信

283
00:14:32,973 --> 00:14:36,542
其他MVC。所以MVC可以共享相同的模型。那是

284
00:14:36,610 --> 00:14:38,944
很好模型完全与UI无关。

285
00:14:39,012 --> 00:14:42,014
他们不在乎多少MVC正在看他们，好吗？

286
00:14:42,082 --> 00:14:45,050
他们甚至不知道控制器。

287
00:14:45,119 --> 00:14:46,985
对，他们完全独立于此。

288
00:14:47,054 --> 00:14:49,421
还要注意这两个模型在底部，

289
00:14:49,489 --> 00:14:52,890
他们正在说话。也没关系，因为

290
00:14:52,959 --> 00:14:56,794
可以以任何方式定义模型。它独立于UI，

291
00:14:56,863 --> 00:14:58,196
它可以跟其他模型交谈，无论如何。

292
00:14:58,264 --> 00:15:00,966
现在当然还是要广播，如果

293
00:15:01,034 --> 00:15:04,203
也许这个模型会改变它的一些东西。但

294
00:15:04,271 --> 00:15:06,004
它仍然可以直接与模型交谈，所以

295
00:15:06,072 --> 00:15:08,941
这是可能发生的其他通信。但

296
00:15:09,009 --> 00:15:10,675
没有其他的沟通可以发生。

297
00:15:10,744 --> 00:15:13,545
我们不希望我们的应用程序看起来像这样。好的，

298
00:15:13,613 --> 00:15:17,048
我们有这些MVC，看看这个视图在这里？

299
00:15:17,117 --> 00:15:19,984
它正在与另一个控制器交谈。这个控制器是

300
00:15:20,053 --> 00:15:22,554
直接与另一个人交谈，而不是出于观点，而是

301
00:15:22,623 --> 00:15:25,691
就在这边。你不想要这个混乱如果你

302
00:15:25,759 --> 00:15:28,594
做这个混乱，你真的，你甚至没有做一个MVC。

303
00:15:28,662 --> 00:15:29,694
库兹大家在同一阵营，

304
00:15:29,763 --> 00:15:31,463
他们都只是在说对方，

305
00:15:31,532 --> 00:15:34,967
好的？所以这是一个不要走。而且当然，

306
00:15:35,035 --> 00:15:37,769
我会显示你，不是下周，而是一周之后，

307
00:15:37,838 --> 00:15:40,672
我们如何在MVC之间建立这些连接。为了第一

308
00:15:40,741 --> 00:15:42,874
两个星期，我们将专注于建立一个MVC，

309
00:15:42,943 --> 00:15:44,976
我们的计算器，一个MVC。但

310
00:15:45,045 --> 00:15:48,146
我们将在第三周向我们的计算器添加另一个MVC。

311
00:15:48,214 --> 00:15:52,283
你会看到，这就是我们如何连线这些东西，

312
00:15:52,352 --> 00:15:54,953
好的？那就是MVC。我们要回来

313
00:15:55,021 --> 00:15:57,155
继续我们的计算器演示。再次，

314
00:15:57,224 --> 00:15:59,058
这是你稍后会看的幻灯片

315
00:15:59,126 --> 00:16:02,194
说，我是否了解所有这些事情？但愿如此。

316
00:16:02,263 --> 00:16:03,962
我不会回到这些幻灯片。

317
00:16:04,031 --> 00:16:06,631
所以让我谈一谈即将到来的事情。星期五，我们有

318
00:16:06,700 --> 00:16:09,367
这个调试周五会议。我还没有空间

319
00:16:09,436 --> 00:16:10,769
它，但它将在广场宣布。

320
00:16:10,837 --> 00:16:13,371
大概中午，也许是1点钟，

321
00:16:13,440 --> 00:16:15,907
我知道你们中有些人有冲突的事情

322
00:16:15,976 --> 00:16:17,943
那时候可能无法做到。

323
00:16:18,012 --> 00:16:21,045
这是可选的，但是我希望你们都能做到。

324
00:16:21,114 --> 00:16:24,082
我们也会在那个，像Xcode一样

325
00:16:24,151 --> 00:16:27,753
快捷方式，如何在Xcode中更容易一些。

326
00:16:27,822 --> 00:16:29,621
Cuz我总是最终点击一切，所以

327
00:16:29,690 --> 00:16:30,455
你可以看看我在做什么但

328
00:16:30,524 --> 00:16:34,092
您可以使用命令键来真正掌握Xcode。和

329
00:16:34,161 --> 00:16:35,426
那么不要忘记周一的假期吧

330
00:16:35,495 --> 00:16:36,661
不要在这里出现

331
00:16:36,730 --> 00:16:39,798
然后下周三，我的阅读作业

332
00:16:39,866 --> 00:16:42,267
分配在星期一，加上编程分配

333
00:16:42,336 --> 00:16:44,836
我今天刚放上广场，都要到了

334
00:16:44,905 --> 00:16:47,405
下周三。然后下个星期三，你会得到另一

335
00:16:47,474 --> 00:16:49,074
阅读作业和另一个编程任务，

336
00:16:49,143 --> 00:16:53,712
一周后到期，好吗？好的，

337
00:16:53,780 --> 00:16:58,550
这里我们去，回到我们的计算器，这里是在哪里，

338
00:16:58,618 --> 00:17:03,221
我们正好在这里离开了。正如我所说的那样

339
00:17:03,290 --> 00:17:07,058
我们在那里，这是一个很好的小计算器，

340
00:17:07,127 --> 00:17:11,963
这真好。但是这个代码在这里很糟糕，

341
00:17:12,032 --> 00:17:15,734
这是什么计算器，这是什么？

342
00:17:15,802 --> 00:17:18,737
这是一个计算器。这是计算发生。

343
00:17:18,805 --> 00:17:20,905
这真的需要在不同的阵营。

344
00:17:20,974 --> 00:17:24,342
它不能像这样的控制器。所以这是主要的

345
00:17:24,411 --> 00:17:26,511
我们要在这个演示中做的事情就在这里，

346
00:17:26,580 --> 00:17:28,080
我们将要创建一个模型

347
00:17:28,148 --> 00:17:28,981
这个计算器，

348
00:17:29,049 --> 00:17:31,149
我们将把所有这些计算。

349
00:17:31,217 --> 00:17:33,685
然后我们会让这个模型真的很强大

350
00:17:33,754 --> 00:17:35,687
可扩展，你会看到。所以

351
00:17:35,755 --> 00:17:39,657
我们需要为我们的模型创建一个新的数据结构

352
00:17:39,726 --> 00:17:41,927
我们用File> New File来做。

353
00:17:41,995 --> 00:17:44,396
任何时候我们要创建一个新的类或新的结构或

354
00:17:44,464 --> 00:17:46,764
任何一种新的数据结构，这就是我们所做的。

355
00:17:46,833 --> 00:17:51,937
所以我们打这个，这将是一个Swift文件。

356
00:17:52,005 --> 00:17:53,472
我们来看看，也许其中一两个，

357
00:17:53,541 --> 00:17:54,940
其实我们大概甚至不会看那些。

358
00:17:55,008 --> 00:17:57,675
几乎总是会创建一个Swift文件

359
00:17:57,744 --> 00:18:01,547
这里。在这里，它想知道这个名字。所以这是

360
00:18:01,615 --> 00:18:04,015
我的计算器的大脑，对，它的胆量。

361
00:18:04,084 --> 00:18:06,818
所以我会叫这个CalculatorBrain。那就是

362
00:18:06,887 --> 00:18:10,088
作为我将要使用的数据结构的名称

363
00:18:10,157 --> 00:18:13,992
这里。我会确定我把它放在同一个小组里，

364
00:18:14,061 --> 00:18:16,861
在这里，像我所有的其他人一样

365
00:18:16,930 --> 00:18:19,431
像ViewController的类，看到ViewController.swift？

366
00:18:19,500 --> 00:18:22,034
我会把它放在同一个地方。

367
00:18:22,103 --> 00:18:24,236
好的，所以这里是在左边和右边，

368
00:18:24,305 --> 00:18:27,139
实际上，让我们让它填满整个屏幕。

369
00:18:27,208 --> 00:18:30,175
如果我们在导航仪中看，现在我们有三个文件，

370
00:18:30,244 --> 00:18:33,512
好的，我们的控制器，有我们的看法，和

371
00:18:33,580 --> 00:18:38,216
有我们的模型，MVC，瞧，好吧，这很容易。现在，

372
00:18:38,285 --> 00:18:42,854
我们需要在这个模型中思考一下它的内容

373
00:18:42,922 --> 00:18:46,457
公共API是。换句话说，这个模型允许什么

374
00:18:46,526 --> 00:18:48,393
其他人，如控制器，

375
00:18:48,462 --> 00:18:51,896
去做？好的，这是最根本的事情之一

376
00:18:51,965 --> 00:18:54,166
你想做任何时候做设计。

377
00:18:54,234 --> 00:18:57,636
想想公共API，大家知道什么

378
00:18:57,704 --> 00:19:00,538
什么API的意思？应用程序接口。

379
00:19:00,607 --> 00:19:03,508
这是所有的方法和属性。 Snd这样

380
00:19:03,577 --> 00:19:06,744
您的公共API是您将要使用的方法和属性

381
00:19:06,813 --> 00:19:09,848
允许其他类或其他数据结构访问。

382
00:19:09,916 --> 00:19:13,051
所以我们真的很想想。也快

383
00:19:13,120 --> 00:19:16,254
注意到我们在这里导入了Foundation，而不是UIKit，

384
00:19:16,323 --> 00:19:20,258
因为这不会是一个UI类，对吧？这个

385
00:19:20,327 --> 00:19:24,630
是UI独立的，这是模型。现在我可以在这里说，

386
00:19:24,698 --> 00:19:28,433
好的，让我们创建一个名为CalculatorBrain的类。不，

387
00:19:28,502 --> 00:19:32,203
不是布莱恩，大脑。所以我可以做到这一点，但实际上并不是这样

388
00:19:32,272 --> 00:19:35,307
去做这个我将使用不同的数据结构

389
00:19:35,376 --> 00:19:39,711
这不是一个班，好吗？我要使用一个结构体。现在，

390
00:19:39,780 --> 00:19:42,347
你可能习惯于在其他语言中使用struct，但是

391
00:19:42,416 --> 00:19:44,983
你可能会想到它就像一个小集合

392
00:19:45,052 --> 00:19:48,753
的其他变量是一个结构体。在Swift，

393
00:19:48,822 --> 00:19:50,889
结构是一类的公民，

394
00:19:50,957 --> 00:19:53,691
非常喜欢上课，好吗？我会谈谈

395
00:19:53,760 --> 00:19:55,928
差异在一秒钟之内。其实

396
00:19:55,996 --> 00:20:00,298
Swift中大多数常用的类都是结构体，

397
00:20:00,367 --> 00:20:04,202
像字符串，双，数组，字典，

398
00:20:04,271 --> 00:20:07,005
这些都是结构体，它们不是类。所以

399
00:20:07,074 --> 00:20:09,340
一个struct和一个类有什么区别？

400
00:20:09,409 --> 00:20:11,143
我下周会详细谈一谈，但是

401
00:20:11,211 --> 00:20:12,978
我会告诉你两个重要的区别，

402
00:20:13,046 --> 00:20:14,880
两个最重要的区别。

403
00:20:14,949 --> 00:20:18,217
有一件事，类有继承，

404
00:20:18,285 --> 00:20:21,386
结构不行，好吗？所以如果你正在建设

405
00:20:21,454 --> 00:20:23,956
你认为的东西需要被分类

406
00:20:24,024 --> 00:20:26,658
要扩展，你可能想做一个类。我

407
00:20:26,727 --> 00:20:29,194
将我的CalculatorBrain以不同的方式扩展

408
00:20:29,263 --> 00:20:30,195
正如你将看到的那样

409
00:20:30,264 --> 00:20:33,265
它不需要是一个类。我可以改变

410
00:20:33,333 --> 00:20:35,534
如果我稍后改变我的想法，那就回到一个类，但是

411
00:20:35,602 --> 00:20:38,303
我目前的架构不需要被分类，

412
00:20:38,372 --> 00:20:41,239
这是一个区别。另一个区别，

413
00:20:41,308 --> 00:20:42,073
巨大的差异，和

414
00:20:42,142 --> 00:20:44,343
那个最需要用的东西

415
00:20:44,411 --> 00:20:49,180
在概念上，是类生活在堆里，而且

416
00:20:49,249 --> 00:20:53,151
你有指向他们的指针。结构不住

417
00:20:53,220 --> 00:20:58,156
堆，他们通过复制他们传递，好吗？

418
00:20:58,225 --> 00:21:02,293
我们称复制样式值类型。

419
00:21:02,362 --> 00:21:06,564
我们在堆文件中调用样式，引用类型。

420
00:21:06,633 --> 00:21:09,067
因为我们在课堂上提到他们，

421
00:21:09,136 --> 00:21:10,902
我们实际上将它们复制在struct case中。

422
00:21:10,971 --> 00:21:14,105
现在，你知道，这似乎是一个很大的限制。

423
00:21:14,174 --> 00:21:16,207
我必须复制这些东西，如果大的话呢？

424
00:21:16,276 --> 00:21:19,912
但正如我星期一提到的那样，这些事情都转过来了

425
00:21:19,980 --> 00:21:23,048
右边复制。所以当你传递他们，如果你没有

426
00:21:23,117 --> 00:21:26,819
实际上改变了它们，实际上没有任何副本。好的，

427
00:21:26,887 --> 00:21:30,155
但这一切都在幕后，对吗？

428
00:21:30,224 --> 00:21:31,155
所以这是一个很大的区别。

429
00:21:31,224 --> 00:21:33,992
现在为什么要我的CalculatorBrain成为一个结构体

430
00:21:34,060 --> 00:21:37,095
而不是上课？嗯，我不会想像我会有的

431
00:21:37,164 --> 00:21:39,064
一大堆不同的人引用它。

432
00:21:39,133 --> 00:21:42,334
CalculatorBrain是一个MVC的大脑。

433
00:21:42,402 --> 00:21:45,137
所以MVC将会访问它，但是我看不到很多

434
00:21:45,205 --> 00:21:49,008
的其他实体以某种方式试图指向这个事情。

435
00:21:49,076 --> 00:21:50,875
所以我真的不需要参考类型，

436
00:21:50,944 --> 00:21:55,814
好的。我可以从这个角度来看它是一种价值类型。所以

437
00:21:55,883 --> 00:21:58,250
这可能很好这也是一个很好的机会

438
00:21:58,319 --> 00:22:01,286
我来告诉你看起来像一个结构，因为

439
00:22:01,355 --> 00:22:03,621
使一个结构看起来就像是一个类，

440
00:22:03,690 --> 00:22:05,024
但有一些小的差异，

441
00:22:05,092 --> 00:22:07,726
你会很快在这里看到真正的，好吗？

442
00:22:07,795 --> 00:22:09,895
所以现在回到公共API，

443
00:22:09,963 --> 00:22:12,764
这是什么公共API？那我知道

444
00:22:12,832 --> 00:22:15,466
这个CalculatorBrain将需要一个功能执行

445
00:22:15,535 --> 00:22:19,304
操作。好的，因为这是根本的

446
00:22:19,373 --> 00:22:22,508
它能做什么。它执行一个操作。我们会用

447
00:22:22,576 --> 00:22:25,210
我们星期一用来定义它的机制是一样的。

448
00:22:25,279 --> 00:22:29,982
我会有一些数学符号是这样的东西

449
00:22:30,050 --> 00:22:35,620
定义我们正在执行哪些操作，好吗？并通知

450
00:22:35,689 --> 00:22:40,125
我把外部名字写成空白。这是一个密切的调用

451
00:22:40,194 --> 00:22:42,561
这里是否要将它作为符号。

452
00:22:42,629 --> 00:22:45,697
换句话说，我会像这样调用performOperation，

453
00:22:45,766 --> 00:22:48,567
好的，执行操作（符号，无论如何

454
00:22:48,636 --> 00:22:53,939
我是否希望它是空白的，我说performOperation，

455
00:22:54,007 --> 00:22:56,475
而我只是把字符串，符号在这里像pi或

456
00:22:56,543 --> 00:22:59,244
随你。这是一个密切的调用，

457
00:22:59,313 --> 00:23:02,014
这是一个很好的判断力，哪个更好。

458
00:23:02,082 --> 00:23:04,015
我会去这样做，因为我觉得读这个代码，

459
00:23:04,084 --> 00:23:07,586
执行操作对我来说是完美的。

460
00:23:07,655 --> 00:23:10,121
在那里添加单词符号不是真的

461
00:23:10,190 --> 00:23:11,489
让我更清楚，所以

462
00:23:11,558 --> 00:23:14,492
这就是我要这样做的方式。好的，

463
00:23:14,561 --> 00:23:17,228
我还需要什么？那么，如果你正在执行操作，

464
00:23:17,297 --> 00:23:19,531
你必须有操作数执行一个，对吗？

465
00:23:19,600 --> 00:23:20,365
如果你做平方根，

466
00:23:20,434 --> 00:23:22,234
你必须做平方根的东西，无论如何。所以

467
00:23:22,303 --> 00:23:25,236
我必须要有一些功能来设置操作数

468
00:23:25,305 --> 00:23:28,206
哦，那好吧？而且我再也没有外部名字了，

469
00:23:28,275 --> 00:23:32,544
我们称之为操作符。我会有我的

470
00:23:32,612 --> 00:23:35,814
整个CalculatorBrain工作双打。它的

471
00:23:35,883 --> 00:23:39,084
将会是一个双精度的CalculatorBrain，所以我会

472
00:23:39,152 --> 00:23:42,120
操作数是double的。现在，这是一个我这样的情况

473
00:23:42,188 --> 00:23:45,223
绝对知道我不想有一个外部名字，

474
00:23:45,292 --> 00:23:48,393
因为说setOperand（operand：5.0），那就是

475
00:23:48,461 --> 00:23:51,830
可笑，这是完全冗余的，不需要它。

476
00:23:51,899 --> 00:23:55,467
很清楚，如果我这样做，setOperand（5.0）。

477
00:23:55,536 --> 00:23:58,102
很清楚我在说什么所以没有问题在我的

478
00:23:58,171 --> 00:24:01,173
记住那更好。然后你设置操作数，

479
00:24:01,242 --> 00:24:03,775
你执行操作，猜什么？你得

480
00:24:03,843 --> 00:24:08,013
得到结果。现在，我可以有一个func来getResult或

481
00:24:08,081 --> 00:24:12,150
这样的东西那会回来double吗？

482
00:24:12,218 --> 00:24:15,420
这是我做的一件事。但这真的不是很快。

483
00:24:15,489 --> 00:24:18,556
真的在Swift你会说什么，这是一个结果

484
00:24:18,625 --> 00:24:24,128
var，返回结果。现在这个UI的唯一问题，

485
00:24:24,197 --> 00:24:28,800
或者那个API，我不想让任何人设定我的结果。

486
00:24:28,869 --> 00:24:31,670
我是计算器大脑，我计算结果。所以

487
00:24:31,739 --> 00:24:33,438
这需要是只读的。

488
00:24:33,507 --> 00:24:38,210
有人记得我们如何使var只读？

489
00:24:38,279 --> 00:24:44,349
没有？有人建议让。那有点儿

490
00:24:44,418 --> 00:24:47,819
不完全是什么让。让它变得不变，

491
00:24:47,888 --> 00:24:50,922
这意味着它是只读的。但它只能设一次。

492
00:24:50,991 --> 00:24:54,059
而结果是不断变化。所以我们不能让let，

493
00:24:54,127 --> 00:24:56,528
不幸。但这是一个很好的猜测。

494
00:24:56,596 --> 00:25:00,365
其实我们用计算的属性来做它。好的，

495
00:25:00,434 --> 00:25:02,467
记住我们计算了显示值和

496
00:25:02,536 --> 00:25:05,170
我们得到和设置？那么，我们只是不做这套，对吧？

497
00:25:05,239 --> 00:25:07,706
在这种情况下，我们不会这样做。只是不把它放在

498
00:25:07,775 --> 00:25:09,741
那里。 Boom，这是一个只读属性。

499
00:25:09,810 --> 00:25:13,945
每个人都得到了就像按钮上的currentTitle。

500
00:25:14,014 --> 00:25:15,981
这只能得到。现在好了，

501
00:25:16,050 --> 00:25:18,917
我会想一下内部的一点

502
00:25:18,985 --> 00:25:22,287
在我去之前执行这个，并开始使用这个

503
00:25:22,355 --> 00:25:26,091
事情。我知道一个计算器的大脑，内部，

504
00:25:26,160 --> 00:25:30,728
它会像它一样积累其答案。和

505
00:25:30,797 --> 00:25:34,700
所以我实际上会有一个内部的var，看这个，

506
00:25:34,769 --> 00:25:40,004
私人变量我会叫它累加器(accumulator)，我是

507
00:25:40,073 --> 00:25:43,441
要做(double)，好吗？所以这将是内部的。

508
00:25:43,510 --> 00:25:46,178
所以现在，其他人不能访问这个。

509
00:25:46,246 --> 00:25:49,414
这就是私人的意思。并为您的所有功课

510
00:25:49,483 --> 00:25:52,184
这整个季度，我要你把私人放在前面

511
00:25:52,252 --> 00:25:56,087
你认为的内容是内部实现。

512
00:25:56,156 --> 00:25:59,191
在你创建的任何课程中，在这个课程中，好吗？

513
00:25:59,260 --> 00:26:01,326
所以习惯这样做。这很重要。

514
00:26:01,394 --> 00:26:04,529
这三个不是私人的。他们是公开的

515
00:26:04,598 --> 00:26:07,065
我会让别人打调用他们。但

516
00:26:07,133 --> 00:26:12,070
这一个是内部的。现在，你注意到的一件事是

517
00:26:12,138 --> 00:26:16,441
我没有任何错误，说没有初始化程序。

518
00:26:16,510 --> 00:26:18,810
记住，当我创建一个var

519
00:26:18,879 --> 00:26:20,178
视图控制器，

520
00:26:20,247 --> 00:26:22,714
它说没有初始化程序。而我不得不

521
00:26:22,782 --> 00:26:25,984
使userInTheMiddleOfTyping等于false。为什么不

522
00:26:26,053 --> 00:26:30,255
我必须在这里做吗？这是因为这是一个结构体。和

523
00:26:30,324 --> 00:26:33,258
结构体自动获取初始化程序。

524
00:26:33,327 --> 00:26:36,495
这将初始化所有未初始化的变量，

525
00:26:36,563 --> 00:26:38,163
好的？你得到一个免费的初始化程序。

526
00:26:38,231 --> 00:26:40,365
你不会上课的。只有结构，所以

527
00:26:40,433 --> 00:26:42,033
类和结构之间有一个区别。

528
00:26:42,102 --> 00:26:44,570
所以我们要有一个结构体，用于CalculatorBrain或

529
00:26:44,638 --> 00:26:47,139
CalculatorBrain的初始化程序。那会的

530
00:26:47,207 --> 00:26:50,375
取一倍，它将初始化为累加器。

531
00:26:50,444 --> 00:26:52,344
但实际上，我不想这样做。

532
00:26:52,413 --> 00:26:56,114
因为让我想想什么是累加器的初始值

533
00:26:56,182 --> 00:26:59,084
真的想成为当有人创建一个CalculatorBrain时，

534
00:26:59,152 --> 00:27:02,020
我不想让他们告诉我什么是累加器

535
00:27:02,089 --> 00:27:02,854
初始值为。

536
00:27:02,923 --> 00:27:05,724
因为我知道内部的初始累加器

537
00:27:05,793 --> 00:27:10,929
它的初始值是我启动时。没有设置

538
00:27:10,998 --> 00:27:13,098
所以我要把它做成一个可选的。

539
00:27:13,167 --> 00:27:15,467
你知道我为什么要这样做吗？

540
00:27:15,535 --> 00:27:18,102
因为累积器当我创造我的大脑。我没有

541
00:27:18,171 --> 00:27:21,306
积累了任何结果。所以我在这个未设定的状态。

542
00:27:21,375 --> 00:27:24,009
所以，这是一个完美的机会，使它成为双重或

543
00:27:24,078 --> 00:27:29,147
一个可选的，所以我可以在我的代码中表达。好吧？所以

544
00:27:29,216 --> 00:27:31,549
如果我在这里有这个内部蓄电池，

545
00:27:31,618 --> 00:27:33,218
我该怎么用来实现这些？

546
00:27:33,286 --> 00:27:36,354
那么其中两个很容易。好的，setOperand

547
00:27:36,423 --> 00:27:39,958
只需设置累加器等于该操作数。好的，

548
00:27:40,026 --> 00:27:42,227
当你设置一个新的操作数来操作时，

549
00:27:42,296 --> 00:27:45,096
这取代了你对你的累加器的任何事情。

550
00:27:45,165 --> 00:27:47,999
这是你现在积累的所以那个

551
00:27:48,068 --> 00:27:52,604
可以是任何，比任何更容易。然后我们得到结果，

552
00:27:52,673 --> 00:27:57,842
你只要返回累加器。现在，

553
00:27:57,911 --> 00:27:59,544
我们在这里有几个错误

554
00:27:59,613 --> 00:28:01,813
必须处理。这是什么在这里？

555
00:28:01,882 --> 00:28:03,381
这看起来很好这怎么可能是坏的？

556
00:28:03,450 --> 00:28:06,284
累加器是一个可选的double，我正在设置它

557
00:28:06,353 --> 00:28:09,287
double，有什么问题吗？

558
00:28:09,356 --> 00:28:13,758
说我不能分配到这个属性，因为自己是

559
00:28:13,827 --> 00:28:18,296
不可改变的。自我意义的计算器大脑是不可变的。

560
00:28:18,365 --> 00:28:21,834
这是说，你想通过这种方法来解决这个问题

561
00:28:21,902 --> 00:28:25,403
变异？你看到他正在尝试添加这个。

562
00:28:25,472 --> 00:28:26,738
结构与类的另一个区别

563
00:28:26,806 --> 00:28:30,475
如果你有办法，好吗？或属性

564
00:28:30,543 --> 00:28:33,879
你正在设置，那么，如果你有一个方法和

565
00:28:33,947 --> 00:28:36,715
它改变了这件事的价值，

566
00:28:36,784 --> 00:28:41,753
你必须标记它变异。你必须告诉Swift，这个

567
00:28:41,821 --> 00:28:45,924
方法可以改变这个结构体的值。这是为什么？

568
00:28:45,993 --> 00:28:48,627
这是因为这个副本写的东西。记得，

569
00:28:48,696 --> 00:28:51,530
我告诉你，通过复制结构来传递结构。

570
00:28:51,598 --> 00:28:53,632
当你写信给他们时，它会复制它。所以

571
00:28:53,700 --> 00:28:56,067
它必须知道你正在通过调用setOperand来编写它。

572
00:28:56,136 --> 00:28:58,036
所以，你必须使setOperand变成func。

573
00:28:58,105 --> 00:29:02,807
这就是类和结构体之间的区别。

574
00:29:02,876 --> 00:29:05,644
有了这个，这个错误在这里呢？一个不同的错误。

575
00:29:05,713 --> 00:29:11,550
任何人都知道这个错误是什么？再大一点？好的，

576
00:29:11,619 --> 00:29:15,754
这里的问题是我们试图返回一个double的，

577
00:29:15,822 --> 00:29:20,893
一个累加器是可选的。好的，这就是说这里，

578
00:29:20,961 --> 00:29:25,797
嘿解包这个。现在，我不想在这里做。好的，

579
00:29:25,866 --> 00:29:28,800
因为它对于不是累加器是完全有效的

580
00:29:28,869 --> 00:29:31,603
组。其实这个开始没有设定。其实

581
00:29:31,672 --> 00:29:34,406
我可以想到另一种蓄电池的情况

582
00:29:34,475 --> 00:29:38,743
不会设定如果我说，五次三等于，

583
00:29:38,812 --> 00:29:42,180
在我的计算器我说了五次后，

584
00:29:42,249 --> 00:29:44,883
我的累加器现在没有设置。

585
00:29:44,952 --> 00:29:49,187
Cuz我需要三个等号，直到我能得到结果。所以

586
00:29:49,256 --> 00:29:52,657
我的累积器通常会回到没有设置。

587
00:29:52,726 --> 00:29:56,228
当我们处于奇怪的五次三等于五次时，

588
00:29:56,296 --> 00:29:58,897
累加器现在不设置。三，好的，

589
00:29:58,966 --> 00:30:00,599
累加器的重新设置，等于，好的，

590
00:30:00,668 --> 00:30:02,233
这是结果。好的，

591
00:30:02,302 --> 00:30:04,536
所以我不能有这个感叹号。

592
00:30:04,604 --> 00:30:06,804
或者这个东西每次有人要求都会崩溃

593
00:30:06,873 --> 00:30:10,542
结果他们说了五次。所以我们不能这样做。

594
00:30:10,611 --> 00:30:15,614
所以我打算把结果变成一个可选的。和

595
00:30:15,682 --> 00:30:16,514
这也是有道理的。

596
00:30:16,583 --> 00:30:20,419
因为如果有人在五中使用这个对象

597
00:30:20,487 --> 00:30:24,156
结果是什么？它会告诉你的

598
00:30:24,224 --> 00:30:26,925
没有设置，因为我在五中的中间，对吧？

599
00:30:26,994 --> 00:30:30,128
在你的作业中，你甚至会更加清晰

600
00:30:30,197 --> 00:30:33,298
这个用户为什么可能不设置，好吗？所以

601
00:30:33,367 --> 00:30:35,968
你会看到好的，所以

602
00:30:36,036 --> 00:30:40,005
这是一个很好的开始执行这个事情。

603
00:30:40,074 --> 00:30:42,841
但在我们进一步深入实施之前，

604
00:30:42,909 --> 00:30:45,944
让我们回到我们的控制器，并使用这个公众

605
00:30:46,012 --> 00:30:48,813
我刚才设计的API好的，我想用这个。

606
00:30:48,882 --> 00:30:50,615
所以我会回到我的控制器。现在，

607
00:30:50,684 --> 00:30:53,819
我想让我的控制器和我的模型在屏幕上一样

608
00:30:53,888 --> 00:30:56,654
时间。只是这样我可以看到他们并肩。和

609
00:30:56,723 --> 00:30:59,291
最好的办法是带出这个助手

610
00:30:59,359 --> 00:31:03,094
编辑的话再说一次吧？你可以上到顶部。

611
00:31:03,163 --> 00:31:06,264
而且你实际上可以手动选择。要么

612
00:31:06,333 --> 00:31:08,866
我会教你一点点Alt的东西。

613
00:31:08,935 --> 00:31:14,005
如果您按住Alt键并点击其他文件，

614
00:31:14,074 --> 00:31:15,840
你会得到它出现在右边。

615
00:31:15,909 --> 00:31:18,110
所以按住Alt键意味着把它放在右边。

616
00:31:19,546 --> 00:31:23,348
好的，所以在这里我有我的模型在左边。

617
00:31:23,417 --> 00:31:25,651
在这里，我的控制器在右边。

618
00:31:25,719 --> 00:31:29,821
所以我现在需要做的是修复这个破坏的代码

619
00:31:29,890 --> 00:31:34,726
通过使用公共的方式在控制器内部做模型

620
00:31:34,795 --> 00:31:37,963
我的模型的API现在，请注意

621
00:31:38,032 --> 00:31:41,967
touchDigit在计算时什么都不做。

622
00:31:42,036 --> 00:31:44,002
它所做的就是从键盘上取数字

623
00:31:44,071 --> 00:31:46,304
把它们放在展示中。所以没有做任何计算

624
00:31:46,373 --> 00:31:47,639
我们不必这么说。

625
00:31:47,708 --> 00:31:50,575
与此显示值相同的事情计算出的var。

626
00:31:50,644 --> 00:31:51,843
它所做的就是转换

627
00:31:51,912 --> 00:31:53,745
显示从双字母到字符串和

628
00:31:53,814 --> 00:31:54,346
背部。这就是它所做的一切。

629
00:31:54,414 --> 00:31:56,515
与计算器无关。

630
00:31:56,584 --> 00:31:59,585
这只是这个特定计算器的UI。所以

631
00:31:59,653 --> 00:32:02,154
这个方法是我们唯一需要改变的，

632
00:32:02,223 --> 00:32:07,025
performOperation。现在，我们知道这一部分在这里

633
00:32:07,093 --> 00:32:10,229
不属于这里。事实上，我会把它扔掉

634
00:32:10,297 --> 00:32:12,630
这里在我的模特儿即使它不会在那里工作。

635
00:32:12,699 --> 00:32:15,333
但是我们现在就把它扔在那里，只是为了让它脱颖而出

636
00:32:15,402 --> 00:32:20,405
方式好吗？所以现在我们需要以某种方式使用这个

637
00:32:20,474 --> 00:32:23,241
API在这里实现。所以，

638
00:32:23,310 --> 00:32:25,743
我们来看看这三个部分要做什么，

639
00:32:25,812 --> 00:32:28,513
我们在执行操作时要做什么首先，

640
00:32:28,582 --> 00:32:30,515
如果我们正在打字号码，

641
00:32:30,584 --> 00:32:33,819
我们需要将该数字设置为操作数，好吗？

642
00:32:33,887 --> 00:32:36,120
因为显然，用户输入一个数字和

643
00:32:36,189 --> 00:32:38,857
他们执行一个它们正在键入的数字的操作

644
00:32:38,926 --> 00:32:41,192
需要成为一个操作数。所以，在这里蝙蝠。

645
00:32:41,261 --> 00:32:44,996
我要说，如果用户正在打字的中间，

646
00:32:45,065 --> 00:32:48,733
那么我要设置操作数。现在，我该怎么办

647
00:32:48,802 --> 00:32:51,837
在这里沟通我的大脑我的大脑在哪里？ [LAUGH]我

648
00:32:51,905 --> 00:32:54,806
没有我的大脑的变种。所以让我们创建一个var，和

649
00:32:54,875 --> 00:32:58,743
它将是私有的。因为模型几乎总是

650
00:32:58,812 --> 00:33:01,947
私人到控制器。你不想要别人

651
00:33:02,015 --> 00:33:05,216
进入和混乱这个控制器的模型。所以

652
00:33:05,285 --> 00:33:06,851
我会把它变成一个私人变种。

653
00:33:06,920 --> 00:33:11,890
我会叫它大脑它的类型是CalculatorBrain，好吗？

654
00:33:11,958 --> 00:33:14,793
那很好。现在，一旦我把这行代码放进去，

655
00:33:14,862 --> 00:33:18,297
看看我得到什么老，你没有任何初始化器。

656
00:33:18,366 --> 00:33:20,732
这是因为这没有初始化。

657
00:33:20,801 --> 00:33:23,802
所以我要通过创建一个CalculatorBrain来初始化它。

658
00:33:23,871 --> 00:33:26,104
并且您正好创建了一个CalculatorBrain

659
00:33:26,173 --> 00:33:29,608
与您作为课程创建的方式相同。

660
00:33:29,677 --> 00:33:32,477
使用类型的名称，然后是括号。

661
00:33:32,546 --> 00:33:36,080
现在我们在这里没有论据。因为我们没有

662
00:33:36,149 --> 00:33:39,384
未初始化的变量由于我们这样做是一个可选的，

663
00:33:39,453 --> 00:33:41,987
它自动为我们自动初始化为零，

664
00:33:42,056 --> 00:33:44,389
记得？所以我们没有未初始化的vars，所以

665
00:33:44,458 --> 00:33:46,858
我们只是做开放括号，闭括号。和

666
00:33:46,927 --> 00:33:49,895
当然，我们不需要这种类型，对吧？

667
00:33:49,963 --> 00:33:54,099
因为它被推断。那么，如果我们问这是什么类型的？

668
00:33:54,167 --> 00:33:56,735
它说，这是一个计算器大脑。必须是cuz这是

669
00:33:56,804 --> 00:34:00,272
你设置什么好的，所以现在我们有一个模型，

670
00:34:00,341 --> 00:34:03,408
我们的控制器这是绿色的箭头，从我们说话

671
00:34:03,476 --> 00:34:07,212
控制器到模型。我们可以说，大脑设置你的

672
00:34:07,281 --> 00:34:11,616
操作数是显示值的任何值。和

673
00:34:11,685 --> 00:34:14,452
当然现在我们不在打字的中间，所以我会的

674
00:34:14,521 --> 00:34:17,989
把它放在这里这就是我们需要做的所有事情

675
00:34:18,058 --> 00:34:20,492
大脑的操作数。我们只需要做，如果这些

676
00:34:20,560 --> 00:34:21,860
中间打字新的，

677
00:34:21,929 --> 00:34:23,095
他们打了一个操作按钮。

678
00:34:23,164 --> 00:34:26,031
我们需要给他们那个操作数，好吗？

679
00:34:26,099 --> 00:34:28,433
现在，这里的东西呢，好吗？

680
00:34:28,502 --> 00:34:30,935
我们得到这个操作的数学符号。

681
00:34:31,004 --> 00:34:32,471
现在我要让大脑做到这一点。

682
00:34:32,540 --> 00:34:35,107
所以我只是说大脑执行操作，

683
00:34:35,175 --> 00:34:37,942
数学符号。而已。

684
00:34:38,011 --> 00:34:40,745
我只是把它交给了模型。因为那样，

685
00:34:40,814 --> 00:34:44,115
这不是我作为一个控制器做计算的工作。

686
00:34:44,184 --> 00:34:45,718
好的，我是一个UI的家伙

687
00:34:47,054 --> 00:34:49,954
现在当然这个操作完成后我需要

688
00:34:50,023 --> 00:34:55,427
将我的显示值设置为大脑的结果。

689
00:34:55,495 --> 00:34:58,730
但是当然我不能这样做，因为displayValue

690
00:34:58,799 --> 00:35:02,801
是双倍。结果可能是

691
00:35:02,870 --> 00:35:05,837
没有设置cuz这是一个可选的。所以我会在这里说，

692
00:35:05,906 --> 00:35:08,173
如果我可以让结果等于大脑的结果。

693
00:35:08,242 --> 00:35:12,443
换句话说，如果大脑的结果是确定的。然后我

694
00:35:12,512 --> 00:35:17,983
将让displayValue等于结果。而已。

695
00:35:18,052 --> 00:35:21,787
好的，所以输入的一小块代码完全没有

696
00:35:21,855 --> 00:35:24,823
将所有计算从控制器中取出。

697
00:35:24,891 --> 00:35:26,725
并把你放在这个其他阵营的模特里。

698
00:35:26,794 --> 00:35:29,294
现在我们可以用这个讲座的其余部分来做这个

699
00:35:29,362 --> 00:35:30,695
真正强大的模型

700
00:35:30,764 --> 00:35:32,397
没有什么会改变这里。

701
00:35:32,466 --> 00:35:37,035
我从来不会再次编辑这段代码。事实上，

702
00:35:37,104 --> 00:35:38,470
我要把它从屏幕上拿出来和

703
00:35:38,538 --> 00:35:42,674
我们将在模型中花费我们所有的时间在这里。

704
00:35:42,743 --> 00:35:45,510
所以，让我们开始做一个很脏的简单

705
00:35:45,579 --> 00:35:48,213
执行performOperation这里。哪一个

706
00:35:48,282 --> 00:35:51,483
尝试获取已经在那里工作的代码。

707
00:35:51,551 --> 00:35:53,785
大多数情况下，这只是改变名字的问题。

708
00:35:53,854 --> 00:35:55,520
因为这个参数是符号，

709
00:35:55,589 --> 00:35:58,056
不是数学符号。所以，我们会这样做

710
00:35:58,125 --> 00:36:00,658
而不是设置显示值cuz我们不在

711
00:36:00,727 --> 00:36:01,560
一个UI了。

712
00:36:01,628 --> 00:36:04,462
现在我们只是将累加器设置为double的pi。

713
00:36:04,531 --> 00:36:07,365
对，这里我们正在设置累加器

714
00:36:07,434 --> 00:36:11,270
作为累加器的平方根。好的，

715
00:36:11,338 --> 00:36:12,604
现在这里是一个问题。

716
00:36:12,672 --> 00:36:16,441
这行，为什么？Accumulator 是可选的。

717
00:36:16,510 --> 00:36:20,479
你不能拿一个可选的平方根。所以我可以说

718
00:36:20,547 --> 00:36:24,082
例如，如果让操作数等于累加器。

719
00:36:24,151 --> 00:36:29,054
所以如果我的累加器被设置，那么我可以点击累加器

720
00:36:29,123 --> 00:36:33,024
是操作数的平方根，好吗？现在，

721
00:36:33,093 --> 00:36:35,427
我们在这两条线上都有另一个警告。

722
00:36:35,496 --> 00:36:40,398
为什么你认为，有人知道为什么这是吗？我们看到了

723
00:36:40,467 --> 00:36:46,004
五分钟前。这个

724
00:36:46,073 --> 00:36:49,708
修改这个CalculatorBrain。所以这个方法，

725
00:36:49,777 --> 00:36:53,478
perfom操作，还需要在它前面变异，

726
00:36:53,547 --> 00:36:55,881
好的？所以我会解决的，添加变异。

727
00:36:58,184 --> 00:37:00,018
添加这个变异需要一点点习惯。

728
00:37:00,086 --> 00:37:03,054
但它是伟大的，因为它的编译器注意到它。这是

729
00:37:03,123 --> 00:37:08,126
总是提醒你这样做。所以相信它或

730
00:37:08,195 --> 00:37:11,964
不是我们现在有这个计算器的MVC版本，如果我们

731
00:37:12,032 --> 00:37:21,707
运行它应该只是工作。好吧，

732
00:37:21,775 --> 00:37:24,109
开始了。让我们来看看。 7,8，这还在工作。

733
00:37:24,177 --> 00:37:26,712
好的，那是在控制器。 Pi wo

734
00:37:26,780 --> 00:37:29,347
这是工作。它正在走向模型。

735
00:37:29,416 --> 00:37:32,517
这实际上正在执行。这是造成的

736
00:37:32,586 --> 00:37:36,521
累加器得到设置为双精度pi。和

737
00:37:36,590 --> 00:37:40,125
然后轻拍结果并将其显示出来。怎么样

738
00:37:40,193 --> 00:37:44,896
约81平方根，平根好的，优秀的，

739
00:37:44,965 --> 00:37:47,532
好的。所以现在我们从一个地方开始

740
00:37:47,601 --> 00:37:50,969
以前。但是我们分解了我们所有的计算代码

741
00:37:51,037 --> 00:37:54,640
进入这个小班。所以这是

742
00:37:54,708 --> 00:37:57,408
一个很好的机会，现在加强这个最大。

743
00:37:57,477 --> 00:38:00,512
所以我们将使用各种各样的酷，迅捷的东西，你

744
00:38:00,581 --> 00:38:02,814
可能没有看到其他语言。

745
00:38:02,883 --> 00:38:06,385
使这个更可扩展的计算器。

746
00:38:06,453 --> 00:38:09,454
现在，Cuz，如果我想增加更多的操作。

747
00:38:09,523 --> 00:38:12,223
我只是得到这个巨大的switch语句的情况，这种情况下，

748
00:38:12,292 --> 00:38:15,160
那个案子。如果让操作数相等，我就要做了

749
00:38:15,229 --> 00:38:16,761
累加器每一次。

750
00:38:16,830 --> 00:38:20,866
对于一般操作像平方根的东西。

751
00:38:20,934 --> 00:38:23,569
想象一下，当我有二分之一的情况下，五乘三

752
00:38:23,637 --> 00:38:26,371
等于。我必须要弄清楚如何处理

753
00:38:26,440 --> 00:38:28,973
与每一个案件的时间和平等。

754
00:38:29,042 --> 00:38:32,110
算了吧。我不能这样做我需要在这里搭建引擎

755
00:38:32,179 --> 00:38:33,545
这可以处理常数。

756
00:38:33,614 --> 00:38:35,880
这可以处理这些一元的操作，如平方根。

757
00:38:35,949 --> 00:38:39,150
这可以处理二进制操作，如乘法和

758
00:38:39,219 --> 00:38:42,053
加上这样的事情。好的？那就是这样

759
00:38:42,122 --> 00:38:44,389
我们要做我们要加强这个模式。现在，

760
00:38:44,458 --> 00:38:47,592
因为我们做了所有这些改进，我们不会改变它

761
00:38:47,661 --> 00:38:50,061
在外面。所以控制器不会改变。

762
00:38:50,130 --> 00:38:51,930
这是真的很酷的这个。我们可以做我们的

763
00:38:51,999 --> 00:38:53,898
模型开发独立于我们的UI。

764
00:38:53,967 --> 00:38:57,603
一旦我们有了UI，那么基础知识就可以了。

765
00:38:57,671 --> 00:39:00,638
那么我们在这里做什么呢？我们先来吧

766
00:39:00,707 --> 00:39:02,774
让我们摆脱这个代码，我们知道这很糟糕。

767
00:39:02,843 --> 00:39:06,144
我们不会这样做让我们专注于常数。

768
00:39:06,213 --> 00:39:10,315
如果我愿意，建一个桌子，不是很酷

769
00:39:10,384 --> 00:39:12,951
好吧，我会做方括号来拿我的桌子。和

770
00:39:13,020 --> 00:39:18,623
在这张桌子上，我有像pi和双点pi一样。接着，

771
00:39:18,692 --> 00:39:22,060
也许我有e的每个人都知道常数e是什么。

772
00:39:22,129 --> 00:39:24,262
数学2.71一件事

773
00:39:24,331 --> 00:39:25,397
我们有一个很好的符号

774
00:39:25,465 --> 00:39:28,233
那不如Double.pi那么好。但它被称为

775
00:39:28,301 --> 00:39:33,005
所以，我将所有的常数放在一张表中。

776
00:39:33,073 --> 00:39:35,040
然后在执行操作中，

777
00:39:35,109 --> 00:39:37,576
我只是查找那个表中的符号

778
00:39:37,644 --> 00:39:40,245
得到价值。这不会是更多的可扩展性

779
00:39:40,313 --> 00:39:42,514
常量？对，我可以添加我想要的所有常量。

780
00:39:42,582 --> 00:39:45,350
我只是一行代码。那会好多了

781
00:39:45,419 --> 00:39:48,253
比把额外的这个blah blah blah。可以，然后呢

782
00:39:48,322 --> 00:39:50,822
我们该怎么做呢？我们需要创建一个表。

783
00:39:50,891 --> 00:39:52,891
那么我们如何在Swift中创建一个表？

784
00:39:52,959 --> 00:39:56,995
我们使用称为字典的struct，好吗？所以

785
00:39:57,064 --> 00:39:59,865
字典是如何创建哈希表的东西。所以

786
00:39:59,934 --> 00:40:03,401
我要创建一个私有的var。

787
00:40:03,470 --> 00:40:05,870
我会叫它，我可以称之为常数，但是

788
00:40:05,939 --> 00:40:08,506
我将会称之为操作，我基本上是最终的

789
00:40:08,575 --> 00:40:12,143
加强对所有业务的工作

790
00:40:12,212 --> 00:40:16,147
它将是字典类型。现在字典，

791
00:40:16,216 --> 00:40:18,716
你会在这里看到Swift的一个新功能。这个，

792
00:40:18,785 --> 00:40:22,554
您也可以在Java中使用此功能。它是一种通用类型。

793
00:40:22,623 --> 00:40:25,157
所以一个字典，它可以是一个字典

794
00:40:25,226 --> 00:40:28,460
几乎任何一种关键几乎任何一种价值。

795
00:40:28,528 --> 00:40:30,995
好的，关键是要实现某个协议。

796
00:40:31,064 --> 00:40:32,797
它基本上必须是可以哈希的。好的，

797
00:40:32,866 --> 00:40:35,534
所以只要它是可加密的，那么它可以是一个关键

798
00:40:35,603 --> 00:40:38,336
那么该值可以是任何类型。所以你指出，

799
00:40:38,405 --> 00:40:40,339
与Java中的关键类型相同。

800
00:40:40,407 --> 00:40:42,975
所以我要把我的钥匙像pi或e这样的字符串。

801
00:40:43,043 --> 00:40:46,477
那么值将是一个double的，

802
00:40:46,546 --> 00:40:50,982
像Double.pi这样，还是_E，好吗？并相信它或

803
00:40:51,051 --> 00:40:54,019
不，我可以说等于这个语法和

804
00:40:54,088 --> 00:40:57,822
它会为我创造一个在那里的那一步，好吗？所以

805
00:40:57,891 --> 00:41:00,693
打开方括号，关键冒号值逗号键冒号，

806
00:41:02,029 --> 00:41:04,696
这就是你可以放一个字典。

807
00:41:04,765 --> 00:41:06,798
现在当然，你可以添加到字典和

808
00:41:06,867 --> 00:41:08,367
删除东西，并从字典中取得东西。

809
00:41:08,435 --> 00:41:09,934
我会在一秒钟内告诉你的。但

810
00:41:10,003 --> 00:41:13,304
这是一个很好的方式来做到这一点。所以

811
00:41:13,373 --> 00:41:17,843
我们这样做好的，所以我们有这个很好的字典。

812
00:41:17,912 --> 00:41:20,011
所以现在我们可以使用这个字典的操作和

813
00:41:20,080 --> 00:41:21,714
performOperation。我要说，

814
00:41:23,316 --> 00:41:30,054
如果我可以让我想要的常数等于操​​作

815
00:41:30,123 --> 00:41:35,293
那符合那个符号，现在为什么要这样做呢

816
00:41:35,362 --> 00:41:40,265
用于操作子符号？这个操作子符号，

817
00:41:40,334 --> 00:41:44,002
那就是你在字典中查找一个符号，对吧？

818
00:41:44,071 --> 00:41:46,437
操作到字典，点击它，对吧？

819
00:41:46,506 --> 00:41:49,574
到字典，字符串和双打。所以你看起来

820
00:41:49,643 --> 00:41:52,444
当你查找它，它返回一个可选的

821
00:41:52,512 --> 00:41:55,980
价值。为什么有人会为什么会这么做？

822
00:41:56,049 --> 00:41:56,948
>>可能不在那里

823
00:41:57,017 --> 00:41:58,149
>>确实，它可能不在

824
00:41:58,218 --> 00:42:01,353
桌子。好的，如果我说操作子X，

825
00:42:01,422 --> 00:42:04,522
那将不会回来，因为没有

826
00:42:04,591 --> 00:42:08,126
X在这个表。只有pi和e在那里，好吗？所以那是

827
00:42:08,195 --> 00:42:11,163
为什么我要做，如果让那里，如果常数在那里，

828
00:42:11,232 --> 00:42:13,865
现在我可以设置我的累加器等于该常数，

829
00:42:13,934 --> 00:42:17,135
好的？因为这个常数会是double的，因为

830
00:42:17,204 --> 00:42:21,239
这是一个具有double的词典，好吗？

831
00:42:21,308 --> 00:42:22,140
这很酷。我们继续吧

832
00:42:22,209 --> 00:42:23,909
我们来跑吧这就是我们需要做的。所以

833
00:42:23,978 --> 00:42:27,579
现在我们已经建立了，只为常数，更可扩展

834
00:42:27,648 --> 00:42:30,983
内部建筑在这里，到我们的计算器大脑。

835
00:42:31,051 --> 00:42:33,384
那么当然，平方根不会工作，好的，

836
00:42:33,453 --> 00:42:38,123
但pi工作，如果我添加一个e按钮，它会做e。好的，

837
00:42:38,192 --> 00:42:40,658
每个人都很酷，我在那里做什么？但

838
00:42:40,727 --> 00:42:44,363
当然，这对于常数来说是没有用的。

839
00:42:44,431 --> 00:42:48,066
我们想要这样做，看这个。引用，

840
00:42:48,135 --> 00:42:51,770
在这里做我的表情符号和符号

841
00:42:51,839 --> 00:42:55,106
有我们的平方根，平方根，

842
00:42:55,175 --> 00:43:00,913
我们想在这里放什么？平方根怎么样？

843
00:43:00,981 --> 00:43:05,217
好的，也许是余弦。把余弦放在那里

844
00:43:05,286 --> 00:43:09,121
如果我们能这么做，那不会很酷吗？

845
00:43:09,189 --> 00:43:10,922
因为现在我们真的有一个可扩展的表，

846
00:43:10,991 --> 00:43:14,492
它可以做不变，也可以做这些一致的功能。

847
00:43:14,561 --> 00:43:17,696
但是我们在这里遇到一个问题，因为平方根是最多的

848
00:43:17,765 --> 00:43:21,900
绝对不是双，对吧？平方根

849
00:43:21,969 --> 00:43:25,337
就像一个功能，所以这不是很好。所以我们要去

850
00:43:25,406 --> 00:43:28,674
如果我们想要一个混合在一起的字典，

851
00:43:28,742 --> 00:43:31,577
我们需要在这里创建代表这些的类型

852
00:43:31,645 --> 00:43:34,112
混合的东西这就是我们要做的，我们要去

853
00:43:34,181 --> 00:43:37,315
创建一个新的类型，好吗？这将是一个数据类型

854
00:43:37,384 --> 00:43:39,784
你会习惯于其他语言，但是

855
00:43:39,853 --> 00:43:42,287
你会看到它更强大的Swift。

856
00:43:42,356 --> 00:43:46,058
我要把它当成嵌入我的私有类型

857
00:43:46,126 --> 00:43:49,127
CalculatorBrain，所以你可以在类型和类型

858
00:43:49,196 --> 00:43:51,563
这只是一个范围界定的问题，这只是一个命名问题，

859
00:43:51,632 --> 00:43:54,165
好的？这个名字将会是CalculatorBrain，

860
00:43:54,234 --> 00:43:57,368
这个点，我在这里叫它。它不会是一个结构体

861
00:43:57,437 --> 00:44:01,940
或者一个类，它会成为一个枚举。大家好吗

862
00:44:02,009 --> 00:44:04,943
知道其他类的枚举是什么？这基本上是一个数据

863
00:44:05,012 --> 00:44:07,646
具有离散值的结构。对，

864
00:44:07,714 --> 00:44:10,015
它只能是一个，像这样的情况，无论如何。

865
00:44:10,084 --> 00:44:11,950
它只能是离散值之一

866
00:44:12,019 --> 00:44:15,653
同样的事情在这里Swift。我会叫它操作，

867
00:44:15,722 --> 00:44:18,456
它将会有不同的情况

868
00:44:18,525 --> 00:44:22,994
案例一元操作。那就是两种事情。

869
00:44:23,063 --> 00:44:26,798
然后我要让这个字典返回一个操作

870
00:44:26,867 --> 00:44:31,370
而不是Double。好的，所以这意味着我已经改变了一切

871
00:44:31,438 --> 00:44:34,772
这些，说Operation.constant，因为

872
00:44:34,841 --> 00:44:39,044
这是一个常数。我们只会评论一秒钟。

873
00:44:39,112 --> 00:44:42,147
然后这也是一个Operation.constant。

874
00:44:42,215 --> 00:44:46,384
这将是一个Operation.unary操作。

875
00:44:46,453 --> 00:44:49,854
我可以打电话给Operation.unary。

876
00:44:49,923 --> 00:44:51,289
我们会说一致的操作。

877
00:44:51,358 --> 00:44:55,160
Operation.unary操作，好吗？

878
00:44:55,228 --> 00:44:58,763
凉！好的，我们现在不能这样做，当然，现在是cuz

879
00:44:58,832 --> 00:45:01,299
我们拉出来不是一个常数。

880
00:45:01,368 --> 00:45:05,237
这实际上是一个操作，好吗？显然，

881
00:45:05,305 --> 00:45:08,439
我们不能这样做，因为这个常数在这里，

882
00:45:08,508 --> 00:45:12,277
现在是一个不是双重的操作。所以我们不能这样说

883
00:45:12,346 --> 00:45:16,582
等于，好吗？所以这很好。这变得越来越好

884
00:45:16,650 --> 00:45:19,084
我们已经有了我们的桌子，可以有两件事情。但

885
00:45:19,153 --> 00:45:22,954
在这样做的时候，我已经失去了根本的意义

886
00:45:23,023 --> 00:45:25,757
所有这些事情。我评论了所以

887
00:45:25,826 --> 00:45:29,227
现在这个表是没有用的，对吧？

888
00:45:29,296 --> 00:45:30,929
它知道pi是一个常数。

889
00:45:30,998 --> 00:45:33,631
它知道平方根是一次性的操作。

890
00:45:33,700 --> 00:45:36,668
但是这样呢？因为我们不能做任何的。和

891
00:45:36,737 --> 00:45:40,773
这是你以前听说过的，

892
00:45:40,841 --> 00:45:44,242
相关的值进来

893
00:45:44,311 --> 00:45:46,845
这个东西在什么时候在这个阶段就有了

894
00:45:46,914 --> 00:45:49,681
与设置状态相关联的关联值，

895
00:45:49,750 --> 00:45:54,953
但是没有与未设置状态相关联？好的，可选

896
00:45:55,022 --> 00:45:59,925
是一个枚举这是一个枚举，有两种情况。不设套的情况下，

897
00:45:59,994 --> 00:46:03,094
这被称为none和set case，称为sum。

898
00:46:03,163 --> 00:46:06,398
在总和的情况下，它有一点关联的价值

899
00:46:06,467 --> 00:46:10,034
它。我们可以做同样的事情，好吗？在我们的枚举中，

900
00:46:10,103 --> 00:46:13,739
当情况是一个常数时，我们可以有一个关联的

901
00:46:13,807 --> 00:46:16,441
双。那就是我们把它放在那里

902
00:46:16,510 --> 00:46:19,344
我们实际上可以有多个相关联的值。

903
00:46:19,413 --> 00:46:21,880
我们只需要一个常量。但我们可以拥有

904
00:46:21,949 --> 00:46:25,550
这个关联值。好的，所以关联的值

905
00:46:25,619 --> 00:46:28,587
是不是特定于可选项的东西。这是为了

906
00:46:28,656 --> 00:46:33,525
Swift中的所有枚举所以这是超级强大，因为现在

907
00:46:33,593 --> 00:46:37,295
当我在这个表中添加一个常量，例如，

908
00:46:37,364 --> 00:46:41,699
我可以将Double.pi与它相关联。

909
00:46:41,768 --> 00:46:47,205
同样的事情，这个常数，我只是关联的价值

910
00:46:47,274 --> 00:46:50,575
的e。好的，现在我们再来一次。

911
00:46:50,644 --> 00:46:53,111
那里有点复杂好的，所以

912
00:46:53,180 --> 00:46:56,314
现在我有一张表，里面有常数

913
00:46:56,383 --> 00:46:57,649
实际上我知道这些价值观。

914
00:46:57,718 --> 00:47:00,685
所以在这里，当我把这个操作从这里出来的时候，

915
00:47:00,754 --> 00:47:02,187
这是一个类型操作，

916
00:47:02,255 --> 00:47:06,057
它是这些枚举之一。我如何看待这些，

917
00:47:06,126 --> 00:47:09,428
并喜欢得到这个相关的价值？那么你会怎么样

918
00:47:09,496 --> 00:47:11,796
看一下另一种语言的枚举值？

919
00:47:11,865 --> 00:47:14,265
你可能会打开它们。所以

920
00:47:14,334 --> 00:47:16,268
我要打开这个操作

921
00:47:16,336 --> 00:47:20,939
当我是一个常数时，我会做一个案例(case)。和

922
00:47:21,008 --> 00:47:25,444
我要做一个案子，我们会做冒号和打破(break)。

923
00:47:25,512 --> 00:47:27,445
当我们做一个unaryOperation时，我会做一个案子，

924
00:47:27,514 --> 00:47:31,650
打破这种情况，好吗？而我甚至不必

925
00:47:31,718 --> 00:47:34,286
说这里是默认的，因为这是唯一的两个值

926
00:47:34,354 --> 00:47:36,087
一个操作可以是，它是一个枚举，

927
00:47:36,156 --> 00:47:39,591
它只有这两个值之一。现在在这里，你可以看到，

928
00:47:39,660 --> 00:47:42,327
它已经在这里放在括号中。

929
00:47:42,395 --> 00:47:46,264
好的，它想帮助你获得相关的价值。

930
00:47:46,333 --> 00:47:47,866
好的，真棒，我们该怎么做？

931
00:47:47,935 --> 00:47:51,536
我们说let ConnectionValue或

932
00:47:51,605 --> 00:47:55,940
无论我们想称之为这个变量。和

933
00:47:56,009 --> 00:47:59,044
这意味着在这里，associatedConstantValue

934
00:47:59,113 --> 00:48:01,813
将是相关价值。现在我们永远不会调用

935
00:48:01,881 --> 00:48:04,783
它关联ConstantValue。我们会在一秒钟内重新命名。

936
00:48:04,851 --> 00:48:06,585
但是现在我们要做什么呢？好，

937
00:48:06,653 --> 00:48:09,454
在不断的情况下，我们将要设置我们的累加器

938
00:48:09,522 --> 00:48:12,924
到相关联的值。现在，为什么我们不叫这个

939
00:48:12,993 --> 00:48:15,494
associatedConstantValue？那么，首先，任何人读书

940
00:48:15,562 --> 00:48:18,129
这段代码知道这是相关联的值，

941
00:48:18,198 --> 00:48:21,466
所以你不需要说关联。我们知道我是

942
00:48:21,535 --> 00:48:24,002
一个常数，因为我们处于不断的情况

943
00:48:24,071 --> 00:48:25,737
我真的很浪费了。

944
00:48:25,805 --> 00:48:29,074
所以，我们只是说这里的价值。 Cuz这是什么，

945
00:48:29,143 --> 00:48:33,712
我是与它相关联的恒定值，好吗？

946
00:48:33,781 --> 00:48:37,415
我们不需要休息。每个人都得到了

947
00:48:37,484 --> 00:48:39,917
顺便说一下，Swift中的开关略有不同

948
00:48:39,986 --> 00:48:42,921
他们不会相互堕落。当你有不变时，

949
00:48:42,990 --> 00:48:45,957
它做到这一点，而且完成了。它不会下降，跌倒

950
00:48:46,026 --> 00:48:49,161
到下一个例子，好吗？所以你最终不需要休息

951
00:48:49,230 --> 00:48:51,697
每一个，这是真的很好。好吧？

952
00:48:51,765 --> 00:48:54,032
所以这是伟大的那么这个工作呢？我想是这样。

953
00:48:54,101 --> 00:49:03,208
让我们试试吧好吧。

954
00:49:03,276 --> 00:49:05,711
所以。 Pi，好的，平方根我们没有做任何事情，

955
00:49:05,779 --> 00:49:08,514
但pi应该工作。咱们试试吧。宾果，好的

956
00:49:08,582 --> 00:49:10,748
所以你看到pi在这里工作吗？

957
00:49:10,817 --> 00:49:14,852
我们在说这个表中的pi。它发现

958
00:49:14,921 --> 00:49:17,756
它是一个恒定的操作，它作为相关联的值。

959
00:49:17,825 --> 00:49:21,893
我们打开这个操作。发现这是一个常数。

960
00:49:21,962 --> 00:49:25,364
我们让值等于相关值，

961
00:49:25,432 --> 00:49:27,099
然后我们将它设置为累加器。

962
00:49:28,568 --> 00:49:31,470
现在这是我们的结果，下次他们要求结果

963
00:49:31,538 --> 00:49:33,572
这就是我们所得到的。好的，现在让我们一手操作。

964
00:49:33,641 --> 00:49:35,740
好的，这个有点强硬，好吗？

965
00:49:35,809 --> 00:49:41,846
这是真的，我想做的对？

966
00:49:41,915 --> 00:49:45,851
相关值希望成为这些功能。

967
00:49:47,220 --> 00:49:50,021
我可以在Swfit吗？当然！

968
00:49:50,090 --> 00:49:52,924
如果我们不能这样做，我们不会在这里。

969
00:49:52,993 --> 00:49:55,861
我们如何使相关值成为一个函数？

970
00:49:55,929 --> 00:49:58,997
那么Swift很酷的事情就是这个功能

971
00:49:59,066 --> 00:50:03,802
是正常类型。就像一个double，任何结构，

972
00:50:03,871 --> 00:50:06,905
一个类，没有什么区别和一个double。

973
00:50:06,974 --> 00:50:09,608
那么我该如何回溯到我的枚举呢？

974
00:50:09,676 --> 00:50:12,677
这里的关联类型是双倍？我怎么说，

975
00:50:12,746 --> 00:50:15,514
该类型是一个double和

976
00:50:15,582 --> 00:50:17,415
返回一个double？ Cuz这就是我想要的。

977
00:50:17,484 --> 00:50:18,750
这是一次性的操作

978
00:50:18,819 --> 00:50:21,419
我需要这是一个需要double的功能

979
00:50:21,488 --> 00:50:24,489
返回一个double。我们只是键入它，功能需要

980
00:50:24,557 --> 00:50:27,226
一个double，返回一个double。只是在那里输入它。

981
00:50:28,596 --> 00:50:32,364
这是一种类型。只是一个类型，就像字符串，

982
00:50:32,433 --> 00:50:35,133
但它恰好是一个功能。现在我

983
00:50:35,202 --> 00:50:37,669
要在这里休息一下，只是给你一点点

984
00:50:37,738 --> 00:50:39,237
更多关于这个功能类型，

985
00:50:39,306 --> 00:50:41,906
确保你得到这个。我要做的是

986
00:50:41,975 --> 00:50:44,476
我要创建一个叫做游乐场的新事物。

987
00:50:44,544 --> 00:50:46,978
所以操场只是一个可以玩的地方

988
00:50:47,047 --> 00:50:49,948
iOS代码好的？所以你只是说新的playground，

989
00:50:50,017 --> 00:50:52,884
这将是一个iOS playground。我会叫它

990
00:50:52,953 --> 00:50:55,420
我的CalculatorPlayground，我可以叫它任何我想要的。

991
00:50:55,489 --> 00:50:57,355
只要把它保存在磁盘上，这样我就可以

992
00:50:57,424 --> 00:50:59,791
当我在玩的时候输入这里，下次再保存。

993
00:50:59,860 --> 00:51:01,593
你可以把它放在任何你想要的地方。

994
00:51:01,662 --> 00:51:04,863
我推荐同一个地方，主目录，开发者。

995
00:51:04,932 --> 00:51:07,598
好的，别把它放在另一个项目里面。

996
00:51:07,667 --> 00:51:10,535
你可以看到这样的playground。在左边，

997
00:51:10,604 --> 00:51:14,039
您可以键入所需的任何iOS代码。而在右边，

998
00:51:14,108 --> 00:51:17,442
这将会评估左边的内容，而不是告诉你

999
00:51:17,511 --> 00:51:19,845
只是，嗯，它基本上会告诉你的结果或

1000
00:51:19,913 --> 00:51:22,013
它找到的任何var的值。

1001
00:51:22,082 --> 00:51:24,916
所以在这里它发现这个var string，str，它的

1002
00:51:24,985 --> 00:51:28,587
告诉你str在这里的价值。好的？所以我可以说，

1003
00:51:28,656 --> 00:51:33,125
例如，让我= 27，它会说27是什么

1004
00:51:33,194 --> 00:51:38,763
它看到那里。但我会创建一个新的var。

1005
00:51:38,832 --> 00:51:42,601
我会叫它f。它的类型将是一个功能

1006
00:51:42,670 --> 00:51:46,671
需要双倍并返回双倍。好的，这是它的类型。

1007
00:51:46,740 --> 00:51:49,808
我可以说f，var f字符串，但是

1008
00:51:49,877 --> 00:51:52,043
我说这是一个需要double的方法

1009
00:51:52,112 --> 00:51:54,346
返回一个double。我会设定f的值。

1010
00:51:54,414 --> 00:51:58,316
我要等于平方根。好的，

1011
00:51:58,385 --> 00:51:59,684
我的意思是这是一个需要double的方法

1012
00:51:59,753 --> 00:52:02,688
返回一个double。所以我可以说f =平方根。现在我怎么样

1013
00:52:02,756 --> 00:52:07,493
实际上调用这个函数？我会让x等于f

1014
00:52:07,561 --> 00:52:12,598
例如81。好的，所以我称这个变量，

1015
00:52:12,666 --> 00:52:14,466
在这里，这是一个double的，

1016
00:52:14,534 --> 00:52:17,269
就像这是一个方法。如果我要回去

1017
00:52:17,338 --> 00:52:22,674
改变为余弦，看看会发生什么。好的，

1018
00:52:22,742 --> 00:52:25,510
所以现在f是余弦，所以现在我得到了81的余弦。

1019
00:52:25,579 --> 00:52:27,078
我甚至可以写我自己的功能，

1020
00:52:27,147 --> 00:52:29,748
怎么回事func changeSign，

1021
00:52:29,817 --> 00:52:33,752
让我们说这需要一double的

1022
00:52:33,821 --> 00:52:37,222
返回一个double，好的。所以这是一个普通的方法，

1023
00:52:37,291 --> 00:52:40,125
返回changeSigned操作数，对，

1024
00:52:40,194 --> 00:52:43,261
操作数更改标志。所以现在我可以在这里下去了

1025
00:52:43,330 --> 00:52:47,666
改变这个是changeSign，我写的功能。和

1026
00:52:47,734 --> 00:52:50,536
现在我正在减81。所以大家看到如何

1027
00:52:50,604 --> 00:52:53,538
这种类型作为一种类型？他们只是正常的类型。

1028
00:52:53,607 --> 00:52:56,341
绝对可以在任何地方使用函数作为类型

1029
00:52:56,409 --> 00:52:59,344
您可以使用任何其他类型。一个方法的参数，

1030
00:52:59,413 --> 00:53:03,215
枚举中的关联值，局部变量，任何东西。

1031
00:53:03,284 --> 00:53:06,451
没有限制，好吗？我甚至会采取，

1032
00:53:06,520 --> 00:53:09,287
注意，顺便说一句，变更标志有一个外部的

1033
00:53:09,356 --> 00:53:11,823
名称，操作数。当你高大的时候，打调用变更标志

1034
00:53:11,891 --> 00:53:15,493
看起来像这样。看到？我们有这个操作数。没关系，

1035
00:53:15,562 --> 00:53:18,296
当我把它称为这里时，我不必说f（operand）。

1036
00:53:18,365 --> 00:53:21,166
其实我不能这样说。那是因为f

1037
00:53:21,235 --> 00:53:23,835
只是一个需要double的方法，返回一个double。

1038
00:53:23,904 --> 00:53:25,403
它可以是任何需要double的方法

1039
00:53:25,472 --> 00:53:27,940
返回一个double，所以你不能有这些外部名字

1040
00:53:28,008 --> 00:53:29,741
在那里，它可以是任何方法。

1041
00:53:29,809 --> 00:53:33,678
当你改变它，你不能改变这一点，所以，无论如何，

1042
00:53:33,747 --> 00:53:37,315
只是一个小笔记。所以我要采取changeSign，

1043
00:53:37,384 --> 00:53:40,952
实际上，并将其复制并粘贴到我的代码中，

1044
00:53:41,021 --> 00:53:44,056
所以我刚刚做了一个新的功能，这甚至是一个很好的全球

1045
00:53:44,124 --> 00:53:46,458
到这个文件，函数叫做changeSign。和

1046
00:53:46,527 --> 00:53:49,894
我可以回到这里说，changeSign，让我们做点什么

1047
00:53:49,963 --> 00:53:54,232
为changeSign。我想我可以记得如何做到这一点

1048
00:53:54,301 --> 00:53:57,435
那里有Ctrl + C，Cmd + Ctrl + Space等等，

1049
00:53:57,504 --> 00:54:01,606
我们去这里编辑好，我们需要一些东西

1050
00:54:01,675 --> 00:54:03,942
changeSign，我想我有一个在这里，这个，好吗？

1051
00:54:04,011 --> 00:54:06,445
这不是真正的变化迹象[LAUGH]，但是，

1052
00:54:06,513 --> 00:54:09,747
没关系，我们会用它。所以

1053
00:54:09,816 --> 00:54:17,256
这是一个操作，Operation.unaryOperation（chan-

1054
00:54:17,324 --> 00:54:21,460
geSign）。好的？完全合法好的，大家都得到了

1055
00:54:21,528 --> 00:54:26,531
那？所以现在，在这里我们的switch，在一样

1056
00:54:26,600 --> 00:54:29,501
我们用let值来获取常数值的方式，

1057
00:54:29,570 --> 00:54:33,371
让我们用let函数来获取相关函数。

1058
00:54:33,440 --> 00:54:35,207
再次我们可以调用，这不一定是函数。

1059
00:54:35,275 --> 00:54:38,777
这可能是f。它可以是func。因为不能func

1060
00:54:38,846 --> 00:54:42,480
这是一个关键字，但功能可能是。好的？所以我们得到了

1061
00:54:42,549 --> 00:54:45,650
这一致的操作。我们要做什么？我们只是想要

1062
00:54:45,719 --> 00:54:49,954
用累加器来调用这个东西。好的？

1063
00:54:50,023 --> 00:54:52,657
但当然，我们更好，我很抱歉，我们想要我们的累加器

1064
00:54:52,726 --> 00:54:55,093
等于，用累加器调用该函数。

1065
00:54:55,162 --> 00:54:57,963
我们最好检查一下，以确保这不是零。所以

1066
00:54:58,032 --> 00:54:59,531
我实际上会做一些有些不同的事情。

1067
00:54:59,599 --> 00:55:02,267
而不是如果让，我会说如果累加器

1068
00:55:02,335 --> 00:55:07,272
不等于零那我们就这样做这是另一个

1069
00:55:07,341 --> 00:55:12,677
以防止这种崩溃的应用程序。好的，

1070
00:55:12,746 --> 00:55:16,648
有点类似于如果让操作数相等的累加器，

1071
00:55:16,717 --> 00:55:20,285
但是我实际上正在检查是否存在累加器

1072
00:55:20,354 --> 00:55:21,220
未设定状态，

1073
00:55:21,288 --> 00:55:23,888
累加器不是可选的，所以它可以等于零或

1074
00:55:23,957 --> 00:55:26,325
它等于别的东西，它有一个相关的价值

1075
00:55:26,393 --> 00:55:30,929
像这些东西好吧？这就是我们需要做的。

1076
00:55:30,998 --> 00:55:33,231
让我们来看看。哎呀，我们有错误吗？

1077
00:55:33,300 --> 00:55:39,771
不，我们没有。好的。好吧。

1078
00:55:39,840 --> 00:55:45,076
所以，pi，还是不错的。 81，平方根。

1079
00:55:45,145 --> 00:55:49,180
像一个魅力一样工作好的，再加上余弦和

1080
00:55:49,249 --> 00:55:51,016
那些我们要添加的那些在一秒钟，但为

1081
00:55:51,085 --> 00:55:53,618
时间我没有添加他们，但我们将添加余弦和

1082
00:55:53,687 --> 00:55:55,653
所有，实际上我是，忘了它，让我们来做。

1083
00:55:55,722 --> 00:55:59,357
我们在这里回到我们的UI，让我们再补充一下

1084
00:55:59,426 --> 00:56:04,495
纽扣。我们把余弦放在这里。余弦，

1085
00:56:04,564 --> 00:56:09,301
我们甚至把我们在那里做的一点变化的迹象。

1086
00:56:09,370 --> 00:56:14,472
Ctrl + Cmd +空格，我们去。更改标志。

1087
00:56:14,541 --> 00:56:17,475
把变更标志放在那里所以我们把那些放在那里

1088
00:56:17,544 --> 00:56:19,144
这就是我们在UI中需要做的一切。

1089
00:56:19,213 --> 00:56:21,046
它可以再次运行，因为我的大脑，

1090
00:56:21,114 --> 00:56:23,348
我的模型已经知道如何做这些操作。

1091
00:56:23,416 --> 00:56:26,018
所以我可以把任何操作我的大脑知道怎么做

1092
00:56:26,086 --> 00:56:28,386
进入我的计算器的UI，它只会工作。

1093
00:56:28,455 --> 00:56:32,524
所以这里我们得到了，你知道，pi余弦怎么样，-1.0，

1094
00:56:32,593 --> 00:56:38,029
好吧？变化标志，正面1.0。好的，所以

1095
00:56:38,098 --> 00:56:42,300
这真的很好看，因为我们的计算器脑，

1096
00:56:42,369 --> 00:56:44,903
在这里还是几乎没有任何代码

1097
00:56:44,972 --> 00:56:48,373
现在它对于这两个常量都是完全可扩展的

1098
00:56:48,442 --> 00:56:52,711
一元作业。下一步是什么？二进制操作。

1099
00:56:52,780 --> 00:56:57,382
5乘3等于，好吧，难度更大，对吧？

1100
00:56:57,451 --> 00:57:01,286
因为当实际上有两个操作

1101
00:57:01,355 --> 00:57:05,323
5乘以3等于。有时间，这让你在这里

1102
00:57:05,392 --> 00:57:09,160
奇怪的等待状态，然后有等于

1103
00:57:09,229 --> 00:57:13,364
实际上完成了5乘以3等于，对吧？所以我

1104
00:57:13,433 --> 00:57:17,535
需要一些数据结构来记住5乘以

1105
00:57:17,604 --> 00:57:20,805
直到平等到来。好的，让我们这样做，

1106
00:57:20,874 --> 00:57:23,608
让我们添加一个数据结构。其实，在我们之前

1107
00:57:23,677 --> 00:57:26,945
这样做，让我们在这里备份，并谈论所有这些混乱。

1108
00:57:27,014 --> 00:57:29,848
这对于二进制操作会是什么样的？所以我们需要

1109
00:57:29,917 --> 00:57:34,753
这里是二进制操作。它的类型是什么？

1110
00:57:34,821 --> 00:57:39,491
它的相关价值是什么？你怎么看？

1111
00:57:41,295 --> 00:57:44,195
一个功能需要两个double的函数

1112
00:57:44,264 --> 00:57:47,432
返回一个double？好的，我们也需要

1113
00:57:47,500 --> 00:57:50,602
一个=等于的操作也。所以

1114
00:57:50,671 --> 00:57:53,438
我们可以在这里下来做例如乘以，

1115
00:57:53,507 --> 00:57:57,542
让我们做点乘法糟糕，空格，我们去。

1116
00:57:57,611 --> 00:58:01,747
我在这里有一个很好的数学乘符号。好的，

1117
00:58:01,815 --> 00:58:05,851
我们必须输入Operation.binaryOperation。和

1118
00:58:05,919 --> 00:58:09,821
我们基本上需要乘法。所以我要自己做

1119
00:58:09,890 --> 00:58:13,058
乘法函数。我们只是放在那里。

1120
00:58:13,126 --> 00:58:18,563
当然，我需要equals，即Operation.equals。

1121
00:58:18,632 --> 00:58:21,600
好的，把那些放在我的桌子上。所以这个倍增，

1122
00:58:21,668 --> 00:58:24,903
那是哪里没有称为乘法的函数。

1123
00:58:24,972 --> 00:58:26,605
好吧，就像我做的changeSign ，

1124
00:58:26,674 --> 00:58:28,406
我会创建我自己的小函数，

1125
00:58:28,475 --> 00:58:32,144
乘。这将是一个double的op1，

1126
00:58:32,213 --> 00:58:34,012
和op2，这是一个Double。和

1127
00:58:34,081 --> 00:58:39,451
当然会返回double。糟糕，和

1128
00:58:39,520 --> 00:58:41,954
它只会返回op1次op2，好吗？

1129
00:58:42,022 --> 00:58:45,190
所以我在这里得到了这个很好的功能。适合在这里很好，

1130
00:58:45,259 --> 00:58:48,727
没有错误，一切都很好，得到了。所以

1131
00:58:48,795 --> 00:58:52,898
现在我们有很大的一部分我们在做这件事情

1132
00:58:52,966 --> 00:58:56,701
这里是二进制操作？我们还有一个功能，

1133
00:58:56,770 --> 00:58:59,337
但现在这是一个需要两个double和返回的函数

1134
00:58:59,406 --> 00:59:04,042
是一个double，那我们在这里做什么？得到，

1135
00:59:04,111 --> 00:59:08,046
就像我说的，我们需要一些数据结构

1136
00:59:08,115 --> 00:59:09,848
记得5乘

1137
00:59:09,917 --> 00:59:13,518
等到我们得到另一个平等的情况，好吗？

1138
00:59:13,587 --> 00:59:16,187
我们在这里要做点什么。所以

1139
00:59:16,256 --> 00:59:19,758
让我们花点时间在这里创建另一个数据结构

1140
00:59:19,827 --> 00:59:22,994
在我们等待的时候记住五乘以

1141
00:59:23,063 --> 00:59:26,097
三等于发生。所以我要做一个结构。

1142
00:59:26,166 --> 00:59:29,434
它也将是一个嵌入式的私有结构，就像这样

1143
00:59:29,503 --> 00:59:33,805
被嵌入私有枚举。所以这个枚举的名字，

1144
00:59:33,874 --> 00:59:36,975
它的全名是CalculatorBrain.Operation，但是

1145
00:59:37,044 --> 00:59:39,410
只要我在这个结构体内使用它，

1146
00:59:39,479 --> 00:59:42,447
我们可以称之为操作，就像我们在这里一样。

1147
00:59:42,516 --> 00:59:44,315
好的，同样的事情在这里。

1148
00:59:44,384 --> 00:59:48,186
我要叫这个PendingBinaryOperation。

1149
00:59:48,255 --> 00:59:50,255
好的，这将是一个待定的二进制操作。

1150
00:59:50,324 --> 00:59:54,326
它会有两个vars。一个是函数

1151
00:59:54,395 --> 00:59:59,231
将要，需要两个double，返回一个double。和

1152
00:59:59,299 --> 01:00:03,368
这将是第一个操作数，这是一个double。

1153
01:00:03,437 --> 01:00:06,904
所以它只是一个拥有这两件事的结构体。

1154
01:00:06,973 --> 01:00:10,842
现在永远不会忘记Swift中的结构可以有方法和

1155
01:00:10,911 --> 01:00:11,877
像这样的东西。事实上，

1156
01:00:11,945 --> 01:00:13,745
我会在这里提出一个方法，只是提醒我们。

1157
01:00:13,814 --> 01:00:16,749
我会有一个叫做perform 的函数

1158
01:00:16,817 --> 01:00:19,684
执行这个二进制操作。现在是什么

1159
01:00:19,753 --> 01:00:23,689
它需要执行吗？它需要一个第二个操作数。

1160
01:00:26,126 --> 01:00:29,260
好的？它会返回一个double。好的，

1161
01:00:29,329 --> 01:00:32,497
现在，请注意这里的命名。为什么我使用这个命名，

1162
01:00:32,566 --> 01:00:36,735
作为我的外部和这里secondOperand作为我的内部？

1163
01:00:36,804 --> 01:00:38,336
嗯，secondOperand是内部的

1164
01:00:38,405 --> 01:00:40,071
因为这是这个论点。

1165
01:00:40,140 --> 01:00:42,574
在我的代码中，我想要第一个Operand和

1166
01:00:42,643 --> 01:00:44,643
secondOperand有正确的名字。但

1167
01:00:44,711 --> 01:00:47,713
我正在使用，因为当调用时，他们是

1168
01:00:47,781 --> 01:00:50,482
叫perform(with: 5.0)。而且当然，

1169
01:00:50,551 --> 01:00:53,284
如果他们正在执行待处理的二进制操作，那么

1170
01:00:53,353 --> 01:00:56,221
这是完美的意义。如果你说二进制操作，

1171
01:00:56,290 --> 01:01:00,859
perform(with: 5.0)。有道理吗？而这些

1172
01:01:00,928 --> 01:01:03,228
内部名称，即使它们只在内部使用，

1173
01:01:03,296 --> 01:01:05,797
您可以将它们视为文档的一部分。

1174
01:01:05,866 --> 01:01:08,833
Cuz看到这种方法的文档的任何人，

1175
01:01:08,902 --> 01:01:12,070
他会看到和第二个人，看吗？所以他们是

1176
01:01:12,139 --> 01:01:14,773
得到一点文档的那种

1177
01:01:14,841 --> 01:01:18,577
与第二个操作与这个二进制操作。

1178
01:01:18,645 --> 01:01:23,882
好的，我们怎么执行这个？嗯，我们只是

1179
01:01:23,951 --> 01:01:30,255
返回第一个操作时间第二个操作，好吗？但

1180
01:01:30,324 --> 01:01:33,525
我们在这里没有时间，我们正在做这个功能。

1181
01:01:33,593 --> 01:01:37,696
所以我会用第一个操作系统来调用它

1182
01:01:37,765 --> 01:01:40,799
和第二人。好的，这是一个非常简单的一点

1183
01:01:40,868 --> 01:01:42,667
方法，但我只是想清楚。

1184
01:01:42,736 --> 01:01:46,604
注意这个方法没有突变。因为

1185
01:01:46,673 --> 01:01:49,374
它实际上并没有改变PendingBinaryOperation，

1186
01:01:49,443 --> 01:01:52,044
对？它只是返回到函数的评估，

1187
01:01:52,112 --> 01:01:56,882
但它不会改变任何内部值。还要注意，

1188
01:01:56,951 --> 01:02:01,253
这些是让我们那是因为我要创造这个

1189
01:02:01,321 --> 01:02:04,256
在这两件事情之前，一直等待二进制操作

1190
01:02:04,325 --> 01:02:06,225
设置，我永远不会改变他们。

1191
01:02:06,293 --> 01:02:10,596
所以它们是这个结构体的常量。现在，还注意到，

1192
01:02:10,664 --> 01:02:13,398
没有错误，说你没有一个初始化程序和你

1193
01:02:13,467 --> 01:02:17,569
有这两个未初始化的变量。再次，这是一个结构体。

1194
01:02:17,637 --> 01:02:20,105
Structs自动获取一个免费的初始化程序

1195
01:02:20,174 --> 01:02:23,041
这将初始化所有这些事情。和

1196
01:02:23,109 --> 01:02:25,110
其实我们现在就用。

1197
01:02:25,178 --> 01:02:29,814
我要创建一个私有的var，我要叫pbo，

1198
01:02:29,883 --> 01:02:33,551
待定二进制操作，但只能暂时，因为

1199
01:02:33,620 --> 01:02:36,354
这是一个不好的名字。我主要是这样做，所以事情不会

1200
01:02:36,423 --> 01:02:38,890
包装，我使用一个大字体，所以你可以看到这里。我要去

1201
01:02:38,959 --> 01:02:41,726
实际上在一秒钟内将其改回一个更好的名字。

1202
01:02:41,795 --> 01:02:46,431
但是这个pbo是一个PendingBinaryOperation，

1203
01:02:46,500 --> 01:02:48,366
和可选项。

1204
01:02:48,435 --> 01:02:50,936
为什么这是一个可选的PendingBinaryOperation？

1205
01:02:51,004 --> 01:02:53,538
Cuz我们并不总是在二进制操作的中间

1206
01:02:53,607 --> 01:02:56,174
点击5乘以。好的，

1207
01:02:56,243 --> 01:02:57,575
如果我们说五平方根，

1208
01:02:57,644 --> 01:03:00,078
所以我们不在一个PendingBinaryOperation的中间

1209
01:03:00,147 --> 01:03:02,914
这不得不设定。你开始感受到了吗

1210
01:03:02,983 --> 01:03:05,250
我们如何在各地使用可选项，

1211
01:03:05,318 --> 01:03:09,354
在语义上正是我们的意思？和这里，

1212
01:03:09,423 --> 01:03:11,056
如果我们不在PendingBinaryOperation的中间，

1213
01:03:11,124 --> 01:03:14,893
这没有设置。所以这是一个可选的。好的，所以

1214
01:03:14,962 --> 01:03:17,128
当你按下时代的时候，

1215
01:03:17,197 --> 01:03:21,065
5次，所有我要在这里做的是记住，或创建，

1216
01:03:21,134 --> 01:03:23,068
一个待处理的二进制操作。

1217
01:03:23,137 --> 01:03:26,371
所以我要说pbo = PendingBinaryOperation。

1218
01:03:26,440 --> 01:03:30,942
现在当我在这里标签时，我做开放的括号。看，

1219
01:03:31,011 --> 01:03:34,446
这显示我已经有一个初始化程序，

1220
01:03:34,515 --> 01:03:37,682
一个，tab，取功能和firstOperand。

1221
01:03:37,751 --> 01:03:41,453
真厉害！所以这是免费的初始化器我得到，

1222
01:03:41,521 --> 01:03:45,224
因为我是一个结构在这里，而不是一个类。那是什么

1223
01:03:45,292 --> 01:03:47,792
功能？那就是这里的这个功能，

1224
01:03:47,861 --> 01:03:49,394
我们得到了我们的关联价值。

1225
01:03:49,463 --> 01:03:51,396
这是binaryOperation中的函数。

1226
01:03:51,465 --> 01:03:52,864
那第一个是什么？

1227
01:03:52,933 --> 01:03:55,567
那么这是我们现在的累加器，对，

1228
01:03:55,636 --> 01:04:00,639
五次是相等的，如果它是五，好吗？现在，

1229
01:04:00,708 --> 01:04:04,843
这里我打开它，所以如果accumulator

1230
01:04:04,912 --> 01:04:08,213
不等于零。 Cuz我不想在这里崩溃

1231
01:04:08,282 --> 01:04:10,983
我是，所以这意味着我会忽略乘以。如果你有

1232
01:04:11,051 --> 01:04:12,984
按时间，你没有给我一个操作数，

1233
01:04:13,053 --> 01:04:15,520
我们不会忽视。就像你启动你的

1234
01:04:15,588 --> 01:04:18,290
计算器和说，乘以3等于，我会忽略它，

1235
01:04:18,358 --> 01:04:21,426
因为我没有任何操作数。

1236
01:04:21,495 --> 01:04:25,530
好的，这样好，那就是我想要的。另外，当我

1237
01:04:25,599 --> 01:04:29,768
有这个时候，我要把我的累加器放在这里没有。

1238
01:04:29,837 --> 01:04:33,671
因为我在这个奇怪的五乘以，

1239
01:04:33,740 --> 01:04:35,874
我的累加器正在等待

1240
01:04:35,943 --> 01:04:38,410
三个等于设置为任何东西。

1241
01:04:38,479 --> 01:04:42,814
所以我现在把它设置为没有设置。好吧，

1242
01:04:42,882 --> 01:04:45,750
就这样，这就是当我们遇到时间时我需要做的。

1243
01:04:45,819 --> 01:04:49,454
但是现在当等于被点击时，我有3，而且

1244
01:04:49,523 --> 01:04:51,223
我需要计算5乘以3。

1245
01:04:51,292 --> 01:04:54,325
所以我需要在这里实际称这个perform 。所以

1246
01:04:54,394 --> 01:04:56,862
我会把它放在自己的小方法中。我打电话

1247
01:04:56,930 --> 01:05:01,133
它执行二进制操作，其实我们甚至会说

1248
01:05:01,201 --> 01:05:05,604
performPendingBinary，oops，BinaryOperation，好的。

1249
01:05:05,672 --> 01:05:06,638
我把它放在另一种方法中，

1250
01:05:06,707 --> 01:05:09,775
你会看到为什么在一会儿。好的，所以我要做私人的

1251
01:05:09,843 --> 01:05:14,513
func那是现在我在这里做什么？好

1252
01:05:14,581 --> 01:05:18,516
这里我要执行pendingBinaryOperation。所以

1253
01:05:18,585 --> 01:05:22,988
我会做pbo.perform，我要做什么？

1254
01:05:23,057 --> 01:05:26,591
我要用当前的累加器执行，好吗？

1255
01:05:26,660 --> 01:05:30,662
现在注意到这里有一个问号，好吗？

1256
01:05:30,731 --> 01:05:32,231
我需要一个问号的原因，真的，

1257
01:05:32,299 --> 01:05:35,767
我想要的是感叹号。因为pbo，在这里，

1258
01:05:35,836 --> 01:05:38,103
是一个可选的，我需要解包。

1259
01:05:38,172 --> 01:05:40,773
但真的很酷的是，如果不是感叹号，

1260
01:05:40,841 --> 01:05:44,410
你提出问号，那么它会解开它，但是

1261
01:05:44,478 --> 01:05:47,479
它没有设置，它只会忽略这一行。

1262
01:05:47,548 --> 01:05:51,216
忽略线的其余部分，好吗？所以

1263
01:05:51,284 --> 01:05:53,185
这是一个很酷的功能。但我不会这样做，

1264
01:05:53,254 --> 01:05:55,353
嗯，我没有真的谈论足够，所以

1265
01:05:55,422 --> 01:05:58,523
我要解包所以在这里我需要确保pbo不是

1266
01:05:58,591 --> 01:06:02,327
零。而且我也需要确保accumulator 也是

1267
01:06:02,395 --> 01:06:05,463
不是零，好吗？所以如果这两件事情不正确，

1268
01:06:05,532 --> 01:06:06,899
我真的不想成为

1269
01:06:06,967 --> 01:06:08,967
在这里做这行代码，

1270
01:06:09,035 --> 01:06:11,737
对？所以我实现了，我得到的结果和

1271
01:06:11,806 --> 01:06:16,141
我要把它放在我的accumulator里，好吗？

1272
01:06:16,210 --> 01:06:21,146
所以我的accumulator不再是零，为什么会这样呢？

1273
01:06:21,215 --> 01:06:24,716
这是第三次，变异，好，优秀，

1274
01:06:24,785 --> 01:06:28,153
当人们快速赶上时，我喜欢它。那么，是的

1275
01:06:28,222 --> 01:06:30,288
需要变异，这是改变累加器(accumulator)。

1276
01:06:30,357 --> 01:06:33,325
所以它修改了计算器大脑的内部状态。

1277
01:06:33,394 --> 01:06:36,828
现在，另一件事已经不再是我的中间了

1278
01:06:36,897 --> 01:06:39,231
的一个pendingBinaryOperation，所以我必须设置为nil。

1279
01:06:40,468 --> 01:06:42,900
好的，我想我一切都一致

1280
01:06:42,969 --> 01:06:45,604
代码，当这个没有，我不在一个待定的中间

1281
01:06:45,673 --> 01:06:49,608
操作。我只是三个等于，好的，

1282
01:06:49,677 --> 01:06:53,945
大家设置？现在，我告诉你，我不喜欢pbo作为一个名字。

1283
01:06:54,014 --> 01:06:56,648
这是一个坏名字，好吗？看着它的人​​必须要走了

1284
01:06:56,717 --> 01:06:58,316
看看这个声明吧。

1285
01:06:58,385 --> 01:07:01,386
这里一个更好的名字将是pendingBinaryOperation，所以

1286
01:07:01,455 --> 01:07:04,522
我会改变它。这就是你可以改变的方式

1287
01:07:04,591 --> 01:07:07,058
在整个上下文中的东西的名称

1288
01:07:07,127 --> 01:07:08,760
它在。你只是鼠标在它，

1289
01:07:08,829 --> 01:07:10,395
我没有点击它，鼠标放在上面。

1290
01:07:10,464 --> 01:07:13,598
你看到那个出现的小箭头？如果你点击它

1291
01:07:13,667 --> 01:07:17,001
你会得到一个菜单，你可以说，在范围内编辑全部。和

1292
01:07:17,070 --> 01:07:22,674
现在当你改变这个，它正在改变它到处。好的，

1293
01:07:22,742 --> 01:07:25,077
所以我把它从pbo改成了PendingBinaryOperation。

1294
01:07:25,145 --> 01:07:27,946
你可以看到为什么我这样做，因为我不想要

1295
01:07:28,015 --> 01:07:31,416
当我们第一次这样做时，包装会发生，好吗？

1296
01:07:31,485 --> 01:07:34,085
就这样，这就是我们需要做的

1297
01:07:34,154 --> 01:07:36,721
我们的小Pending BinaryOperation，所以

1298
01:07:36,790 --> 01:07:40,626
让我们继续添加一些等待，一些二进制，所以让我们来

1299
01:07:40,694 --> 01:07:43,928
在我们的UI中添加一些二进制操作。其实我要去了

1300
01:07:43,997 --> 01:07:46,264
添加一些我们甚至没有在我们的表中。

1301
01:07:46,333 --> 01:07:51,003
所以让我们做一些时间，在空间上来。

1302
01:07:51,071 --> 01:07:54,839
是的，这样的时候，但我也要去做另一个

1303
01:07:54,908 --> 01:07:58,476
这里的分歧和加号，只是我们不必

1304
01:07:58,545 --> 01:08:03,148
再来这里再来这样做。所以有分歧，

1305
01:08:03,216 --> 01:08:08,120
那里，我会做另一个，做加号和

1306
01:08:08,189 --> 01:08:13,491
减去这里。所以我在做命令控制空间，

1307
01:08:13,560 --> 01:08:17,729
我想，要得到这个小emojis和

1308
01:08:17,798 --> 01:08:23,769
符号事物和加号，好吗？

1309
01:08:23,837 --> 01:08:28,607
而我们需要另外一件事，平等，就必须有平等

1310
01:08:28,676 --> 01:08:32,844
按钮。所以我们把它放在那里，好吗？所以现在我们只有

1311
01:08:32,913 --> 01:08:35,580
有时间，所以时间是唯一应该工作的人，但是

1312
01:08:35,649 --> 01:08:38,450
让我们来看看。其实我会把代码带回来

1313
01:08:38,518 --> 01:08:42,520
你可以同时看到它。很难看到这一切

1314
01:08:42,589 --> 01:08:46,658
一次，但。好吧，我们走吧，好吗？

1315
01:08:46,726 --> 01:08:50,161
4平方根，那还在工作，pi，还在工作。

1316
01:08:50,230 --> 01:08:56,201
8乘以6等于，wahoo，平方根？

1317
01:08:56,269 --> 01:09:00,939
好的，好的，所以时间正在精美的工作。

1318
01:09:01,008 --> 01:09:03,575
现在唯一的是，我们要做分歧

1319
01:09:03,644 --> 01:09:06,478
所有这一切，所以我想我要做的是，

1320
01:09:06,547 --> 01:09:09,747
我去四乘以

1321
01:09:09,816 --> 01:09:14,720
这里再次和Ctrl + Space再次，我们会做分歧。和

1322
01:09:14,788 --> 01:09:19,324
我们会去这里Ctrl + Space，我们会做的。和

1323
01:09:19,392 --> 01:09:23,361
那么我们要去这里，我们会做命令，空间和

1324
01:09:23,430 --> 01:09:26,898
我们会做减号，好吗？现在我要写了，

1325
01:09:26,967 --> 01:09:29,467
写一个方法分开，在这里和

1326
01:09:29,536 --> 01:09:32,871
复制并贴上这个并做一个划分？你懂，

1327
01:09:32,939 --> 01:09:35,674
如果我必须这样做，突然间，我感觉像，

1328
01:09:35,743 --> 01:09:38,210
这整个桌子的业务真的没有买到我

1329
01:09:38,278 --> 01:09:41,313
好吗？ Cuz我还是要创建一个方法

1330
01:09:41,381 --> 01:09:44,082
我想做的每一个二进制操作？我的意思是

1331
01:09:44,151 --> 01:09:47,085
一致的操作是很好的，因为我已经建立了所有这些

1332
01:09:47,153 --> 01:09:50,388
在那些，我确实必须做这个一个方法。是的，我可以

1333
01:09:50,457 --> 01:09:52,958
甚至看到一致的操作，我想创造一堆更多

1334
01:09:53,027 --> 01:09:54,826
我必须创建这些其他功能。

1335
01:09:54,895 --> 01:09:56,795
这不是真的为我工作。

1336
01:09:56,864 --> 01:10:00,932
好的，我们怎么解决这个问题？那我们要用了

1337
01:10:01,001 --> 01:10:04,736
Swift中的一个功能非常强大。

1338
01:10:04,805 --> 01:10:06,204
你必须习惯它，

1339
01:10:06,273 --> 01:10:07,706
cuz它不是很多其他语言。

1340
01:10:07,775 --> 01:10:08,574
它是在其他一些语言，

1341
01:10:08,642 --> 01:10:09,975
我不想让它听起来像不在周围，

1342
01:10:10,043 --> 01:10:13,078
这绝对是在。但可能不是你所拥有的东西

1343
01:10:13,147 --> 01:10:16,882
用于您使用的任何语言，它被称为关闭。

1344
01:10:16,951 --> 01:10:18,783
好的，有多少人知道关闭是什么，

1345
01:10:18,852 --> 01:10:19,651
以前听过吗？

1346
01:10:19,719 --> 01:10:24,556
看到，几乎没有人，所以关闭是一个功能

1347
01:10:24,624 --> 01:10:29,394
嵌入你的代码行，好吗？所以，

1348
01:10:29,463 --> 01:10:33,665
我们实际上可以在这里乘法，选择它的代码。

1349
01:10:33,734 --> 01:10:38,737
我要剪它，下到这里我使用它

1350
01:10:38,805 --> 01:10:41,973
粘贴在那里现在如果不行，

1351
01:10:42,042 --> 01:10:45,744
我们需要做两件事情。一个，这个开放的大括号

1352
01:10:45,813 --> 01:10:50,348
需要在一开始所以，我们要去

1353
01:10:50,417 --> 01:10:54,453
将这个打开的大括号替换为关键字in和

1354
01:10:54,522 --> 01:10:56,855
把大括号放在开头。所以

1355
01:10:56,923 --> 01:10:59,691
这就是你的函数，并把它放在一起。

1356
01:10:59,760 --> 01:11:02,427
只是字面上复制和粘贴写在那里。

1357
01:11:02,496 --> 01:11:05,997
将大括号更改为in并将其移动到开头，

1358
01:11:06,066 --> 01:11:09,635
好的，得到了所以现在我们甚至不需要乘法，

1359
01:11:09,703 --> 01:11:13,839
全没了。现在看起来好像不太好

1360
01:11:15,242 --> 01:11:17,742
但还是打了很多东西，

1361
01:11:17,811 --> 01:11:24,015
让我们使用Swift的类型推论，使这个更好。

1362
01:11:24,084 --> 01:11:29,288
swift知道，这就是这里，

1363
01:11:29,356 --> 01:11:33,358
该类型的关联值。所以知道这个

1364
01:11:33,426 --> 01:11:36,261
这里是一个需要两个double的函数

1365
01:11:36,330 --> 01:11:40,298
返回一个double。所以我们在这里不需要这些类型，

1366
01:11:40,367 --> 01:11:43,134
摆脱那些。好的，

1367
01:11:43,203 --> 01:11:45,037
现在开始看起来更好。事实上，

1368
01:11:45,105 --> 01:11:49,908
也许如果我去这里把一些东西放在同一条线上。

1369
01:11:53,480 --> 01:11:56,615
是的，现在我很喜欢，好的。但我们可以做得更好

1370
01:11:56,684 --> 01:12:00,953
这个。Swift也知道这会返回一些东西。

1371
01:12:01,021 --> 01:12:05,424
所以我们不推翻，好的。Swift也会让你有

1372
01:12:05,492 --> 01:12:09,594
你想要的任何数量的论据。称为$ 0，$ 1，$ 2 $ 3，

1373
01:12:09,663 --> 01:12:12,864
然而有多少。所以我不需要那个。

1374
01:12:12,932 --> 01:12:17,770
我可以说$ 0的$ 1。

1375
01:12:19,807 --> 01:12:24,409
好的，现在我赢了。现在，

1376
01:12:24,477 --> 01:12:27,513
这里发生的一切事情就在这里。

1377
01:12:27,581 --> 01:12:29,481
而且没有无关的类型和

1378
01:12:29,550 --> 01:12:31,983
所有的业务。当然，这意味着

1379
01:12:32,052 --> 01:12:36,087
这些其他的情况就像分裂，我可以说分歧。

1380
01:12:36,156 --> 01:12:40,992
另外，在这里我可以看到加，减去，

1381
01:12:41,061 --> 01:12:45,163
我可以做减法，即使我们的朋友在这里改变标志。

1382
01:12:45,232 --> 01:12:49,101
好的，我们可以把这个副本粘贴，

1383
01:12:49,169 --> 01:12:54,506
摆脱所有这些垃圾，因为这只是 -  $ 0，

1384
01:12:54,574 --> 01:13:01,479
好的？所以，这个关闭让你做这个事情在哪里

1385
01:13:01,548 --> 01:13:04,749
你在那里得到你正在做的事情的基本要素

1386
01:13:04,818 --> 01:13:07,419
一致。所以，你不必去看别的

1387
01:13:07,488 --> 01:13:09,788
方法在某个地方像change在这里。

1388
01:13:09,857 --> 01:13:13,558
关闭的另一件事允许你做，是要传递给

1389
01:13:13,627 --> 01:13:18,296
方法一些代码执行，如果某些失败，

1390
01:13:18,365 --> 01:13:21,966
或当某事完成时。或者这样做和

1391
01:13:22,035 --> 01:13:24,636
例如，当你在做这件事时，你可以动画化。你会去

1392
01:13:24,705 --> 01:13:27,439
看到这样的API。所以，能够通过这些方法

1393
01:13:27,507 --> 01:13:31,276
周围，​​你会看到。真的是伟大的，伟大的

1394
01:13:31,344 --> 01:13:34,145
API。所以，你只是看到最简单的使用

1395
01:13:34,214 --> 01:13:37,448
在这里。我们只是用作相关值，但是想象一下

1396
01:13:37,517 --> 01:13:40,084
它作为功能，参数和类似的东西。它的，

1397
01:13:40,153 --> 01:13:43,922
这很不可思议好的，让我们去看看是否有效。

1398
01:13:52,166 --> 01:13:57,001
好的，4 x 5 = 20，平方根，余弦，

1399
01:13:57,070 --> 01:14:03,074
改变标志，pi，余弦，这一切都很漂亮。

1400
01:14:03,143 --> 01:14:06,278
现在，我们可以添加我们想要的新操作，

1401
01:14:06,347 --> 01:14:10,715
每行一行，好的。所以，你看到我如何构建一个结构体

1402
01:14:10,784 --> 01:14:13,385
这里是可扩展的，无需进行子分类，而且

1403
01:14:13,453 --> 01:14:16,054
所有的东西我可以添加东西，甚至可以去

1404
01:14:16,122 --> 01:14:19,791
进一步使公众。如果我做这个操作

1405
01:14:19,860 --> 01:14:23,561
表公开。我也要做运营公开，

1406
01:14:23,630 --> 01:14:27,666
那么其他人可以得到我的计算器脑int和

1407
01:14:27,735 --> 01:14:31,603
添加操作，好吗？真是太，

1408
01:14:31,671 --> 01:14:36,140
非常明智，不需要任何子类化。

1409
01:14:36,209 --> 01:14:38,577
所以，结构通常可以一样好，

1410
01:14:38,645 --> 01:14:41,547
如果不是一点点更好的设计点

1411
01:14:41,615 --> 01:14:45,851
类。好的，我想在这里做的最后一件事。

1412
01:14:45,919 --> 01:14:50,955
我们回到我们的模拟器。是谈论

1413
01:14:51,024 --> 01:14:54,726
UI的布局。你看到我有这个布局在这里。

1414
01:14:54,795 --> 01:14:57,662
我们来看看如果我把它旋转成景观会发生什么

1415
01:14:57,731 --> 01:15:01,166
模式。所以，我会在模拟器上上去，

1416
01:15:01,234 --> 01:15:04,870
转到硬件，向左旋转。好的，我的计算器是

1417
01:15:04,938 --> 01:15:08,507
现在完全无法使用好吧，cuz没有平等的，所以

1418
01:15:08,575 --> 01:15:10,909
我甚至不能做三次平等的五次，对不对？所以

1419
01:15:10,977 --> 01:15:13,411
这完全没用，我想我还可以做pi，

1420
01:15:13,480 --> 01:15:16,247
毫米，但很明显，这不是你想要的，对吧？

1421
01:15:16,316 --> 01:15:20,652
当你旋转时，你想以这种方式使用那个空间，好吗？

1422
01:15:20,721 --> 01:15:23,555
我答应你，我们将要建立一个UI

1423
01:15:23,624 --> 01:15:24,789
在所有这些事情上工作，事实上，

1424
01:15:24,858 --> 01:15:28,127
我们现在要这样做。我们回到我们的UI，

1425
01:15:28,195 --> 01:15:31,063
这样做不会要求任何改变

1426
01:15:31,131 --> 01:15:33,098
我们的控制器或我们的模型好的，

1427
01:15:33,166 --> 01:15:35,734
这纯粹是我们在视图中所做的事情

1428
01:15:35,802 --> 01:15:38,837
我们将在这里做这件事情。好的，

1429
01:15:38,906 --> 01:15:41,840
这个多个手机，我们可以点击这里，

1430
01:15:41,909 --> 01:15:43,575
看看所有这些不同的东西

1431
01:15:43,644 --> 01:15:46,811
方向在这里。并出发基本策略

1432
01:15:46,880 --> 01:15:51,049
我们将把所有这些按钮堆叠成行，然后

1433
01:15:51,118 --> 01:15:54,953
我们将把所有这些行堆叠在一起。

1434
01:15:55,021 --> 01:15:58,257
然后我们将用显示器来叠加

1435
01:15:58,325 --> 01:16:02,294
这种块有我们的UI。然后我们要打结

1436
01:16:02,362 --> 01:16:06,698
该块的边缘到设备的边缘。所以，

1437
01:16:06,767 --> 01:16:10,636
随着设备的变化，这块东西，得到

1438
01:16:10,704 --> 01:16:13,939
伸展，或任何。而里面的东西，

1439
01:16:14,007 --> 01:16:17,142
现在会自动调整按钮的大小和

1440
01:16:17,210 --> 01:16:20,112
东西布局。好的，这就是我们需要做的一切

1441
01:16:20,180 --> 01:16:23,214
做到这一点。要在这里有漂亮的行和列，

1442
01:16:23,283 --> 01:16:25,984
我要添加一个你需要的按钮

1443
01:16:26,052 --> 01:16:29,487
你的家庭作业呢哪个是点按钮你的一个

1444
01:16:29,556 --> 01:16:33,324
作业分配项目，是做浮点输入

1445
01:16:33,393 --> 01:16:35,727
可能。这已经是一个浮点计算器。

1446
01:16:35,796 --> 01:16:39,431
我可以说4，45，我不能在这里输入，对不起。

1447
01:16:39,500 --> 01:16:41,699
但是我可以输入45并打平方根。和

1448
01:16:41,768 --> 01:16:43,902
它会给我一个浮点数，对吧？

1449
01:16:43,971 --> 01:16:45,837
但是您不能输入任何浮点数，

1450
01:16:45,906 --> 01:16:47,639
'cuz没有小数点，对吧？所以，

1451
01:16:47,708 --> 01:16:48,506
这是你的任务的一部分。

1452
01:16:48,575 --> 01:16:51,710
所以，我会把它放在那里。好的，现在，

1453
01:16:51,779 --> 01:16:55,614
我要去这一排。我会把它放在一堆。

1454
01:16:55,682 --> 01:16:58,116
它的侧面将是一个水平堆叠。你做的

1455
01:16:58,185 --> 01:17:03,922
在这里与编辑。嵌入堆栈视图，好吗？

1456
01:17:03,990 --> 01:17:07,559
所以，当我这样做，看，它把它们水平堆叠。

1457
01:17:07,627 --> 01:17:10,762
我可以检查该堆栈，它在这里选择。

1458
01:17:10,830 --> 01:17:14,065
你可以看到Stack View，它是水平的。

1459
01:17:14,134 --> 01:17:17,902
我会在那里放一些间距，10点间距。

1460
01:17:17,971 --> 01:17:20,872
我也要确保他们是等距的。

1461
01:17:20,941 --> 01:17:24,142
所以，我希望在那里的每个正方形的宽度相同。

1462
01:17:24,211 --> 01:17:26,979
好的，同样的事情在这里。我们走这个吧

1463
01:17:27,047 --> 01:17:29,047
现在，除了这里，还有另外一种方法，

1464
01:17:29,115 --> 01:17:31,883
编辑器，嵌入。这里有一个按钮。所以

1465
01:17:31,952 --> 01:17:34,119
常见的，那里有一个按钮，嵌入在堆栈，

1466
01:17:34,187 --> 01:17:38,090
所以繁荣，我会这样做。再次，我会在这里放一个空间。

1467
01:17:38,158 --> 01:17:41,326
请注意，余弦按钮比1,2，3宽。

1468
01:17:41,394 --> 01:17:43,728
所以，我会说平等地填写

1469
01:17:43,797 --> 01:17:46,265
使它们全部相同的宽度再次，

1470
01:17:49,269 --> 01:17:53,772
哎呀，对不起，我们再做10，

1471
01:17:53,841 --> 01:17:58,343
平均填充同样的事情在这里

1472
01:17:58,411 --> 01:18:02,314
叠加。填平均10，我们将堆叠这一个。

1473
01:18:07,887 --> 01:18:12,624
哎呀，不好意思好的，现在我要采取这些横向

1474
01:18:12,693 --> 01:18:16,194
栈。这五个水平并垂直堆叠。所以，

1475
01:18:16,263 --> 01:18:19,731
我要嵌入注意这很聪明

1476
01:18:19,800 --> 01:18:20,965
它注意到他们在彼此之间

1477
01:18:21,034 --> 01:18:23,301
它会自动将其放在垂直堆栈中。但，

1478
01:18:23,370 --> 01:18:25,837
它把它们全部推到了堆栈的左边，而我

1479
01:18:25,906 --> 01:18:29,107
希望他们跨越堆栈分散。所以，我会有

1480
01:18:29,176 --> 01:18:34,179
这里的对齐，而不是领导，填补和

1481
01:18:34,247 --> 01:18:36,882
这将填补整个宽度。当然我想要

1482
01:18:36,950 --> 01:18:39,718
间隔在这里，所以我们这样做。所以看这个，

1483
01:18:39,787 --> 01:18:42,553
我有这个美丽的键盘，键盘在这里

1484
01:18:42,622 --> 01:18:47,292
我的计算器现在，我要挂钩这个显示。

1485
01:18:47,361 --> 01:18:48,760
我会选择他们，而且

1486
01:18:48,829 --> 01:18:52,865
说他们堆叠好吧，把它们放进栈左边

1487
01:18:52,933 --> 01:18:55,267
线重新对齐，导致它在那里对齐

1488
01:18:55,336 --> 01:18:59,437
我会说填充，我不想在这里平均填写。

1489
01:18:59,506 --> 01:19:02,507
如果我在这里平均填充，那么它会显示出来

1490
01:19:02,576 --> 01:19:04,776
与整个键盘相同的高度，所以

1491
01:19:04,845 --> 01:19:06,344
我不想要所以我只想填，

1492
01:19:06,413 --> 01:19:08,980
我想填补这个空间，但我确实希望这里的间距

1493
01:19:09,049 --> 01:19:12,985
我们再做10分。所以，现在我的整个UI在一个很好的

1494
01:19:13,053 --> 01:19:16,855
整个矩形在这里。我只是把边缘，

1495
01:19:18,759 --> 01:19:23,996
的这个UI到设备的边缘基本上没关系。

1496
01:19:24,064 --> 01:19:26,898
现在，我要从这里开始，哎呀，我要开始了，是的

1497
01:19:26,967 --> 01:19:29,601
也要小心一点。如果你点击某事

1498
01:19:29,670 --> 01:19:32,470
并拖动它，看到你可能会尝试拖动内部的一个。

1499
01:19:32,539 --> 01:19:34,539
一个不这样做的伎俩，有两个技巧。

1500
01:19:34,608 --> 01:19:39,611
一个，你可以做命令转变我相信是，是的。

1501
01:19:39,679 --> 01:19:41,980
命令转移将让你选择你想要哪一个，

1502
01:19:42,048 --> 01:19:44,415
在鼠标下。

1503
01:19:44,484 --> 01:19:47,052
鼠标下的控制移位让你选择它。但，

1504
01:19:47,121 --> 01:19:49,888
另一个简单的方法是使用拖动选择，

1505
01:19:49,957 --> 01:19:52,056
选择你想要的，然后拿起它。

1506
01:19:52,125 --> 01:19:56,395
好的，所以我要用蓝线，实际上放

1507
01:19:56,463 --> 01:19:59,164
这在左边缘和顶部的适当空间。

1508
01:19:59,232 --> 01:20:03,435
现在我要做魔术把它挂到边缘。和

1509
01:20:03,504 --> 01:20:06,437
我用Ctrl键做到这一点，就像我们拖动的一样

1510
01:20:06,506 --> 01:20:10,308
代码。但是在这里，我会从这个选择的东西中拖出来。

1511
01:20:10,377 --> 01:20:12,344
确保整个事情被选中。和

1512
01:20:12,413 --> 01:20:16,615
Ctrl +拖动到顶部。所以我们可以把它绑在顶端。

1513
01:20:16,684 --> 01:20:18,850
当你放开时，它会说，

1514
01:20:18,919 --> 01:20:22,053
你想在这个大盒子之间有什么关系

1515
01:20:22,122 --> 01:20:26,791
顶端？而且，真的在谈论外缘。

1516
01:20:26,860 --> 01:20:28,626
你可以尝试使它们的宽度相同，或者

1517
01:20:28,695 --> 01:20:30,628
相同的高度，这在这里真的没有意义。

1518
01:20:30,697 --> 01:20:33,565
或者您可以将此垂直间距固定在顶部

1519
01:20:33,634 --> 01:20:34,532
布局指南。

1520
01:20:34,601 --> 01:20:37,770
所以我基本上把它固定在顶部。同样的事情在这里，

1521
01:20:37,838 --> 01:20:41,840
我可以去左边和领先的空间。和

1522
01:20:41,909 --> 01:20:45,543
我可以去右边和针脚，把尾随的空间钉住。和

1523
01:20:45,612 --> 01:20:50,616
我可以到底，对不起，是的，底部和

1524
01:20:50,684 --> 01:20:53,585
引脚底部空间，底部垂直空间。

1525
01:20:53,654 --> 01:20:56,822
现在我们只是把它固定在边缘，但你可以使用

1526
01:20:56,890 --> 01:21:00,058
这个机制来Ctrl +拖动任意两个元素之间

1527
01:21:00,127 --> 01:21:03,428
说这两个相同的宽度，排列在左边缘，

1528
01:21:03,497 --> 01:21:04,429
排成一排。

1529
01:21:04,498 --> 01:21:05,897
你看我在说什么和

1530
01:21:05,966 --> 01:21:10,102
一旦你拥有了所有的物品都有规则的能力

1531
01:21:10,170 --> 01:21:12,671
他们之间的关系，现在你可以想象如何

1532
01:21:12,739 --> 01:21:16,174
你可以旋转整个东西，让它看起来都很好，

1533
01:21:16,243 --> 01:21:19,010
因为它遵循如何做的规则。

1534
01:21:19,079 --> 01:21:22,647
现在有一件事关于这两个针，好的，我固定的那些

1535
01:21:22,716 --> 01:21:25,650
我想要他们但是这两个针不是我想要的。

1536
01:21:25,719 --> 01:21:28,320
它远离了边缘。所以

1537
01:21:28,388 --> 01:21:30,822
我该如何解决？你实际上可以双击它。

1538
01:21:30,891 --> 01:21:32,890
如果双击这个I-beam，

1539
01:21:32,959 --> 01:21:36,962
它说，是的，我把这113点从边缘钉住。和

1540
01:21:37,030 --> 01:21:40,032
你可以在这里去尝试选择标准价值。

1541
01:21:40,100 --> 01:21:42,601
但是这很灰暗，所以我们要使用0。

1542
01:21:42,669 --> 01:21:46,104
所以你几乎想要标准价值，如果有的话，

1543
01:21:46,172 --> 01:21:47,939
或0.所以在这种情况下，

1544
01:21:48,008 --> 01:21:52,844
0表示从这个布局指南边缘的0点，好吗？和

1545
01:21:52,913 --> 01:21:55,280
同样的事情与这一个在这里，我会双击。

1546
01:21:55,349 --> 01:21:57,950
顺便说一句，我们也可以看到这些东西，好吗？

1547
01:21:58,018 --> 01:22:01,386
如果我们选择这个，我们可以去大小检查员。

1548
01:22:01,455 --> 01:22:04,189
你可以在这里看到所有这些东西，

1549
01:22:04,258 --> 01:22:07,492
好的，所有这些连接到边缘，对吧？

1550
01:22:07,561 --> 01:22:10,929
看到这个301.所以我要双击这个

1551
01:22:10,998 --> 01:22:14,299
工字梁，在这里，标准值可用。所以我

1552
01:22:14,368 --> 01:22:17,669
要选择标准值，好吗？它放在那里

1553
01:22:17,737 --> 01:22:20,806
现在，他们把它绑在底部，把它伸出来。

1554
01:22:20,874 --> 01:22:23,609
现在，我们并没有像这样想，

1555
01:22:23,677 --> 01:22:27,545
对？所以其中一些，里面的行，

1556
01:22:27,614 --> 01:22:30,048
我们没有得到正确的属性。

1557
01:22:30,116 --> 01:22:32,951
所以让我们回去检查一下。我们平均地填满了，

1558
01:22:33,019 --> 01:22:36,187
水平地，他们都是吗？我们做，对吧？

1559
01:22:36,256 --> 01:22:40,258
这怎么样？这里我要用Ctrl +点击。

1560
01:22:40,327 --> 01:22:44,029
我们将选择这个堆栈视图。看到这一个，好的，

1561
01:22:44,097 --> 01:22:47,499
这是这个内在的，也想平均地填补，

1562
01:22:47,568 --> 01:22:50,769
对？我们想要所有这些行，不包括这个顶级的人，

1563
01:22:50,838 --> 01:22:53,338
但所有这些内部的内部行都是一样的。

1564
01:22:53,407 --> 01:22:58,109
所以我要等到这里去填补这个，

1565
01:22:58,178 --> 01:23:01,447
好的？所以现在我有这个可以伸展的东西，

1566
01:23:01,515 --> 01:23:04,115
因为它有这些堆栈有规则

1567
01:23:04,184 --> 01:23:07,952
如何填写然后我把它们挂在边缘，所以

1568
01:23:08,021 --> 01:23:11,389
现在当我切换方向时，它会调整，

1569
01:23:11,458 --> 01:23:17,762
即使我去一个较小的设备，好吗？要么

1570
01:23:17,831 --> 01:23:22,534
一个大的设备。现在有一件事了

1571
01:23:22,602 --> 01:23:26,004
有趣的是最小的设备，一个iPhone 4，

1572
01:23:26,072 --> 01:23:29,641
在这个方向上，它不能适应所有的东西。您

1573
01:23:29,710 --> 01:23:34,279
看到那个显示器是，它不能适应它。所以这是

1574
01:23:34,348 --> 01:23:36,515
为什么在界面构建器中可以看到这一点，

1575
01:23:36,584 --> 01:23:39,517
我们可以回到这里，选择一个较小的字体

1576
01:23:39,586 --> 01:23:42,153
例。我们甚至可以，你知道，我们的字体是

1577
01:23:42,222 --> 01:23:45,224
变量，但是没有办法自动使用字体

1578
01:23:45,292 --> 01:23:48,426
沮丧，不幸的是。没有自动收缩

1579
01:23:48,495 --> 01:23:51,596
像标签那样的按钮。很抱歉

1580
01:23:51,665 --> 01:23:54,266
但是，我们会选择一个更小的字体，这将会在所有的工作

1581
01:23:54,335 --> 01:23:57,936
我们的平台可能还好吗？好的，所以我们有这个。

1582
01:23:58,005 --> 01:24:01,472
而且，当然，如果我们在模拟器中运行，我们可以这样做

1583
01:24:01,541 --> 01:24:05,210
在模拟器中旋转它，并看到它在那里工作。

1584
01:24:05,278 --> 01:24:07,645
如果我们有一个设备，我们可以在我们的设备上运行它

1585
01:24:07,714 --> 01:24:09,380
在那里做所以我们走吧。这是我们的iPhone 7。

1586
01:24:09,449 --> 01:24:12,451
7乘以9等于。它还在工作

1587
01:24:12,520 --> 01:24:14,586
平方根，那很好。当我们旋转时，

1588
01:24:14,655 --> 01:24:16,554
顺便说一下，我要用Command键旋转。

1589
01:24:16,623 --> 01:24:19,557
好吧，命令左右箭头，你会看到它

1590
01:24:19,626 --> 01:24:22,060
这里的左下角，但旋转命令。

1591
01:24:22,129 --> 01:24:27,399
看到那个好的，所以你可以看到我们不得不做的很少

1592
01:24:27,468 --> 01:24:30,702
使这个东西适应。而这是一个相当简单的UI，

1593
01:24:30,771 --> 01:24:32,938
很多矩形。更复杂的UI，

1594
01:24:33,007 --> 01:24:36,041
我们会做一点点在大约五，四，四

1595
01:24:36,109 --> 01:24:39,611
五，我会详细介绍一下我们如何构建这些，甚至

1596
01:24:39,679 --> 01:24:42,447
对于复杂的UI，我们如何构建这些可旋转的东西，

1597
01:24:42,516 --> 01:24:45,951
好的，就这样。你的家庭作业

1598
01:24:46,019 --> 01:24:48,353
基本上是为了再现我在前两个中所做的

1599
01:24:48,422 --> 01:24:50,255
讲座，然后再添加几件事情。

1600
01:24:50,324 --> 01:24:53,391
在那里添加一个小标签，添加一些按钮，更改一些

1601
01:24:53,460 --> 01:24:56,662
颜色，那种生意，很简单。

1602
01:24:56,730 --> 01:24:59,497
使其与浮点输入和

1603
01:24:59,566 --> 01:25:02,901
这是下个星期三。我在这里，如果你有问题，

1604
01:25:02,969 --> 01:25:05,804
然后我会看到你。 >>更多，

1605
01:25:05,873 --> 01:25:14,379
请访问我们的stanford.edu。


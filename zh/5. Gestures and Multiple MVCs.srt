1
00:00:00,668 --> 00:00:08,807
>>斯坦福大学

2
00:00:08,876 --> 00:00:12,210
>>欢迎来到斯坦福CS193P，

3
00:00:12,279 --> 00:00:16,114
开发iOS应用程序，2017年冬季。

4
00:00:16,183 --> 00:00:18,650
这是第五节课？

5
00:00:18,719 --> 00:00:20,251
是对的吗？第五节课

6
00:00:20,320 --> 00:00:21,453
是的，第五课。

7
00:00:22,790 --> 00:00:25,990
今天我们要开始一个小的演示，

8
00:00:26,059 --> 00:00:29,594
我们继续上次的那个应用

9
00:00:29,663 --> 00:00:31,763
并添加一个model。

10
00:00:31,831 --> 00:00:34,999
Cuz，我们只是看了一部分，

11
00:00:35,068 --> 00:00:37,036
建立好酷的FaceView，

12
00:00:37,104 --> 00:00:40,305
现在我们要为该MVC增加一个模型。

13
00:00:40,374 --> 00:00:42,841
然后我们要回到幻灯片

14
00:00:42,910 --> 00:00:45,477
我将在手势上做一些幻灯片。

15
00:00:45,545 --> 00:00:49,013
显然，您希望能够输入到您的应用程序，

16
00:00:49,082 --> 00:00:50,915
你需要知道如何做多点触摸手势，

17
00:00:50,984 --> 00:00:52,518
我们会谈谈这一切，和

18
00:00:52,586 --> 00:00:55,220
那么我将回到我们的FaceView应用程序

19
00:00:55,289 --> 00:00:58,957
我们将添加一些手势，捏，平移，点击。

20
00:00:59,026 --> 00:01:01,894
最后，我会再次回到幻灯片

21
00:01:01,962 --> 00:01:04,062
开始谈论多个MVC。

22
00:01:04,130 --> 00:01:06,364
如何构建更大的应用程序

23
00:01:06,433 --> 00:01:11,837
结合MVC，这就是今天的发展。

24
00:01:11,906 --> 00:01:17,809
所以让我们再回到这个FaceIt演示中。

25
00:01:17,878 --> 00:01:21,346
如果你记得我们离开的地方，

26
00:01:21,414 --> 00:01:24,048
我们有这个很好的看法，真的很酷，因为，

27
00:01:24,117 --> 00:01:28,220
在Interface Builder中，我们可以做一些打开眼睛的东西。

28
00:01:28,289 --> 00:01:31,189
我们可以使它真的很大，

29
00:01:31,258 --> 00:01:36,261
我们可以使它真的很小，或者两者之间的任何地方。

30
00:01:36,330 --> 00:01:39,297
我们可以改变颜色，绿色，

31
00:01:39,366 --> 00:01:41,299
这样的东西，很酷

32
00:01:41,368 --> 00:01:44,302
这是一个很好的可重用的东西，有一点

33
00:01:44,371 --> 00:01:46,104
公开API给它。

34
00:01:46,173 --> 00:01:48,240
这些检查的东西都是公开的，

35
00:01:48,308 --> 00:01:52,110
所以，我们可以设定mouth curvature，我们可以打开

36
00:01:52,178 --> 00:01:53,878
闭上眼睛，我们可以改变那些东西，像大小。

37
00:01:53,947 --> 00:01:56,882
所以，很好，这是一个很好的可重用的脸。

38
00:01:56,950 --> 00:02:01,086
而我们要做的就是让我们的MVC有一个模型。

39
00:02:01,155 --> 00:02:03,788
那个模型不会和我们完全吻合

40
00:02:03,857 --> 00:02:06,324
FaceView可以做，因为这是模型的工作方式。

41
00:02:06,393 --> 00:02:09,961
世界上的模特儿往往是数据库或者是他们的东西

42
00:02:10,030 --> 00:02:13,031
模式与您所拥有的视图不完全匹配。

43
00:02:13,100 --> 00:02:15,600
所以你，控制器的工作是解释

44
00:02:15,669 --> 00:02:18,870
该模型为视图尽可能最好。

45
00:02:18,939 --> 00:02:23,075
并从视图中解释输入也影响模型。

46
00:02:23,143 --> 00:02:25,877
所以让我们回到我们的控制器，

47
00:02:25,946 --> 00:02:29,647
你可以看到我们没有模特，我们也没有网点

48
00:02:29,716 --> 00:02:32,751
在这里我们认为，所以我们来补充一下。

49
00:02:32,819 --> 00:02:37,021
我要开始添加一个outlet到我们的FaceView，所以

50
00:02:37,090 --> 00:02:40,758
记住我们如何做，我们在屏幕上得到了我们的故事板。

51
00:02:40,827 --> 00:02:43,929
我会同时在屏幕上得到他们

52
00:02:43,998 --> 00:02:45,664
那么我会控制拖动。

53
00:02:45,732 --> 00:02:48,333
我控制从我的FaceView拖动创建

54
00:02:48,401 --> 00:02:49,134
一个outlet，

55
00:02:49,202 --> 00:02:51,903
以完全相同的方式，我将控制拖动到一个标签，

56
00:02:51,972 --> 00:02:52,871
或按钮，或任何其他，所以

57
00:02:52,940 --> 00:02:54,872
关于FaceView没什么特别之处

58
00:02:54,941 --> 00:02:57,342
所以我只是在这里控制和拖动，

59
00:02:57,411 --> 00:02:59,778
我会创建一个outlet，

60
00:02:59,846 --> 00:03:02,614
我会把这个outlet叫做FaceView。

61
00:03:02,683 --> 00:03:06,184
这是一个很好的名字。

62
00:03:06,252 --> 00:03:10,689
点击连接，我们去，我们得到这个代码，你是

63
00:03:10,758 --> 00:03:16,961
很习惯这里，这是这个IBOutlet weak var。

64
00:03:17,030 --> 00:03:20,098
现在我们连接到我们的观点，并记住在MVC中

65
00:03:20,167 --> 00:03:23,101
图片，控制器可以看到绿色的箭头，

66
00:03:23,170 --> 00:03:26,070
就这样，它的模型可以有绿色的箭头。

67
00:03:26,139 --> 00:03:28,273
所以让我们创建一个与模型的连接。

68
00:03:28,342 --> 00:03:30,642
那么什么会成为我们的MVC模型？

69
00:03:30,711 --> 00:03:33,978
我实际上会拖动，在这里

70
00:03:34,047 --> 00:03:35,647
它被称为facial expression。

71
00:03:37,417 --> 00:03:39,851
当你拖动东西在我强烈推荐

72
00:03:39,920 --> 00:03:42,587
你有这个目的地，如果需要复制项目，

73
00:03:42,656 --> 00:03:45,757
否则，当你拖动一个类，或结构，或

74
00:03:45,826 --> 00:03:47,225
有些东西，你会指向它。

75
00:03:47,293 --> 00:03:49,294
所以如果你改变它，无论你从哪里得到它，

76
00:03:49,363 --> 00:03:50,729
它将在您的项目中改变它，

77
00:03:50,797 --> 00:03:52,631
所以，这通常是我们想做的。

78
00:03:52,699 --> 00:03:53,732
也许这可能是你想要的，

79
00:03:53,800 --> 00:03:56,835
在某些情况下，通常要复制它。

80
00:03:56,904 --> 00:04:00,071
所以让我们来看看这个我带来的东西，

81
00:04:00,140 --> 00:04:03,641
它是一个结构体，它将成为我们的FaceView的模型。

82
00:04:03,710 --> 00:04:06,044
而且这是一个非常简单的面部表情，

83
00:04:06,113 --> 00:04:09,380
这就是这个代表，这个结构。

84
00:04:09,449 --> 00:04:11,015
它有眼睛的位置，

85
00:04:11,084 --> 00:04:14,052
睁开眼睛，闭上眼睛，眯着眼睛，不幸的是，

86
00:04:14,121 --> 00:04:16,955
我们不能表现我们的视图，但它在模型(model)中，

87
00:04:17,023 --> 00:04:19,123
我们必须弄清楚我们能做的最好的事情。

88
00:04:19,192 --> 00:04:22,360
它也有一个嘴巴，嘴巴可以皱眉或假笑，或

89
00:04:22,428 --> 00:04:23,628
它可以笑，或微笑，

90
00:04:23,697 --> 00:04:27,732
注意这个模型中没有什么关于mouth curvature.。

91
00:04:27,801 --> 00:04:29,233
它不知道mouth curvature，

92
00:04:29,302 --> 00:04:30,301
它只是知道微笑和

93
00:04:30,370 --> 00:04:32,971
皱眉，像这样的东西，就是这个模型。

94
00:04:33,039 --> 00:04:37,209
它也很酷，它知道如何让你更快乐

95
00:04:37,277 --> 00:04:40,211
自己的版本，或者是自己的一个sadder版本。

96
00:04:40,280 --> 00:04:41,813
这就是这些吧，

97
00:04:41,882 --> 00:04:44,616
他们只是想回到一个更快乐或者更快的一天。

98
00:04:44,684 --> 00:04:48,620
但主要是这个结构只是一个表达式来保持

99
00:04:48,689 --> 00:04:53,291
跟踪眼睛和嘴巴的状态。

100
00:04:53,359 --> 00:04:55,027
所以我要去，在我的控制器，

101
00:04:55,095 --> 00:04:58,329
为它创建一个绿色箭头，或者为它创建一个var。

102
00:04:58,398 --> 00:05:00,365
我们会叫它表达，

103
00:05:00,434 --> 00:05:02,266
这是一个面部表情。

104
00:05:02,335 --> 00:05:05,570
而且它是类型面部表情，

105
00:05:05,639 --> 00:05:09,441
实际上，

106
00:05:09,509 --> 00:05:12,577
让我们有一个开始的面部表情有眼睛，

107
00:05:12,646 --> 00:05:18,516
这就是说，张开，还有一个嘴巴，这是一个笑容。

108
00:05:18,585 --> 00:05:20,419
这听起来像一个开心的地方。

109
00:05:22,322 --> 00:05:22,954
那太好了

110
00:05:23,022 --> 00:05:27,725
现在，记住控制器的主要工作

111
00:05:27,794 --> 00:05:31,062
是解释模型的视图，反之亦然。

112
00:05:31,131 --> 00:05:34,165
所以我会在这里添加一个私人功能 -

113
00:05:34,234 --> 00:05:36,367
你们都经常有一个方法或

114
00:05:36,436 --> 00:05:38,769
您的控制器中的一些方法如此。

115
00:05:38,838 --> 00:05:40,672
这个我将要调用updateUI。

116
00:05:41,841 --> 00:05:44,275
而这种方法的工作就是这样

117
00:05:44,344 --> 00:05:47,812
使模型与UI匹配，这是我的工作。

118
00:05:47,881 --> 00:05:49,915
这是这个方法要做的。

119
00:05:49,983 --> 00:05:52,817
那么，我们做什么来做我们的模型，

120
00:05:52,886 --> 00:05:54,586
这种面部表情，匹配我们的UI？

121
00:05:54,655 --> 00:05:56,487
那么我们必须处理眼睛

122
00:05:56,556 --> 00:05:58,389
我们必须处理嘴巴。

123
00:05:58,458 --> 00:06:02,960
所以，让我们首先处理眼睛，这很容易，所以，

124
00:06:03,029 --> 00:06:06,664
我只是打开我的表达式。

125
00:06:06,733 --> 00:06:10,701
而在模型中眼睛开放的情况下，

126
00:06:10,770 --> 00:06:14,539
那么很容易，我可以把我的faceView和

127
00:06:14,607 --> 00:06:19,444
设置它的眼睛打开真实，这很明显我们如何做到这一点。

128
00:06:19,512 --> 00:06:23,048
而这张脸，你还记得，是这个插座，

129
00:06:23,116 --> 00:06:27,552
我刚刚在那里创建，所以这很明显。

130
00:06:27,621 --> 00:06:30,922
眼睛在模型中关闭的情况怎么样？

131
00:06:30,990 --> 00:06:33,457
那么这是faceView.eyesOpen，

132
00:06:33,526 --> 00:06:35,493
会是假的

133
00:06:35,562 --> 00:06:38,729
最后，模型中就是这种情况

134
00:06:38,798 --> 00:06:41,900
在那里我们眯着眼睛，在这里，

135
00:06:41,968 --> 00:06:44,236
我真的没有办法代表。

136
00:06:44,304 --> 00:06:47,038
所以我只是说在这种情况下我们的眼睛

137
00:06:47,107 --> 00:06:50,642
会被关闭，因为眯眼更像是拥有

138
00:06:50,711 --> 00:06:52,944
你的眼睛闭合，而不是让他们开放。

139
00:06:53,013 --> 00:06:56,481
但我们并不总是有我们想要的观点

140
00:06:56,550 --> 00:06:58,517
代表我们的模式，所以我们在这里做的最好。

141
00:07:00,119 --> 00:07:02,888
所以这是眼睛，很简单。

142
00:07:02,956 --> 00:07:05,756
现在嘴里，我可以做同样的事情

143
00:07:05,825 --> 00:07:08,125
这里的嘴，case expression.mouth，

144
00:07:08,194 --> 00:07:10,394
如果这是一个笑容，设定mouth curvature这个。

145
00:07:10,463 --> 00:07:12,130
如果是正常的，将mouth curvature设为，

146
00:07:12,199 --> 00:07:14,198
但是这个代码是一个凌乱的，

147
00:07:14,267 --> 00:07:19,704
（在这里做一些空间，这样会更高），如果

148
00:07:19,773 --> 00:07:24,976
我在这里创建了一个私人的var，实际上让它成为一个let。

149
00:07:25,045 --> 00:07:28,513
我会把它称为mouthCurvatures，和

150
00:07:28,581 --> 00:07:31,015
它会成为一本字典，在字典中，

151
00:07:31,084 --> 00:07:37,822
值将是FacialExpression.MouthPositi-

152
00:07:37,891 --> 00:07:40,625
可能是一个笑容。

153
00:07:40,694 --> 00:07:43,594
而且值将会是一个mouth curvature,，所以

154
00:07:43,663 --> 00:07:44,929
咧着嘴笑，好吗？

155
00:07:44,997 --> 00:07:46,964
我想我决定了0.5。

156
00:07:47,033 --> 00:07:49,634
所以这只是一个字典

157
00:07:49,703 --> 00:07:53,705
嘴里的位置在模型中，mouthCurvatures为视图。

158
00:07:53,773 --> 00:07:56,374
所以我只是创建这个小的映射数据结构。

159
00:07:56,443 --> 00:07:58,409
所以让我们来做这个，让我们来映射这个。

160
00:07:58,478 --> 00:08:00,811
对于我们在这里的所有面部表情。

161
00:08:00,880 --> 00:08:02,313
请注意，顺便说一句，

162
00:08:02,381 --> 00:08:06,818
Swift能够推断这个字典的类型。

163
00:08:06,887 --> 00:08:10,254
Cuz它只有一个项目，它们的类型

164
00:08:10,323 --> 00:08:13,724
事情从他们是明显的。

165
00:08:13,793 --> 00:08:17,028
所以现在呢知道，顺便说一句，

166
00:08:17,097 --> 00:08:21,365
我们可以更简洁一点，只是说，

167
00:08:21,434 --> 00:08:24,736
皱眉为-1.0，笑脸为1.0。

168
00:08:24,805 --> 00:08:30,841
显然中性将为0.0。

169
00:08:30,910 --> 00:08:31,709
我得到了他们吗

170
00:08:31,778 --> 00:08:32,844
傻笑，傻笑怎么样？

171
00:08:32,912 --> 00:08:38,717
不，我们说的这个假笑是-0.5。

172
00:08:40,220 --> 00:08:42,119
所以我只是把这些嘴曲率放在这很好

173
00:08:42,188 --> 00:08:43,087
小桌子

174
00:08:43,156 --> 00:08:44,889
所以现在在我的更新UI中，

175
00:08:44,958 --> 00:08:48,392
我将要设置我的faceView的mouthCurvature

176
00:08:48,461 --> 00:08:51,496
相当于在mouthCurvatures看起来，

177
00:08:51,565 --> 00:08:58,669
model's的嘴巴。

178
00:08:58,738 --> 00:09:01,639
我只是想这样做，让你显示你

179
00:09:01,708 --> 00:09:04,475
并不总是每一个人都强悍的情况

180
00:09:04,544 --> 00:09:05,844
当你有一个枚举的事情

181
00:09:05,913 --> 00:09:07,545
有时你可以使用这样的东西。

182
00:09:07,614 --> 00:09:08,946
现在我有一个错误，

183
00:09:09,015 --> 00:09:10,314
任何人知道为什么我有错误？

184
00:09:10,383 --> 00:09:11,149
有人猜猜吗

185
00:09:16,322 --> 00:09:16,988
可选，是的。

186
00:09:17,057 --> 00:09:18,689
好的，人们得到了可选的东西。

187
00:09:18,758 --> 00:09:20,425
好。 MouthCurvature，

188
00:09:20,494 --> 00:09:21,593
那是什么类型的？

189
00:09:21,662 --> 00:09:24,762
这是一个double的，和mouthCurvature的sub

190
00:09:24,831 --> 00:09:27,632
expression.mouth，是什么类型的？

191
00:09:27,701 --> 00:09:29,533
这是一个可选的double。

192
00:09:29,602 --> 00:09:33,337
那是因为这个表达可能不是

193
00:09:33,406 --> 00:09:34,506
在那个字典中。

194
00:09:34,574 --> 00:09:37,508
所以我要用我们学到的那个默认的东西

195
00:09:37,577 --> 00:09:40,044
并说，如果我找不到表达嘴巴，

196
00:09:40,113 --> 00:09:43,047
我们会有中立的嘴巴，不要微笑或

197
00:09:43,116 --> 00:09:45,383
皱眉作为我们的曲率(curvature)。

198
00:09:48,688 --> 00:09:52,156
现在，我们有这个伟大的更新UI。

199
00:09:52,225 --> 00:09:55,192
我们什么时候叫这个东西？

200
00:09:55,261 --> 00:09:58,963
那么我们当然需要随时把这个东西叫做

201
00:09:59,032 --> 00:10:00,364
模型更改。

202
00:10:00,433 --> 00:10:02,934
如果我们的模型改变有不同的表达，

203
00:10:03,003 --> 00:10:04,068
我们必须更新我们的用户界面。

204
00:10:04,137 --> 00:10:05,836
那么我们该怎么办呢？

205
00:10:05,905 --> 00:10:08,439
我们会用这个很酷的功能，我说过

206
00:10:08,507 --> 00:10:13,478
一次称为属性监听，这样做了事情。

207
00:10:13,547 --> 00:10:16,648
所以didSet允许你在你的任何vars，

208
00:10:16,717 --> 00:10:19,417
如果更改，可以执行一些代码。

209
00:10:19,486 --> 00:10:22,019
所以任何时候有人设置这个表达，

210
00:10:22,088 --> 00:10:24,122
我只是要更新我的UI。

211
00:10:28,161 --> 00:10:29,827
现在还有另一个我想要的地方

212
00:10:29,896 --> 00:10:33,564
更新我的UI，但这不太明显

213
00:10:33,633 --> 00:10:36,568
就是这个属性监听。

214
00:10:39,171 --> 00:10:40,905
我在这是要干嘛？

215
00:10:40,974 --> 00:10:42,607
这个属性是outlet，

216
00:10:42,676 --> 00:10:45,743
那个东西我Ctrl +拖到我的faceView。

217
00:10:45,812 --> 00:10:49,681
当我们第一次启动时，它没有设置。

218
00:10:49,749 --> 00:10:53,318
iOS需要几微秒才能实际连接。

219
00:10:53,387 --> 00:10:56,487
这就是为什么这是一个可选的，记得吗？

220
00:10:56,556 --> 00:11:01,492
在这么短的时间内，如果模型被设置好了。

221
00:11:01,561 --> 00:11:03,927
那么更新UI不会因为faceView而工作

222
00:11:03,996 --> 00:11:05,830
尚未连接。

223
00:11:05,899 --> 00:11:07,632
那没那么好

224
00:11:07,701 --> 00:11:11,836
此外，我们初始化了我们的FacialExpression。

225
00:11:11,905 --> 00:11:16,741
初始化某些东西时，didSet不会被调用。

226
00:11:16,810 --> 00:11:19,144
didSet只有在外部设置时被调用

227
00:11:19,212 --> 00:11:20,445
表达方式。

228
00:11:20,514 --> 00:11:24,648
最初的事情并不意味着它被设置。

229
00:11:24,717 --> 00:11:27,451
那么什么时候会发生setSet？

230
00:11:27,520 --> 00:11:32,123
当iOS连接这个outlet时，它只会发生一次

231
00:11:32,191 --> 00:11:35,526
那个faceView，那么这个didSet将被调用。

232
00:11:35,595 --> 00:11:37,362
这是唯一一次会被召唤的时间。

233
00:11:37,430 --> 00:11:39,764
但是那时候，我们会更新我们的UI。

234
00:11:39,833 --> 00:11:43,401
现在还有另外一个小事情。

235
00:11:43,469 --> 00:11:51,009
如果在这种情况下被调用，该怎么办？

236
00:11:52,211 --> 00:11:55,412
这会让我们的程序崩溃

237
00:11:55,481 --> 00:11:59,517
因为直到这个连接到iOS，这是零。

238
00:12:01,320 --> 00:12:04,055
我们不必在此感叹号的唯一原因

239
00:12:04,124 --> 00:12:06,824
是cuz我们有这个隐含的包装可选这里，但是

240
00:12:06,893 --> 00:12:08,092
它是一个可选的。

241
00:12:08,161 --> 00:12:09,794
那我们怎么处理呢？

242
00:12:09,862 --> 00:12:12,263
我们不希望更新UI崩溃我们的程序

243
00:12:12,332 --> 00:12:14,832
如果表达式应该恰好在之前设置

244
00:12:14,901 --> 00:12:16,434
事情被弄清了。

245
00:12:16,502 --> 00:12:19,337
那么事情很快就会被接线

246
00:12:19,405 --> 00:12:21,639
可能不会发生，但可以。

247
00:12:21,708 --> 00:12:24,775
所以，我们要用这个链接来做，

248
00:12:24,844 --> 00:12:26,544
这个可选链接。

249
00:12:26,613 --> 00:12:28,146
记住可选链接，

250
00:12:28,215 --> 00:12:29,880
你可以在那里放一个问号。

251
00:12:29,949 --> 00:12:33,384
如果你把问号放在评估上

252
00:12:33,453 --> 00:12:36,654
为零，其余代码行被忽略。

253
00:12:36,722 --> 00:12:40,358
完美的，faceView?.eyes打开，如果faceView没有设置，

254
00:12:40,427 --> 00:12:41,726
我们将忽略它。

255
00:12:41,795 --> 00:12:43,561
我们不会睁开眼睛，

256
00:12:43,630 --> 00:12:45,630
那条线将立即中止。

257
00:12:47,534 --> 00:12:50,768
这是你经常想在你的更新中做的

258
00:12:50,837 --> 00:12:54,572
UI的东西是保护您的outlets不被设置

259
00:12:58,144 --> 00:13:01,880
而且这一切都会好起来的，因为如果发送了，而且

260
00:13:01,948 --> 00:13:04,882
这还没有，然后就发生了，而且

261
00:13:04,951 --> 00:13:08,152
这些代码行都没有执行，没有问题。

262
00:13:08,221 --> 00:13:10,054
因为当这个确实被钩住了，

263
00:13:10,123 --> 00:13:11,655
这将再次被打来。

264
00:13:11,724 --> 00:13:13,258
而这一次，就能做到这一点。

265
00:13:16,896 --> 00:13:17,829
就这样

266
00:13:17,897 --> 00:13:19,797
让我们在这里运行我们的小应用程序

267
00:13:19,866 --> 00:13:23,635
看看我们是否明目张胆地笑了起来。

268
00:13:23,703 --> 00:13:24,768
换一种说法，

269
00:13:24,837 --> 00:13:28,206
我们来看看我们的UI是否反映了我们的模型。

270
00:13:28,274 --> 00:13:32,277
够肯定，睁开眼睛，有点笑。

271
00:13:32,345 --> 00:13:38,349
我们试试关闭

272
00:13:38,417 --> 00:13:44,389
眼睛，闭合和

273
00:13:44,457 --> 00:13:50,061
有点皱眉

274
00:13:50,130 --> 00:13:51,862
果然！

275
00:13:51,931 --> 00:13:54,966
所以现在我们已经做了我们需要在我们的控制器，

276
00:13:55,035 --> 00:13:57,502
我们正在解释我们的模型为我们的观点。

277
00:13:57,571 --> 00:13:59,303
而从现在开始我们设定的模型，

278
00:13:59,372 --> 00:14:00,938
它会自动更新我们的视图。

279
00:14:01,006 --> 00:14:03,874
所以问题是，如果我忘了把这个小小的话呢该怎么办？

280
00:14:03,943 --> 00:14:06,143
问号在这里？

281
00:14:06,212 --> 00:14:09,814
可能一切都会很好，因为你没有设置

282
00:14:09,883 --> 00:14:13,584
在Outlook之前，您的模型将被iOS连接起来

283
00:14:13,653 --> 00:14:15,253
很快连接好了。

284
00:14:15,321 --> 00:14:19,189
但如果你这样做，

285
00:14:19,258 --> 00:14:20,291
所以这样你会知道，

286
00:14:20,360 --> 00:14:22,159
“哎呀”，你搞砸了。

287
00:14:22,228 --> 00:14:24,628
有时你会忘记把那个问号放在那里，

288
00:14:24,697 --> 00:14:26,180
你做所有的编码，你从来没有打过这个模型。

289
00:14:26,181 --> 00:14:27,664
没关系。

290
00:14:27,733 --> 00:14:29,701
但是后来，你以这样的方式改变你的代码

291
00:14:29,769 --> 00:14:31,869
在接受这个事情之前，接受模型的兴趣。

292
00:14:31,938 --> 00:14:33,304
它崩溃了，你马上找到它。

293
00:14:33,372 --> 00:14:34,372
这就是为什么崩溃

294
00:14:34,441 --> 00:14:36,340
并不总是世界上最糟糕的事情。

295
00:14:36,409 --> 00:14:38,076
崩溃可以帮助您找到类似的错误。

296
00:14:39,479 --> 00:14:40,778
你只希望你不要出货，

297
00:14:40,847 --> 00:14:44,081
客户以这种方式发现这个bug。

298
00:14:44,150 --> 00:14:45,949
就这样，这就是我想做的只是表演

299
00:14:46,018 --> 00:14:47,351
你现在我们有一个完整的MVC。

300
00:14:47,419 --> 00:14:49,053
它有一个模型，它有一个看法，

301
00:14:49,122 --> 00:14:52,389
它有一个控制器相互解释。

302
00:14:52,458 --> 00:14:53,624
所以我们可以回到我们的幻灯片

303
00:14:53,693 --> 00:14:54,692
了解手势，和

304
00:14:54,760 --> 00:14:56,561
那么我们会给这个东西添加一些手势。

305
00:15:01,634 --> 00:15:04,735
那么，我们如何得到这些感觉？

306
00:15:04,804 --> 00:15:07,872
现在可以收到通知

307
00:15:07,940 --> 00:15:11,575
原始的触摸事件，如触摸，意思是手指，

308
00:15:11,644 --> 00:15:15,646
在屏幕上下来，它移动了，它上升了。

309
00:15:15,714 --> 00:15:16,981
两个手指下来，

310
00:15:17,050 --> 00:15:20,351
你可以找出所有这些，但我们从来没有。

311
00:15:20,419 --> 00:15:23,787
太复杂了，试图弄清楚这是否下降，

312
00:15:23,856 --> 00:15:27,691
滑动，向上是滑动，而不是移动，这太难了。

313
00:15:27,760 --> 00:15:30,094
所以我们会让iOS为我们做。

314
00:15:30,163 --> 00:15:33,464
我们称之为与多点触摸相互作用，

315
00:15:33,533 --> 00:15:35,400
通过手势触摸

316
00:15:35,468 --> 00:15:37,167
所以我们甚至不会了解原始的

317
00:15:37,236 --> 00:15:39,871
在本课程中触摸输入，只是手势。

318
00:15:40,940 --> 00:15:43,341
所以手势被认可

319
00:15:43,409 --> 00:15:46,678
这个类叫做UIGestureRecognizer。

320
00:15:46,746 --> 00:15:49,413
实际上，不是通过UIGestureRecognizer本身，

321
00:15:49,482 --> 00:15:51,015
这是一个抽象类。

322
00:15:51,084 --> 00:15:53,017
有多少人知道什么是抽象类？

323
00:15:53,086 --> 00:15:54,651
如果你知道这是什么，举起手来。

324
00:15:54,720 --> 00:15:56,253
好的，所以我要花一点时间告诉你。

325
00:15:56,322 --> 00:15:59,089
所以一个抽象类是一个只有这个类的类

326
00:15:59,158 --> 00:16:02,659
生活中的目的是成为其他类的父类。

327
00:16:02,728 --> 00:16:06,097
你从来没有创建一个抽象类，好吗？

328
00:16:06,165 --> 00:16:08,198
你只创建它的子类，

329
00:16:08,267 --> 00:16:10,468
它的子类的实例。

330
00:16:10,537 --> 00:16:13,304
所以UI手势识别器的抽象，你永远不会

331
00:16:13,373 --> 00:16:16,307
创建一个UI，你永远不会在UI手势上调用一个初始化器

332
00:16:16,376 --> 00:16:17,074
识别器。

333
00:16:17,143 --> 00:16:19,009
相反，我会有一堆子类

334
00:16:19,078 --> 00:16:21,379
谈论，你会调用它们的初始化程序。

335
00:16:23,082 --> 00:16:27,785
现在在这里使用手势识别器有两个部分。

336
00:16:27,853 --> 00:16:30,554
一个是你必须问一个UIView，请开始

337
00:16:30,623 --> 00:16:34,491
承认这个姿态，像一个滑动或一个泛或任何东西。

338
00:16:34,560 --> 00:16:37,695
然后第二个是识别器识别时

339
00:16:37,763 --> 00:16:40,097
它，它想用一个处理程序来回调你，

340
00:16:40,166 --> 00:16:42,500
我们称之为处理程序，一个手势处理程序。

341
00:16:42,569 --> 00:16:45,035
所以有一个识别器，你添加到一个视图和

342
00:16:45,104 --> 00:16:47,838
那么有处理程序，任何人都可以是处理程序，

343
00:16:47,907 --> 00:16:48,672
你会看到

344
00:16:48,741 --> 00:16:52,343
几乎总是这个视图本身或一个控制器，

345
00:16:52,412 --> 00:16:54,278
但任何人都可以。

346
00:16:54,347 --> 00:16:57,715
现在，手势识别器的添加完成

347
00:16:57,783 --> 00:17:01,518
在UIView中添加手势识别器的方法。

348
00:17:01,587 --> 00:17:04,922
该方法通常由控制器调用，

349
00:17:04,991 --> 00:17:06,857
为什么控制器叫那个？

350
00:17:06,926 --> 00:17:10,428
这是因为控制器想要控制是否

351
00:17:10,496 --> 00:17:14,198
其观点认识到某些手势。

352
00:17:14,267 --> 00:17:16,767
他们可能想关闭某些手势或

353
00:17:16,836 --> 00:17:18,569
没有打开某些手势，所以

354
00:17:18,638 --> 00:17:21,072
控制器经常控制。

355
00:17:21,140 --> 00:17:25,208
但偶尔你会得到一个会添加的UIView

356
00:17:25,277 --> 00:17:28,379
一个自己的手势，像滚动视图。

357
00:17:28,447 --> 00:17:31,182
因为没有平移手势的滚动视图，或

358
00:17:31,250 --> 00:17:33,718
没有捏捏手势，如果它可以放大，

359
00:17:33,787 --> 00:17:35,386
它甚至不是滚动视图。

360
00:17:35,454 --> 00:17:36,920
换句话说，那个手势是这样的

361
00:17:36,989 --> 00:17:40,124
滚动视图添加的滚动视图的基本原理

362
00:17:40,193 --> 00:17:41,910
它会，你会有一些API来关闭它，但它添加到

363
00:17:41,911 --> 00:17:43,628
它本身。

364
00:17:43,696 --> 00:17:47,297
本身，它不会使一些控制器添加这个手势，

365
00:17:47,366 --> 00:17:49,333
它只是识别拖和捏。

366
00:17:49,402 --> 00:17:51,135
所以主要是由控制器完成，

367
00:17:51,204 --> 00:17:52,369
虽然你会看到

368
00:17:52,438 --> 00:17:53,971
第二件事，处理者，

369
00:17:54,040 --> 00:17:56,506
好的，可以是控制器或视图。

370
00:17:56,575 --> 00:18:00,477
它究竟取决于手势是否影响

371
00:18:00,546 --> 00:18:01,445
模型，或

372
00:18:01,514 --> 00:18:05,148
手势是否影响视图，好的。

373
00:18:05,217 --> 00:18:06,883
如果手势只影响视图，

374
00:18:06,952 --> 00:18:08,586
那么视图可能会处理它。

375
00:18:08,655 --> 00:18:11,088
但如果手势直接影响模型，

376
00:18:11,157 --> 00:18:12,123
现在控制器必须

377
00:18:12,191 --> 00:18:13,958
处理它，因为视图看不到模型。

378
00:18:17,297 --> 00:18:18,896
所以处理程序是控制器视图，而不是

379
00:18:18,965 --> 00:18:19,830
你会在演示中看到。

380
00:18:19,898 --> 00:18:22,166
我会有一个处理器是一个模型，一个和

381
00:18:22,234 --> 00:18:25,869
一个控制视图，你会看到我们把它们放在哪里。

382
00:18:25,938 --> 00:18:28,839
好的，那么代码如何添加一个手势呢？

383
00:18:28,907 --> 00:18:30,140
识别器到一个视图？

384
00:18:30,209 --> 00:18:31,308
所以对于我这里的例子，

385
00:18:31,377 --> 00:18:33,977
假设你有一个看法，在这段代码中我将会发生

386
00:18:34,046 --> 00:18:36,246
放在这里的方式将是在一个控制器。

387
00:18:36,315 --> 00:18:39,549
假设它有一个它想要添加的观点

388
00:18:39,618 --> 00:18:42,987
一个平移手势，一个平移手势放在你的手指

389
00:18:43,056 --> 00:18:45,255
屏幕移动。

390
00:18:45,324 --> 00:18:48,625
叫它panning around in the view。

391
00:18:48,694 --> 00:18:54,365
所以这是它的样子，添加一个手势的好地方

392
00:18:54,433 --> 00:18:59,470
识别器在这个视图的outlet中。

393
00:18:59,539 --> 00:19:02,740
因为那是，一旦你可以掌握它，

394
00:19:02,808 --> 00:19:05,476
你的iOS只是设置，设置你的outlet，所以

395
00:19:05,544 --> 00:19:07,545
现在你已经掌握了这个视图。

396
00:19:07,614 --> 00:19:09,413
现在您可以发送消息给该视图，

397
00:19:09,481 --> 00:19:11,048
addGestureRecognizer。

398
00:19:11,117 --> 00:19:14,318
在这里我有这个var，这个outlet叫pannableView，

399
00:19:14,387 --> 00:19:18,055
这是我想添加平移手势的观点。

400
00:19:18,124 --> 00:19:20,457
你可以看到，在它的didSet中，

401
00:19:20,526 --> 00:19:22,826
换句话说，当iOS连线时，

402
00:19:22,895 --> 00:19:25,829
我要做这个addGestureRecognizer。

403
00:19:25,898 --> 00:19:28,799
首先我要创建手势识别器，

404
00:19:28,868 --> 00:19:32,269
通知我在说UIPanGestureRecognizer，在其中，

405
00:19:32,338 --> 00:19:33,904
在初始化器中为此。

406
00:19:33,973 --> 00:19:37,074
不是UIGestureRecognizer，我正在创造一个具体的

407
00:19:37,143 --> 00:19:39,309
用于平移的手势识别器。

408
00:19:39,378 --> 00:19:42,312
而且它有两个参数，这两个参数

409
00:19:42,381 --> 00:19:44,682
是处理程序，这个东西如何处理。

410
00:19:44,751 --> 00:19:47,117
目标是谁来处理它

411
00:19:47,186 --> 00:19:50,354
该行为是什么方法来处理它。

412
00:19:50,423 --> 00:19:51,989
所以现在在这种情况下，目标，

413
00:19:52,058 --> 00:19:54,758
我有目标将自己，视图控制器。

414
00:19:54,827 --> 00:19:57,127
这显然是在视图控制器，因为这是在

415
00:19:57,196 --> 00:19:58,395
outlet的属性监听。

416
00:19:58,464 --> 00:20:00,364
这只会在视图控制器中有意义。

417
00:20:00,433 --> 00:20:03,634
所以目标是我自己，我要设定，

418
00:20:03,702 --> 00:20:07,037
问这个平底锅手势何时开始被认出

419
00:20:07,106 --> 00:20:11,108
它会给我这个动作来处理它。

420
00:20:11,177 --> 00:20:15,278
而且这个动作，你会注意到你必须说#selector来

421
00:20:15,347 --> 00:20:16,914
指定方法。

422
00:20:16,983 --> 00:20:19,750
不要混淆功能之间的区别

423
00:20:19,819 --> 00:20:22,152
类型，一个类型是一个函数和

424
00:20:22,221 --> 00:20:24,755
一个类中的实际方法。

425
00:20:24,824 --> 00:20:28,292
我们用#selector来说这是一个方法，

426
00:20:28,361 --> 00:20:32,229
我想在我的类里称这个具体的方法。

427
00:20:32,298 --> 00:20:34,898
并注意到我已经说过ViewController.pan(

428
00:20:34,967 --> 00:20:38,569
recognizer:)，那就意味着这个方法

429
00:20:38,638 --> 00:20:40,003
被称为pan。

430
00:20:40,072 --> 00:20:44,041
它有一个参数，其外部名称是 recognizer:

431
00:20:44,110 --> 00:20:45,876
这就是这个意思。

432
00:20:45,945 --> 00:20:49,980
ViewController。，表示该方法在我自己。

433
00:20:50,049 --> 00:20:52,650
如果在我看来，这可能就像

434
00:20:52,718 --> 00:20:54,752
PannableView.whatever。

435
00:20:54,820 --> 00:20:58,055
这也可以是self.pan，这是允许的，

436
00:20:58,124 --> 00:21:01,658
说pan.panGesture，自动识别器。

437
00:21:01,727 --> 00:21:04,562
也可以省略，这部分在全部和

438
00:21:04,630 --> 00:21:07,764
只是说panRecognizer：因为默认是为

439
00:21:07,833 --> 00:21:08,933
它在我自己。

440
00:21:09,001 --> 00:21:11,668
所以有三种方法可以指出，

441
00:21:11,737 --> 00:21:15,239
viewController.pan，self.pan或只是平移。

442
00:21:15,307 --> 00:21:17,674
但是请注意，它确实有这样的论据，

443
00:21:17,743 --> 00:21:20,678
那个参数就是把recognizer传给我。

444
00:21:20,746 --> 00:21:23,347
所以当pan开始被认出时，它会调用

445
00:21:23,416 --> 00:21:26,150
这种方法，并且识别器将被通过。

446
00:21:26,218 --> 00:21:29,220
这个pan手势识别器叫做panGestureRecognizer

447
00:21:29,288 --> 00:21:32,289
在那里，每次都会传回给我。

448
00:21:32,358 --> 00:21:35,325
现在我有一个手势识别器

449
00:21:35,394 --> 00:21:38,162
平移，我只是添加到视图，

450
00:21:38,231 --> 00:21:42,599
只有意见才能识别手势。

451
00:21:42,668 --> 00:21:44,768
所以如果你有手势识别器，

452
00:21:44,837 --> 00:21:48,339
整个UI工具包中唯一的addGestureRecognizer方法是

453
00:21:48,408 --> 00:21:51,108
在UIView中，所以你必须将它发送到UIView，或者

454
00:21:51,176 --> 00:21:52,576
UIView的子类。

455
00:21:53,946 --> 00:21:56,880
我们来谈谈处理，所以现在这是代码，

456
00:21:56,949 --> 00:21:57,948
这样添加处理程序

457
00:21:58,017 --> 00:22:01,685
该视图将开始寻找平移手势。

458
00:22:01,754 --> 00:22:03,053
然后当它找到它们时，

459
00:22:03,122 --> 00:22:06,189
它将开始调用这个识别器。

460
00:22:06,258 --> 00:22:08,025
现在我们可以看看代码

461
00:22:08,094 --> 00:22:10,861
我们必须了解一些事情。

462
00:22:10,930 --> 00:22:13,830
一个是当你得到一个平移手势或

463
00:22:13,899 --> 00:22:18,034
你需要一些具体的子类具体信息

464
00:22:18,103 --> 00:22:19,403
关于它像一个pan。

465
00:22:19,472 --> 00:22:21,638
你必须知道它在哪里，或者是捏，

466
00:22:21,707 --> 00:22:23,974
你必须知道你很多，

467
00:22:24,043 --> 00:22:26,944
所以我们必须明白这是什么意思，

468
00:22:27,012 --> 00:22:30,681
现在为了一个平移手势识别器，有三个。

469
00:22:30,749 --> 00:22:33,383
实际上还有一点，但这三个非常

470
00:22:33,452 --> 00:22:36,086
关于pan的重要的具体信息。

471
00:22:36,155 --> 00:22:40,524
所以，translation(in: UIView) 是平移手势中的一个功能

472
00:22:40,593 --> 00:22:42,793
识别器在哪里可以问，

473
00:22:42,861 --> 00:22:46,296
这个pan开始有多远。

474
00:22:46,365 --> 00:22:49,466
当我移动的时候，它从一开始就有多远，

475
00:22:49,535 --> 00:22:52,369
x和y，它是一个CG点，所以它给我x和

476
00:22:52,438 --> 00:22:55,172
从它开始就移动到它。

477
00:22:55,240 --> 00:22:58,408
Velocity表示手指移动有多快。

478
00:22:58,477 --> 00:23:00,077
是鞭打它吗？

479
00:23:00,146 --> 00:23:01,312
它真的很慢吗？

480
00:23:01,380 --> 00:23:02,913
因为如果它真的很慢，

481
00:23:02,981 --> 00:23:05,348
也许你想做一个非常你知道，小的绘制。

482
00:23:05,417 --> 00:23:06,683
如果他打嗝真的很快，

483
00:23:06,752 --> 00:23:08,818
你只是想知道，移动一些东西，谁知道？

484
00:23:08,887 --> 00:23:11,221
然后有setTranslation，

485
00:23:11,290 --> 00:23:13,724
现在这最后一个是有点酷，因为

486
00:23:13,792 --> 00:23:17,027
如果你只是知道起点和移动到哪里。

487
00:23:17,096 --> 00:23:20,397
你并没有真正得到增量

488
00:23:20,465 --> 00:23:21,832
每次更新时，

489
00:23:21,900 --> 00:23:24,968
所以你可以将转成零。

490
00:23:25,037 --> 00:23:27,404
然后，而不是从原点得到距离，

491
00:23:27,473 --> 00:23:29,606
你从上次的距离得到了

492
00:23:29,674 --> 00:23:30,508
这是发给你的。

493
00:23:30,576 --> 00:23:33,043
Cuz这个处理程序将被发送给你

494
00:23:33,112 --> 00:23:35,513
随着pan重复移动。

495
00:23:35,581 --> 00:23:38,248
几百次，你移动移动，所以

496
00:23:38,317 --> 00:23:41,651
通常你会把转设为零，

497
00:23:41,720 --> 00:23:44,421
它给你增量平移。

498
00:23:44,490 --> 00:23:46,890
你会看到与其他具体的一些

499
00:23:46,959 --> 00:23:48,408
现在，抽象超类，UIGestureRecognizer，

500
00:23:48,409 --> 00:23:49,858
也是。

501
00:23:49,928 --> 00:23:52,729
即使你不做一个它仍然是父类

502
00:23:52,798 --> 00:23:53,463
这些东西。

503
00:23:53,532 --> 00:23:54,631
你做继承，

504
00:23:54,700 --> 00:23:58,969
特别是这一个非常重要的var，被称为状态(state)。

505
00:23:59,037 --> 00:24:01,504
state告诉你手势的状态，

506
00:24:01,573 --> 00:24:03,273
如何得到认可

507
00:24:03,342 --> 00:24:05,875
所以所有这些手势识别器都开始了

508
00:24:05,944 --> 00:24:07,845
state可能。

509
00:24:07,914 --> 00:24:10,614
这可能会发生这种手势。

510
00:24:10,683 --> 00:24:13,917
然后，一旦它开始，如果它是一个持续的姿态

511
00:24:13,986 --> 00:24:16,687
像一个pan或一个pinch你去state开始了。

512
00:24:16,756 --> 00:24:19,789
所以这不是，“一个pan，我认为它已经开始了”。

513
00:24:19,858 --> 00:24:22,392
所以你会得到你的处理程序调用，你可以看看

514
00:24:22,461 --> 00:24:25,195
识别器的状态说，它开始了。

515
00:24:25,264 --> 00:24:28,031
然后，每次手指移动，

516
00:24:28,100 --> 00:24:28,832
它会改变。

517
00:24:28,901 --> 00:24:31,001
它变化，变化，变化，变化，变化，

518
00:24:31,069 --> 00:24:31,769
改变，改变。

519
00:24:31,837 --> 00:24:34,071
你得到你的处理程序反复调用

520
00:24:34,140 --> 00:24:36,473
没有任何改变的是上述方法，

521
00:24:36,542 --> 00:24:38,609
转换和state。

522
00:24:38,677 --> 00:24:39,343
移动改变

523
00:24:39,411 --> 00:24:42,045
然后，当手指上升时，你就会结束。

524
00:24:42,114 --> 00:24:45,348
你会得到你的处理程序调用，状态将会结束。

525
00:24:45,417 --> 00:24:50,254
现在，对于像滑动这样的离散的手势，

526
00:24:50,323 --> 00:24:52,189
滑动发生或不发生。

527
00:24:52,257 --> 00:24:54,157
当你看到一个滑动，你没有得到

528
00:24:54,226 --> 00:24:56,893
滑动开始，它正在屏幕上移动

529
00:24:56,962 --> 00:24:58,094
它脱落了，没有。

530
00:24:58,163 --> 00:24:59,396
滑动是否发生。

531
00:24:59,465 --> 00:25:01,297
所以你只需要调用一次

532
00:25:01,366 --> 00:25:04,501
舞台将直接走向ended或recognized。

533
00:25:04,570 --> 00:25:09,273
但你必须对states有点小心

534
00:25:09,341 --> 00:25:12,643
失败(failed) 和 取消(cancelled)

535
00:25:12,711 --> 00:25:15,212
失败可能是因为你开始了一个手势

536
00:25:15,280 --> 00:25:16,647
那么系统实现了，我的天哪，

537
00:25:16,715 --> 00:25:19,749
那不是一个pan的手势，那就是滑动的开始。

538
00:25:19,818 --> 00:25:20,984
或类似的东西。

539
00:25:21,053 --> 00:25:23,286
所以，它切换到滑动。

540
00:25:23,355 --> 00:25:26,623
所以你可以取消，然后另一个，

541
00:25:26,692 --> 00:25:29,526
或失败，然后你也没有取消。

542
00:25:29,595 --> 00:25:32,429
你正在平移过程中，调用来了，

543
00:25:32,498 --> 00:25:35,666
接管你的屏幕，人说你好，你怎么样？

544
00:25:35,734 --> 00:25:39,102
那么很明显，那个pan手势被取消了。

545
00:25:39,171 --> 00:25:40,437
所以你也可以这样做。

546
00:25:40,505 --> 00:25:42,973
所以如果你做任何事情，当你的手势结束时，

547
00:25:43,042 --> 00:25:45,709
那么当它失败时你必须小心清理，或者

548
00:25:45,778 --> 00:25:47,010
也被取消了。

549
00:25:47,079 --> 00:25:48,946
那就state。

550
00:25:49,014 --> 00:25:52,549
所以让我们来看看，了解我们对pan手势的了解

551
00:25:52,618 --> 00:25:54,684
操作会看起来像说明

552
00:25:54,753 --> 00:25:57,521
所以记住处理程序叫做pan，

553
00:25:57,590 --> 00:25:59,990
recognizer是那里的参数，那就是pan

554
00:26:00,058 --> 00:26:02,425
gesture recognizer 本身返回给我们。

555
00:26:02,494 --> 00:26:04,194
它的状态(state)会有所不同，

556
00:26:04,263 --> 00:26:06,329
我们可以问一下关于translation和view

557
00:26:06,398 --> 00:26:07,497
所有这些事情

558
00:26:07,566 --> 00:26:10,668
所以我们要做的第一件事就是看这个状态(state)

559
00:26:10,736 --> 00:26:13,436
我要做同样的事情，不管是pan，

560
00:26:13,505 --> 00:26:15,839
已经改变了，或者手指是否上移。

561
00:26:15,908 --> 00:26:17,407
这是pan的最后一个位置，

562
00:26:17,476 --> 00:26:19,242
我们要做同样的事情。

563
00:26:19,311 --> 00:26:22,179
注意到我使用这种切换的方式，

564
00:26:22,247 --> 00:26:24,214
希望你在阅读任务中得到这个。

565
00:26:24,282 --> 00:26:27,584
这基本上只是意味着你想掉下来

566
00:26:27,653 --> 00:26:30,587
下一个例子是很多语言的默认(default)，

567
00:26:30,655 --> 00:26:32,022
但是在Swift中它不是默认的，

568
00:26:32,091 --> 00:26:33,223
你不会fall through穿透.

569
00:26:33,292 --> 00:26:34,791
所以fallthrough让case穿透，

570
00:26:34,860 --> 00:26:36,359
这是一个特别的关键词。

571
00:26:36,428 --> 00:26:39,863
你也可以说case.changed.ended：那个

572
00:26:39,931 --> 00:26:41,397
可能实际上会更好。

573
00:26:41,466 --> 00:26:42,299
我们会在演示中做到这一点。

574
00:26:44,069 --> 00:26:48,072
所以如果pan移动一点或结束，那我要去

575
00:26:48,140 --> 00:26:52,676
首先从我们开始的地方得到转换

576
00:26:52,745 --> 00:26:55,479
通过请求可转换可以pan的视图。

577
00:26:55,548 --> 00:26:57,815
这就是pan在那里的视图。

578
00:26:57,883 --> 00:26:58,949
你几乎总是要求

579
00:26:59,018 --> 00:27:00,718
可转换pan的视图中。

580
00:27:00,786 --> 00:27:02,185
但是你可以在其他视图中要求它

581
00:27:02,254 --> 00:27:05,388
如果需要，它将转换到该视图的坐标系。

582
00:27:05,457 --> 00:27:07,190
但几乎总是你要求

583
00:27:07,259 --> 00:27:09,259
一个在可pan的视图。

584
00:27:09,328 --> 00:27:11,695
然后，我要拿那个转换，我要去

585
00:27:11,764 --> 00:27:14,164
移动，我要去做我的应用程序。

586
00:27:14,232 --> 00:27:14,965
画一条线，

587
00:27:15,033 --> 00:27:17,267
如果我用线跟踪手指，或者

588
00:27:17,336 --> 00:27:18,702
如果我在移动某物，

589
00:27:18,770 --> 00:27:21,104
我会把事情移到新的位置。

590
00:27:21,173 --> 00:27:23,974
那么，如果我想，我可以将转换到零

591
00:27:24,043 --> 00:27:26,243
下一次调用这个处理程序时，

592
00:27:26,311 --> 00:27:29,179
转换将是距离

593
00:27:29,248 --> 00:27:31,782
最后一次被称为。

594
00:27:31,851 --> 00:27:33,717
与所有开始的距离相反。

595
00:27:35,053 --> 00:27:36,352
pan开始了

596
00:27:36,421 --> 00:27:38,454
就是这样了。

597
00:27:38,523 --> 00:27:40,090
这是一个处理程序的工作原理，很简单。

598
00:27:40,158 --> 00:27:42,126
让我们谈谈一些其他的具体内容

599
00:27:42,194 --> 00:27:46,163
手势。

600
00:27:46,232 --> 00:27:48,932
所以我把手指放下，两根手指在屏幕上。

601
00:27:49,000 --> 00:27:50,968
现在，比例(scale)是1.0。

602
00:27:51,037 --> 00:27:53,370
如果我把手指分开两倍，

603
00:27:53,438 --> 00:27:54,971
现在的比例是2.0。

604
00:27:55,040 --> 00:27:58,108
如果我现在下降一半，那么比例是0.5。

605
00:27:58,177 --> 00:27:59,876
所以这是捏什么的。

606
00:27:59,945 --> 00:28:02,179
它只是不断地报道什么是比例，

607
00:28:02,247 --> 00:28:04,147
相对于什么pinch开始。

608
00:28:04,216 --> 00:28:06,482
现在，该比例不是只读的var，所以

609
00:28:06,551 --> 00:28:07,884
你也可以重设它。

610
00:28:07,953 --> 00:28:10,587
然后，你会得到增量比例。

611
00:28:10,655 --> 00:28:12,923
自上次以来，比例有多大变化？

612
00:28:12,991 --> 00:28:16,693
几乎像你保持重置初始手指

613
00:28:16,762 --> 00:28:19,663
如果将比例设置为1，则缩小。

614
00:28:19,732 --> 00:28:22,199
这就是你可以得到增量比例。

615
00:28:22,267 --> 00:28:23,433
我们也会在演示中做到这一点。

616
00:28:23,502 --> 00:28:25,602
然后，你也得到速度。

617
00:28:25,671 --> 00:28:29,839
或者这个东西是多少分，或者

618
00:28:29,908 --> 00:28:31,074
不是真的一点事实。

619
00:28:31,143 --> 00:28:33,042
这是一个比例因子。

620
00:28:33,111 --> 00:28:34,478
规模的百分比正在变化，

621
00:28:34,546 --> 00:28:36,046
每秒钟变化有多快。

622
00:28:36,114 --> 00:28:39,482
还有一个旋转手势是两个手指

623
00:28:39,551 --> 00:28:41,452
下来，就像转动一个旋钮。

624
00:28:43,522 --> 00:28:44,254
保持两个手指放下。

625
00:28:44,323 --> 00:28:44,921
你转过来

626
00:28:44,990 --> 00:28:46,690
你在那里旋转

627
00:28:46,759 --> 00:28:48,492
旋转是弧度。

628
00:28:48,560 --> 00:28:51,161
再次，它不是只读，所以你可以重置它和

629
00:28:51,230 --> 00:28:53,263
得到增量转弯。

630
00:28:53,332 --> 00:28:55,432
你也可以得到每秒的速度和弧度。

631
00:28:55,501 --> 00:28:57,501
人旋转的速度有多快

632
00:28:57,569 --> 00:29:01,471
还有SwipeGesture，再次这是离散的

633
00:29:01,540 --> 00:29:05,108
你的处理程序只会被调用一次。

634
00:29:05,177 --> 00:29:06,677
如果它识别这个手势。

635
00:29:06,745 --> 00:29:07,777
现在，因为这样，

636
00:29:07,846 --> 00:29:10,213
您必须配置一个SwipeGesture识别器。

637
00:29:10,282 --> 00:29:11,014
你创建它和

638
00:29:11,082 --> 00:29:13,484
那么你想在这里设置bars像方向。

639
00:29:13,552 --> 00:29:16,386
你要左手滑动，向右滑动，向上，向下。

640
00:29:16,454 --> 00:29:17,554
还有多少手指？

641
00:29:17,623 --> 00:29:18,588
两手指滑动？

642
00:29:18,657 --> 00:29:20,324
三手指滑动？

643
00:29:20,392 --> 00:29:21,942
当您创建它时，您可以设置所有这些，因为它是

644
00:29:21,943 --> 00:29:23,493
一个手指滑动？

645
00:29:23,562 --> 00:29:24,728
只是要找那个。

646
00:29:24,796 --> 00:29:27,197
当它找到它，它调用给你的处理程序一次。

647
00:29:27,266 --> 00:29:29,465
Cuz是离散的。

648
00:29:29,534 --> 00:29:32,001
然后有点击手势，类似于滑动手势

649
00:29:32,070 --> 00:29:33,137
因为你必须配置它。

650
00:29:33,205 --> 00:29:35,639
点击的数量，就像双击一下

651
00:29:35,707 --> 00:29:38,275
它是双击，你这样做。

652
00:29:38,343 --> 00:29:41,711
然后，它会调用，这不是纯粹是离散的

653
00:29:41,780 --> 00:29:45,381
手势，像SwipeGesture，真的是你正在寻找

654
00:29:45,450 --> 00:29:48,685
但是state也以点击结束

655
00:29:48,753 --> 00:29:50,654
仍然需要像swipe那样预先配置它，所以

656
00:29:50,722 --> 00:29:53,490
它的行为几乎完全像一个离散的手势。

657
00:29:55,260 --> 00:29:57,828
所以希望这样会在我们展示时更有意义

658
00:29:57,896 --> 00:30:00,563
演示这里，我们的演示我们将添加三个手势，

659
00:30:00,632 --> 00:30:03,766
一个是捏(pinch)，那只是要让脸变大了

660
00:30:03,835 --> 00:30:04,968
哪个与只有这么小的视图的模型

661
00:30:04,969 --> 00:30:06,102
无关

662
00:30:06,172 --> 00:30:08,672
我们将把该处理程序放在视图中。

663
00:30:08,741 --> 00:30:13,176
然后，我们要做pan，移动。

664
00:30:13,245 --> 00:30:14,878
其实不，我们要swipe而不是panJ。

665
00:30:14,946 --> 00:30:15,779
让我们用滑动(swipe)

666
00:30:15,847 --> 00:30:18,915
我们swipe，我们swipe，使我们的脸更快乐或

667
00:30:18,984 --> 00:30:20,183
向下滑动，使其平静下来。

668
00:30:20,252 --> 00:30:21,985
我们将打开和关闭你的眼睛。

669
00:30:22,053 --> 00:30:23,153
那个怎么样？

670
00:30:23,221 --> 00:30:25,388
最后两个显然会受到影响

671
00:30:25,457 --> 00:30:28,458
该模型，所以必须由控制器处理。

672
00:30:28,527 --> 00:30:31,994
所以我们回到我们在这里的代码

673
00:30:32,063 --> 00:30:33,396
我们怎么能做到这一点

674
00:30:33,465 --> 00:30:36,633
我们先做pinch。

675
00:30:36,701 --> 00:30:39,469
现在，捏(pinch)不影响模型，所以

676
00:30:39,538 --> 00:30:40,837
它可以由视图处理。

677
00:30:40,906 --> 00:30:42,839
所以，实际上是我们的视图

678
00:30:42,908 --> 00:30:48,044
首先写一个pinch的处理程序。

679
00:30:48,113 --> 00:30:50,880
因为我会叫这个处理函数func changeScale

680
00:30:50,949 --> 00:30:53,683
这就是它会做的，它会是一个捏。

681
00:30:53,752 --> 00:30:59,589
所以它会改变脑袋的比例。

682
00:30:59,658 --> 00:31:05,796
我叫它byReactingTo  a pinchRecognizer，

683
00:31:05,864 --> 00:31:09,932
哪个将是UI pinch recognizer,，

684
00:31:10,001 --> 00:31:14,904
捏手势识别器，我们去。

685
00:31:14,973 --> 00:31:17,440
所以这将是我的处理者。

686
00:31:17,509 --> 00:31:20,777
所以我会把这个捏回来给我的。

687
00:31:20,846 --> 00:31:22,712
我不会看那个小尺度的知道

688
00:31:22,781 --> 00:31:24,714
我自己的比例有多大。

689
00:31:24,783 --> 00:31:32,321
所以我要打开捏识别器的状态。

690
00:31:32,390 --> 00:31:35,358
记住，它从UI手势识别器继承，

691
00:31:35,427 --> 00:31:37,560
这是这个的父类。

692
00:31:37,629 --> 00:31:40,696
在这种情况下，它是改变的

693
00:31:40,765 --> 00:31:42,532
捏(pinch)已经改变了，或者

694
00:31:42,601 --> 00:31:46,869
如果结束了，这意味着用户将手指松开。

695
00:31:46,938 --> 00:31:51,307
这两种情况都不会调整我的比例

696
00:31:51,376 --> 00:31:54,344
通过任何缩放的pinchRecognizer。

697
00:31:56,548 --> 00:31:57,247
就那么简单。

698
00:31:59,518 --> 00:32:04,320
现在这个事情呢，如果

699
00:32:04,389 --> 00:32:08,425
我在这里开始pinch 1.0，我只是稍微动了一下。

700
00:32:08,494 --> 00:32:09,058
好的。

701
00:32:09,127 --> 00:32:10,961
我的比例(scale)只有一点点移动。

702
00:32:11,030 --> 00:32:12,896
如果超出2.0怎么办？

703
00:32:12,964 --> 00:32:14,764
现在我的脸变得2.0被大小。

704
00:32:14,833 --> 00:32:17,634
现在如果我把它超出2.1？

705
00:32:17,703 --> 00:32:23,373
这个代码会让我的脸从2.1到4.2你看到。

706
00:32:23,442 --> 00:32:26,543
所以我需要保持将这个缩放重新设置为1

707
00:32:26,611 --> 00:32:29,713
时间如此，我正在增加量化变化。

708
00:32:29,781 --> 00:32:32,949
所以我会说pinch recognizer.scale = 1。

709
00:32:33,017 --> 00:32:35,718
所以我只是经常重置。

710
00:32:35,787 --> 00:32:37,687
每次这个被叫，和

711
00:32:37,756 --> 00:32:40,490
我移动我的比例，我会重新设定比例

712
00:32:40,558 --> 00:32:43,426
我再次以我的捏(pinch)开始。

713
00:32:43,495 --> 00:32:46,963
这给我增量缩放。

714
00:32:47,031 --> 00:32:50,500
当然，我们还要处理所有其他情况

715
00:32:50,569 --> 00:32:51,300
的状态。

716
00:32:51,369 --> 00:32:52,302
但我不会做任何事情。

717
00:32:52,370 --> 00:32:54,270
所以当捏(pinch)开始时，我不会做任何事情。

718
00:32:54,339 --> 00:32:55,906
如果它被取消，我不在乎。

719
00:32:55,975 --> 00:32:57,640
我会离开它的任何比例(scale)

720
00:32:57,709 --> 00:32:58,475
在当时等

721
00:32:58,543 --> 00:33:02,512
所以我不需要真正处理任何其他情况。

722
00:33:02,581 --> 00:33:03,146
就是这样了。

723
00:33:03,215 --> 00:33:06,849
处理程序超级容易写。

724
00:33:06,918 --> 00:33:07,750
而这个比例(scale)的方式，

725
00:33:07,819 --> 00:33:10,420
大家都明白，这个比例就在这里吧，这个吧。

726
00:33:10,489 --> 00:33:11,521
这是我们的比例。

727
00:33:14,025 --> 00:33:14,758
有关的问题？

728
00:33:15,760 --> 00:33:16,793
所以现在我们有一个处理程序。

729
00:33:16,862 --> 00:33:20,030
在视图中发生短暂的事情时，我们有人要处理。

730
00:33:20,098 --> 00:33:24,768
现在我们需要做的就是添加识别器

731
00:33:24,837 --> 00:33:27,070
一个捏，并调用处理程序。

732
00:33:27,139 --> 00:33:29,639
所以我们将在这里做我们的脸视图(faceview)

733
00:33:29,707 --> 00:33:32,175
didSet，因为这是我们第一次拿到

734
00:33:32,244 --> 00:33:34,777
那个脸视图, ，我想要的脸视图是一个

735
00:33:34,846 --> 00:33:37,681
这是认识到这一点。

736
00:33:37,749 --> 00:33:40,583
所以让我们从创建处理程序开始吧

737
00:33:40,652 --> 00:33:42,618
我要创建一个局部变量来表明

738
00:33:42,687 --> 00:33:43,753
给我的处理者

739
00:33:43,822 --> 00:33:48,958
它是一个主题标签选择器和它的faceView方法，

740
00:33:49,027 --> 00:33:52,429
changeScalebyReactingTo，这是我的处理程序。

741
00:33:54,266 --> 00:33:56,433
然后我要在这里创建一个识别器，

742
00:33:56,501 --> 00:33:59,069
捏识别器和

743
00:33:59,138 --> 00:34:03,073
它将是一个UIPinchGestureRecognizer和

744
00:34:03,141 --> 00:34:05,641
当然我们需要target和action。

745
00:34:05,710 --> 00:34:07,744
我们需要创建一个识别器。

746
00:34:07,813 --> 00:34:10,714
目标将是faceView，

747
00:34:11,950 --> 00:34:14,083
它会自己处理这件事情

748
00:34:14,152 --> 00:34:15,786
该action将成为这个处理程序。

749
00:34:18,890 --> 00:34:19,455
就这样吧。

750
00:34:19,524 --> 00:34:21,991
现在我们只需要采取faceView和

751
00:34:22,060 --> 00:34:25,628
添加GestureRecognizer，pinchRecognizer。

752
00:34:25,697 --> 00:34:27,264
通过这样做，

753
00:34:27,332 --> 00:34:29,899
脸视图将开始识别捏。

754
00:34:29,967 --> 00:34:32,568
当它承认一个，它会发送这个处理程序

755
00:34:32,637 --> 00:34:35,038
消息就在这里面对面。

756
00:34:35,107 --> 00:34:40,543
现在，如果你

757
00:34:40,611 --> 00:34:47,917
希望这将是工作，让我们看看。

758
00:34:47,986 --> 00:34:49,286
当你可能会问，顺便说一句，

759
00:34:49,354 --> 00:34:52,055
如果我用鼠标，我该怎么做？

760
00:34:52,124 --> 00:34:53,723
在我的事情，好吗？

761
00:34:53,792 --> 00:34:55,858
神奇的option键。

762
00:34:55,927 --> 00:34:57,293
如果按option键，看看，

763
00:34:57,362 --> 00:34:58,662
我甚至没有触动任何东西，

764
00:34:58,730 --> 00:35:00,763
看到我有两件事情在那里。

765
00:35:00,832 --> 00:35:02,065
而且他们有相同的分开。

766
00:35:02,134 --> 00:35:05,167
你也可以option shift，他们会偏移他们，所以

767
00:35:05,236 --> 00:35:06,702
你可以捏你想要的任何地方。

768
00:35:06,771 --> 00:35:09,539
所以无论如何，这样做。

769
00:35:10,908 --> 00:35:12,975
不，不行。

770
00:35:13,044 --> 00:35:15,812
看到那个怎么可能呢？

771
00:35:15,881 --> 00:35:17,914
那么我们在这里花点时间来调试这个。

772
00:35:17,983 --> 00:35:19,482
为什么这不工作？

773
00:35:19,551 --> 00:35:20,750
我把那个捏手势。

774
00:35:20,819 --> 00:35:21,818
我补充说

775
00:35:21,887 --> 00:35:23,420
我有一个处理程序

776
00:35:23,489 --> 00:35:26,322
我们先来看看我们的FaceView和

777
00:35:26,391 --> 00:35:28,691
在我们的处理程序栏中放置一个中断点。

778
00:35:28,760 --> 00:35:31,394
让我们来看看它是否真的处理好了。

779
00:35:31,463 --> 00:35:34,130
所以我要回到这里，

780
00:35:34,199 --> 00:35:37,867
我要让我的选择准备好了，捏。

781
00:35:37,936 --> 00:35:38,835
好的！

782
00:35:38,903 --> 00:35:40,169
它破了

783
00:35:40,238 --> 00:35:43,339
这绝对是我的处理程序。

784
00:35:43,407 --> 00:35:44,173
那么，问题出在哪里？

785
00:35:44,242 --> 00:35:44,974
我们什么也不做。

786
00:35:45,043 --> 00:35:47,443
让我们来打印我们的scale

787
00:35:47,512 --> 00:35:49,845
看看我们的scale是否在变化。

788
00:35:49,914 --> 00:35:51,447
我会在这里放打印的代码。

789
00:35:51,516 --> 00:35:53,717
在这里使用断点的组合

790
00:35:53,785 --> 00:35:55,952
进行打印调试。

791
00:35:56,020 --> 00:35:56,786
我们来吧

792
00:35:56,854 --> 00:36:00,190
我们来看看这个比例是否真的被改变了。

793
00:36:03,662 --> 00:36:04,293
开始了。

794
00:36:04,362 --> 00:36:08,164
再次选项(option)键，它看起来像是这样。

795
00:36:08,233 --> 00:36:09,666
我在后台看到一些东西。

796
00:36:10,602 --> 00:36:12,334
当然可以看看。

797
00:36:12,403 --> 00:36:15,739
一半，双倍，它的工作完美。

798
00:36:15,807 --> 00:36:17,373
为什么不重绘那张脸。

799
00:36:17,442 --> 00:36:20,076
任何人都可以不重画。

800
00:36:21,279 --> 00:36:22,179
Cuz我们知道它正在工作。

801
00:36:24,049 --> 00:36:29,052
这是因为当你改变一个变量，像比例，对

802
00:36:29,120 --> 00:36:34,391
在这里，它不会自动知道重绘你的视图。

803
00:36:35,394 --> 00:36:36,993
这个比例正在变化。

804
00:36:37,062 --> 00:36:39,462
但最后一次被称为是第一次

805
00:36:39,530 --> 00:36:42,231
事情被画了，你知道，这个方法我们在这里

806
00:36:42,300 --> 00:36:44,901
在FaceView中绘制CGRect。

807
00:36:44,970 --> 00:36:45,668
这东西？

808
00:36:45,737 --> 00:36:47,503
这被称为当它被第一次绘制和

809
00:36:47,572 --> 00:36:49,406
它从来没有被调用。

810
00:36:49,474 --> 00:36:54,010
所以没有这个被称为没有其他方法画

811
00:36:54,079 --> 00:36:57,446
我的脸我告诉你这是唯一的画画方法。

812
00:36:57,515 --> 00:37:00,783
所以我们必须得到这个调用。

813
00:37:00,852 --> 00:37:02,185
我们怎么会这样做？

814
00:37:02,253 --> 00:37:05,355
那么我们只是在这里放大一下，

815
00:37:05,423 --> 00:37:09,292
任何一个时间段被调用，我们要做一个didSet。

816
00:37:10,395 --> 00:37:12,795
好的，在这里我们要去

817
00:37:12,864 --> 00:37:14,631
让我们自己画画。

818
00:37:14,699 --> 00:37:15,331
现在该怎么办？

819
00:37:15,400 --> 00:37:17,701
我调用draw吗

820
00:37:19,904 --> 00:37:22,204
不，我看到很多摇头不，绝对不是。

821
00:37:22,273 --> 00:37:23,940
当然，我们从调用draw。

822
00:37:24,008 --> 00:37:26,375
如果我们这样做，我们会遇到很大的麻烦

823
00:37:26,444 --> 00:37:27,376
我们叫什么？

824
00:37:27,445 --> 00:37:28,645
任何人都记得从幻灯片？

825
00:37:30,915 --> 00:37:32,048
SetNeedsDisplay。

826
00:37:33,684 --> 00:37:36,152
所以我们告诉系统有关我们的事情

827
00:37:36,221 --> 00:37:38,455
改变了，我们需要重新显示。

828
00:37:38,523 --> 00:37:41,924
所以请尽快回复我们。

829
00:37:41,993 --> 00:37:42,658
这就是它会做的。

830
00:37:42,727 --> 00:37:46,830
事实上，我们希望这一切都在这里。

831
00:37:50,569 --> 00:37:54,204
任何时候，任何这些公共事物被某人改变，

832
00:37:54,272 --> 00:37:55,805
我们要重新显示。

833
00:37:55,874 --> 00:37:58,074
让我们把这个评论放在这里。

834
00:37:58,143 --> 00:38:00,910
所以这是很常见的有这个小代码片段

835
00:38:00,979 --> 00:38:03,746
在任何var之后，当你改变它，

836
00:38:03,815 --> 00:38:05,315
会改变事情的样子。

837
00:38:06,684 --> 00:38:08,518
现在我们跑了，我们实际上可以回到这里

838
00:38:08,586 --> 00:38:09,652
摆脱这个打印。

839
00:38:09,720 --> 00:38:15,525
相当自信

840
00:38:15,594 --> 00:38:20,629
让它工作

841
00:38:20,698 --> 00:38:24,567
在这里，我再次选择option键，确定，看看，我们的scale。

842
00:38:24,636 --> 00:38:27,703
由于我们的规模在这里变化，那setNeedsDisplay是

843
00:38:27,772 --> 00:38:30,740
要求画画和iOS通过绘图适应我们。

844
00:38:33,378 --> 00:38:34,143
那很酷，

845
00:38:34,211 --> 00:38:37,413
这样做很简单。

846
00:38:37,482 --> 00:38:40,082
所以我们现在回到我们的控制器

847
00:38:40,151 --> 00:38:45,021
想想做一个像水龙头的手势，打开眼睛。

848
00:38:45,089 --> 00:38:48,391
现在，这个视图可能是这个的处理程序。

849
00:38:48,460 --> 00:38:50,260
它可以知道如何闭上眼睛。

850
00:38:50,328 --> 00:38:53,229
但是如果我们把这个视图作为一个点击(tap)的处理机构，

851
00:38:53,298 --> 00:38:56,866
打开眼睛，它会与比例(scale)失去同步。

852
00:38:56,935 --> 00:38:59,569
Cuz的模型是说眼睛是否开放，

853
00:38:59,638 --> 00:39:00,303
不是脸型。

854
00:39:00,371 --> 00:39:01,770
脸视图是一个仆从。

855
00:39:01,839 --> 00:39:03,205
这是控制器的一小撮，

856
00:39:03,274 --> 00:39:04,907
所以应该做的是控制器想要的

857
00:39:04,976 --> 00:39:05,642
我们不能这样做

858
00:39:05,710 --> 00:39:08,678
所以我们必须让控制器处理一个tap，

859
00:39:08,747 --> 00:39:09,712
并在模型中更改它。

860
00:39:09,781 --> 00:39:12,248
然后会自动

861
00:39:12,317 --> 00:39:15,384
在这里更新UI，因为这一行代码。

862
00:39:15,453 --> 00:39:19,055
任何时候我们改变我们的模型，它会更新我们的UI。

863
00:39:19,124 --> 00:39:21,624
所以我们只需要一个处理程序

864
00:39:21,693 --> 00:39:24,193
点击，只是改变我们的模型。

865
00:39:24,262 --> 00:39:26,296
这就是它需要做的一切。

866
00:39:27,832 --> 00:39:29,332
我们来试试这个处理程序。

867
00:39:29,400 --> 00:39:32,702
我们来调用该处理程序，关于toggleEyes怎么样

868
00:39:32,770 --> 00:39:34,671
我们要点击，它会与眼睛一起。

869
00:39:34,739 --> 00:39:37,206
如果它打开它会关闭，关闭它会打开。

870
00:39:37,275 --> 00:39:42,345
而ToggleEyes是一个tapGestureRecognizer的东西，

871
00:39:42,414 --> 00:39:47,016
所以我要通过反馈到tapRecognizer来说

872
00:39:47,085 --> 00:39:51,254
这是一个类型UITapGestureRecognizer。

873
00:39:51,323 --> 00:39:53,356
在这里我只是说，

874
00:39:53,425 --> 00:39:56,625
如果tapRecognizer.state已结束。

875
00:39:56,694 --> 00:39:58,194
所以tap发生了。

876
00:39:58,262 --> 00:40:03,066
然后我会让眼睛，这是FacialExpression.Eyes，

877
00:40:03,135 --> 00:40:06,135
只是为了让你知道是什么类型，

878
00:40:06,204 --> 00:40:10,206
等于我目前的表情的眼睛，

879
00:40:10,275 --> 00:40:14,810
如果目前的表情眼睛被关闭，那我就是

880
00:40:14,879 --> 00:40:19,448
要让他们开放，否则他们将被关闭。

881
00:40:19,517 --> 00:40:21,251
所以我只是切换他们。

882
00:40:22,754 --> 00:40:27,323
所以眼睛现在是类型FacialExpression.Eyes，

883
00:40:27,391 --> 00:40:30,592
这是相反的，或者是旧的。

884
00:40:30,661 --> 00:40:35,365
现在，我将把我的模型设定为一个新的面部表情。

885
00:40:35,433 --> 00:40:36,766
那新面孔表情的眼睛

886
00:40:36,835 --> 00:40:39,768
将是我刚刚计算的这个新眼睛。

887
00:40:39,837 --> 00:40:42,104
嘴巴会是老嘴巴的嘴巴。

888
00:40:42,173 --> 00:40:44,874
我没有做任何事情，所以我只是说

889
00:40:44,942 --> 00:40:47,376
表达方式，对于旧的。

890
00:40:47,445 --> 00:40:49,278
所以在这里我正在改变我的模型

891
00:40:49,347 --> 00:40:51,380
这将导致这个事件发生。

892
00:40:51,449 --> 00:40:53,082
它会重新绘制我的视图

893
00:40:53,151 --> 00:40:55,318
眼睛会和他们是相反的。

894
00:40:57,421 --> 00:40:58,821
那就是处理程序。

895
00:40:58,890 --> 00:40:59,489
这将要处理。

896
00:40:59,558 --> 00:41:02,825
所以现在我们必须添加一个tap手势识别器

897
00:41:02,894 --> 00:41:03,692
到我们的脸视图上

898
00:41:03,761 --> 00:41:08,064
所以这个时候让我们来说说tapRecognizer =

899
00:41:08,133 --> 00:41:10,600
UITapGestureRecognizer。

900
00:41:10,668 --> 00:41:13,703
和往常一样，我们只是指定目标(target)和选择器(selector)。

901
00:41:13,772 --> 00:41:15,838
所以目标这次不是faceView，

902
00:41:15,907 --> 00:41:17,139
这里是faceView。

903
00:41:17,208 --> 00:41:19,542
现在的目标(target)是我自己。

904
00:41:19,611 --> 00:41:22,644
而行动(action)将会是，

905
00:41:22,713 --> 00:41:24,547
再次我可以说faceView控制器或

906
00:41:24,616 --> 00:41:28,751
我可以指出自己的点，我们会这样做，切换眼睛。

907
00:41:33,592 --> 00:41:36,825
而我们需要放这个#selector。

908
00:41:36,894 --> 00:41:41,397
Cuz我们需要把它变成那个特定的选择器。

909
00:41:41,466 --> 00:41:43,966
那么我再也不需要这样的自我，

910
00:41:44,034 --> 00:41:45,885
看起来更好一点，它默认为我自己的方法。

911
00:41:45,886 --> 00:41:47,737
我可以这样做

912
00:41:49,173 --> 00:41:51,040
所以我们得到了tap识别器创建。

913
00:41:51,109 --> 00:41:53,610
现在我们必须配置tap识别器

914
00:41:53,678 --> 00:41:56,011
因为我们希望它在单个点击上发生。

915
00:41:56,080 --> 00:41:59,148
所以我们可以说例如numberOfTapsRequired = 1，

916
00:41:59,216 --> 00:42:01,618
这恰好是默认的，所以可能我不会

917
00:42:01,686 --> 00:42:03,786
需要说实话，不过我们还是要做。

918
00:42:03,855 --> 00:42:06,655
现在我们需要把它打开，我们通过添加来做

919
00:42:06,724 --> 00:42:08,625
一个手势识别器到FaceView。

920
00:42:09,961 --> 00:42:12,662
如果您不执行此步骤将其添加到某些视图

921
00:42:12,731 --> 00:42:15,498
那么那个视图就不会认识到这一点。

922
00:42:15,567 --> 00:42:17,500
所以它不会做任何事情。

923
00:42:17,569 --> 00:42:19,836
只是一个容易的一步忘记。

924
00:42:20,938 --> 00:42:26,008
好的，我们来吧

925
00:42:26,077 --> 00:42:30,612
看看是否有效。

926
00:42:30,681 --> 00:42:34,683
好的，所以点击，它工作了。

927
00:42:34,752 --> 00:42:38,554
每次我点击，它打开和关闭眼睛。

928
00:42:38,622 --> 00:42:39,856
它在模型中正在改变。

929
00:42:41,292 --> 00:42:42,158
所以它改变了模型，

930
00:42:42,226 --> 00:42:45,761
这将导致更新UI发生，这个更新UI

931
00:42:45,830 --> 00:42:48,464
做这个小事情来更新眼睛。

932
00:42:48,532 --> 00:42:53,536
当它打开眼睛打开这里好吧，眼睛打开。

933
00:42:53,605 --> 00:42:55,504
当它被设置时，它调用NeedsDisplay，

934
00:42:55,573 --> 00:42:57,106
这导致事情重绘。

935
00:42:57,174 --> 00:42:59,909
每个人都有这样的事件链？

936
00:43:01,780 --> 00:43:04,146
我们在这里另外做一个

937
00:43:04,215 --> 00:43:06,081
这是做一个滑动。

938
00:43:06,150 --> 00:43:08,951
所以我会有一个滑动，在哪里滑动

939
00:43:09,019 --> 00:43:12,388
我们的脸快乐和滑倒使得它成为一个平静的过程。

940
00:43:12,456 --> 00:43:14,890
所以这必须在控制器中处理。

941
00:43:14,959 --> 00:43:15,524
为什么？

942
00:43:15,593 --> 00:43:17,092
因为这正在影响模型。

943
00:43:17,161 --> 00:43:18,761
Happiness是模型。

944
00:43:18,829 --> 00:43:21,831
所以我会有一个func称为increaseHappiness。

945
00:43:23,535 --> 00:43:26,135
它只是将表达式设置为等于

946
00:43:26,204 --> 00:43:28,071
现有的表达却更快乐。

947
00:43:30,608 --> 00:43:32,942
我会做一个func减少喜欢

948
00:43:33,011 --> 00:43:35,077
我会相反的，

949
00:43:35,146 --> 00:43:38,213
expression =当前表达式但是sadder。

950
00:43:38,282 --> 00:43:40,349
而这些变化在这里，更快乐

951
00:43:40,418 --> 00:43:44,454
在这里，那些在面部表情中。

952
00:43:44,522 --> 00:43:46,355
你可以稍后再来看看它们的工作原理。

953
00:43:46,424 --> 00:43:47,523
但基本上只是创造一个新的

954
00:43:47,592 --> 00:43:50,058
面部表情在嘴里更开心或者

955
00:43:50,127 --> 00:43:51,461
嘴是平坦的。

956
00:43:51,529 --> 00:43:53,428
然后嘴巴知道如何快乐或悲伤或

957
00:43:53,497 --> 00:43:56,132
希望在枚举中使用这个原始机制

958
00:43:56,200 --> 00:43:58,567
你在阅读作业中已经想到了这一点。

959
00:43:58,636 --> 00:44:01,503
如果你这样做，这是一个很好的机会

960
00:44:01,572 --> 00:44:03,206
没有。

961
00:44:03,274 --> 00:44:08,744
回到我们的控制器，我们现在有这些处理程序。

962
00:44:08,813 --> 00:44:11,414
注意这些处理程序没有争议。

963
00:44:11,482 --> 00:44:13,182
为什么这些处理程序没有争议，

964
00:44:13,251 --> 00:44:15,551
像这样ByReactingTo的人在这里。

965
00:44:15,620 --> 00:44:17,786
因为滑动手势是离散的，所以

966
00:44:17,855 --> 00:44:20,456
我们从来没有看到滑动手势发生时，

967
00:44:20,525 --> 00:44:22,258
我们知道发生了，这就是我们需要知道的一切。

968
00:44:22,327 --> 00:44:25,160
所以这些处理程序不一定要看状态

969
00:44:25,229 --> 00:44:28,297
任何类似的东西，如点击手势或滑动手势或

970
00:44:28,365 --> 00:44:30,032
一个手势。

971
00:44:30,101 --> 00:44:34,403
让我们把这些人添加到那里，所以

972
00:44:34,471 --> 00:44:39,074
我要让swipeUpRecognizer =

973
00:44:39,143 --> 00:44:46,849
UISwipeGestureRecognizer，再次，目标和行动。

974
00:44:46,918 --> 00:44:49,318
再次，目标是我自己，因为它影响模型。

975
00:44:49,386 --> 00:44:53,522
而且我会选择这个增加幸福

976
00:44:53,591 --> 00:44:55,958
因为这是向上滑动。

977
00:44:56,027 --> 00:44:57,827
好的，现在我必须配置它。

978
00:44:57,896 --> 00:45:01,764
SwipeUpRecognizer的方向已经到了

979
00:45:01,832 --> 00:45:03,733
现在我要补充一下，

980
00:45:03,801 --> 00:45:09,272
faceView.addGestureRecognizer-（swipeUpRecognizer）。

981
00:45:09,340 --> 00:45:10,772
而且因为swipeDown是如此相似，

982
00:45:10,841 --> 00:45:13,176
我只是在这里复制粘贴。

983
00:45:13,244 --> 00:45:15,011
复制和粘贴。

984
00:45:15,079 --> 00:45:19,415
而且我们会改变向上滑动以向下滑动

985
00:45:22,720 --> 00:45:24,854
当然，现在的方向是下降的。

986
00:45:24,922 --> 00:45:29,192
而且减少的喜好，所以我减少。

987
00:45:29,260 --> 00:45:31,994
所以我添加了这两个识别器

988
00:45:32,063 --> 00:45:32,929
下滑

989
00:45:32,997 --> 00:45:34,697
他们会增加和

990
00:45:34,766 --> 00:45:37,065
减少我们在模型中的happiness。

991
00:45:37,134 --> 00:45:40,136
当模型发生变化时，会调用更新UI。

992
00:45:40,204 --> 00:45:42,505
我们将在该字典中查找口 mouth curvature。

993
00:45:42,573 --> 00:45:44,206
我们会mouth curvature，

994
00:45:44,275 --> 00:45:46,475
这将是doSet，我们的形状很好。

995
00:45:46,544 --> 00:45:49,778
所以在这里我们有一个很伤心的人，我们会睁开眼睛，

996
00:45:49,847 --> 00:45:51,914
那么我们将关闭，不要让他们开放

997
00:45:51,983 --> 00:45:53,015
现在我们要让他更快乐，

998
00:45:53,083 --> 00:45:54,049
更快乐，更快乐

999
00:45:54,118 --> 00:45:55,551
噢，他真的很开心！

1000
00:45:55,620 --> 00:45:59,055
而且滑下来，不，不是那么开心。

1001
00:46:02,193 --> 00:46:03,659
这就是手势。

1002
00:46:03,728 --> 00:46:07,129
手势是超简单和超强大的所有

1003
00:46:07,198 --> 00:46:10,532
检测的逻辑是滑动，或者是

1004
00:46:10,601 --> 00:46:12,969
一个锅，或者是什么，都是由你完成的。

1005
00:46:16,074 --> 00:46:21,243
回到我们

1006
00:46:21,312 --> 00:46:26,716
幻灯片。

1007
00:46:26,785 --> 00:46:29,618
时间谈论建立更大的应用程序，

1008
00:46:29,687 --> 00:46:33,622
应用程序涉及到多个MVC。

1009
00:46:33,691 --> 00:46:36,391
不只是我们的计算器MVC，而是多个MVC。

1010
00:46:36,460 --> 00:46:39,528
不只是我们的脸部控制器MVC，而是

1011
00:46:39,597 --> 00:46:41,230
多个MVC。

1012
00:46:41,298 --> 00:46:45,735
所以我从MVC的讨论中向你展示了这张照片

1013
00:46:45,803 --> 00:46:48,937
你可以看到MVC之间的关系是彼此

1014
00:46:49,006 --> 00:46:54,209
一个或多个MVC是另一个MVC视图的一部分。

1015
00:46:54,278 --> 00:46:57,713
所以我们来看看怎么回事。

1016
00:46:57,781 --> 00:47:03,085
我们结合这些MVC，（我不想说特别的，

1017
00:47:03,154 --> 00:47:06,188
因为你可以自己写），但是

1018
00:47:06,257 --> 00:47:09,391
iOS内置的MVC。

1019
00:47:09,460 --> 00:47:12,027
这些MVC已经建成

1020
00:47:12,096 --> 00:47:14,796
使用其他MVC作为其观点的一部分。

1021
00:47:14,865 --> 00:47:17,533
所以，是的，你可以建立自己的。

1022
00:47:17,601 --> 00:47:20,535
所以，例如，这里是我们做的最多的三个

1023
00:47:20,604 --> 00:47:22,704
建在这里或几乎我们所有的建筑物，

1024
00:47:22,773 --> 00:47:23,706
多个MVC。

1025
00:47:23,774 --> 00:47:26,708
有TabBarController，一个SplitViewController和

1026
00:47:26,777 --> 00:47:27,977
一个NavigationController。

1027
00:47:28,045 --> 00:47:30,879
所以我将在这里详细介绍一下这些

1028
00:47:30,948 --> 00:47:34,282
控制器是MVC的控制器

1029
00:47:34,351 --> 00:47:36,886
其观点是其他MVC。

1030
00:47:38,189 --> 00:47:41,089
所以这里是一个TabBarController。

1031
00:47:41,158 --> 00:47:43,158
如果你看看你在那里看到的东西，

1032
00:47:43,227 --> 00:47:47,195
那个屏幕上有两个MVC，两个。

1033
00:47:47,264 --> 00:47:49,732
一个MVC是TabBarController。

1034
00:47:49,800 --> 00:47:52,334
这是在底部绘制小图标。

1035
00:47:52,403 --> 00:47:55,103
你看到这些图标在底部，那四个图标？

1036
00:47:55,172 --> 00:47:56,972
那个MVC正在这样做。

1037
00:47:57,041 --> 00:47:59,642
另一个MVC是被黄色包围的东西，

1038
00:47:59,710 --> 00:48:02,011
一个仪表板MVC，无论如何，

1039
00:48:02,080 --> 00:48:04,213
在这里的健康应用程序或某事。

1040
00:48:04,281 --> 00:48:07,249
这是由一个完全不同的MVC绘制的，

1041
00:48:07,318 --> 00:48:08,684
仪表板MVC。

1042
00:48:08,752 --> 00:48:12,087
但请注意它是如何在视图中绘制的

1043
00:48:12,156 --> 00:48:13,889
的标签栏控制器。

1044
00:48:13,958 --> 00:48:17,526
所以，你已经看到我们如何构建一个MVC

1045
00:48:17,595 --> 00:48:19,461
的其他MVC。

1046
00:48:19,530 --> 00:48:23,498
标签栏控制器在其视图中内置了一个MVC。

1047
00:48:23,567 --> 00:48:26,568
现在，有趣的是这是非常面向对象的

1048
00:48:26,637 --> 00:48:29,872
在那些按钮的底部，这两个图标和

1049
00:48:29,941 --> 00:48:31,807
文本上，如果他们有一个徽章，

1050
00:48:31,876 --> 00:48:32,875
那也会在那里

1051
00:48:32,943 --> 00:48:37,179
那些实际上没有在TabBarController中设置，

1052
00:48:37,248 --> 00:48:40,082
TabBarController正在抓取它们

1053
00:48:40,151 --> 00:48:41,050
仪表板MVC。

1054
00:48:43,754 --> 00:48:45,988
在仪表板MVC中从var中抓取它们，

1055
00:48:46,057 --> 00:48:49,724
它是一个名为TabBarItem的UI控制器栏。

1056
00:48:49,793 --> 00:48:54,263
而TabBarItem则包含徽章，标题和图标，

1057
00:48:54,332 --> 00:48:56,465
像这样的东西。

1058
00:48:56,533 --> 00:49:00,001
当然，如果我在标签栏中可以有更多的MVC

1059
00:49:00,070 --> 00:49:02,271
点击那里的第二个图标，

1060
00:49:02,339 --> 00:49:05,340
我得到一个不同的MVC填补了这个空间在顶部。

1061
00:49:05,409 --> 00:49:07,843
所以现在，我们已经看到了三个MVC

1062
00:49:07,912 --> 00:49:11,646
远，仪表板，运行状况数据和TabBarController。

1063
00:49:11,715 --> 00:49:15,984
对，现在顺便说一下，如果你得到太多的标签，如果你放

1064
00:49:16,053 --> 00:49:19,187
六个MVC，例如，进入标签栏控制器，

1065
00:49:19,256 --> 00:49:22,924
那么你得到一点点“...”图标在右边，和

1066
00:49:22,993 --> 00:49:24,593
你可以点击，用户可以得到那些。

1067
00:49:24,661 --> 00:49:29,164
因此，标签栏控制器可以有超过五个MVC。

1068
00:49:29,233 --> 00:49:30,966
但是如果你开始得到五个以上，

1069
00:49:31,034 --> 00:49:33,502
UI由于用户拥有而变得有点笨重

1070
00:49:33,570 --> 00:49:35,571
过去点击更多来到另一个。

1071
00:49:35,640 --> 00:49:37,640
我推荐如果你有一个标签栏，

1072
00:49:37,709 --> 00:49:39,808
不要在那里放五个以上的MVC。

1073
00:49:39,876 --> 00:49:43,812
所以问题是，当我们有底部的图标

1074
00:49:43,881 --> 00:49:46,381
并且喜欢，那里的图标和标题。

1075
00:49:46,450 --> 00:49:48,651
而且我说这是从MVC那里得到的

1076
00:49:48,719 --> 00:49:49,951
正在显示。

1077
00:49:50,020 --> 00:49:56,058
问题是，是嵌入的

1078
00:49:56,127 --> 00:49:59,027
MVC，像健康数据一样，还是仪表盘，就是这样

1079
00:49:59,096 --> 00:50:03,032
从模型中获取按钮和标题？

1080
00:50:03,101 --> 00:50:05,433
答案是，这取决于MVC。

1081
00:50:05,502 --> 00:50:09,304
一些MVC可能会这样做，大概不是因为

1082
00:50:09,373 --> 00:50:12,808
这更像是UI的东西，什么是图标和文字。

1083
00:50:12,877 --> 00:50:15,744
可能不是模型的一部分，特别是图标。

1084
00:50:15,813 --> 00:50:23,151
不太可能在模型中。

1085
00:50:23,220 --> 00:50:28,356
我们在屏幕上共有五个MVC拥有更多的MVC。

1086
00:50:28,425 --> 00:50:29,691
标签栏控制器和

1087
00:50:29,760 --> 00:50:32,828
这四个MVC是每个选项卡。

1088
00:50:32,896 --> 00:50:37,532
所以这是组合MVC的最简单的方法。

1089
00:50:37,601 --> 00:50:40,335
但是，当我说这些话的时候，你会看到我的意思

1090
00:50:40,404 --> 00:50:44,139
MVC是标签栏控制器视图的一部分。

1091
00:50:44,208 --> 00:50:47,743
实际上他们的观点实际上是嵌入式的

1092
00:50:47,812 --> 00:50:52,915
嵌入在标签栏控制器的视图中。

1093
00:50:52,984 --> 00:50:54,716
这是最简单的一个。

1094
00:50:54,785 --> 00:50:56,552
我们来谈谈下一个最简单的一个，

1095
00:50:56,621 --> 00:50:58,153
这是分割视图控制器。

1096
00:50:58,222 --> 00:51:03,025
所以分割视图控制器是并行的两个MVC。

1097
00:51:03,094 --> 00:51:05,694
你可以在屏幕上同时看到他们，

1098
00:51:05,763 --> 00:51:07,262
至少在横屏中你做。

1099
00:51:07,331 --> 00:51:10,866
左边这个是一个计算器MVC。

1100
00:51:10,935 --> 00:51:12,735
它看起来不像你的，但是

1101
00:51:12,804 --> 00:51:15,037
你可以想象这是一个计算器MVC。

1102
00:51:15,105 --> 00:51:15,837
那个MVC，

1103
00:51:15,906 --> 00:51:20,409
我们调用分割视图控制器的主MVC。

1104
00:51:20,477 --> 00:51:23,044
然后在另一边有一个完全不同的MVC，

1105
00:51:23,113 --> 00:51:24,713
完全和完全不同。

1106
00:51:24,782 --> 00:51:29,251
这个恰好是一张图

1107
00:51:29,320 --> 00:51:31,486
什么是计算器MVC。

1108
00:51:31,555 --> 00:51:32,888
这样看起来很相似

1109
00:51:32,957 --> 00:51:35,724
作业作业，因为这是作业3。

1110
00:51:35,793 --> 00:51:37,493
要建立一个图形计算器，

1111
00:51:37,561 --> 00:51:38,894
你会放在一个分裂的视图和

1112
00:51:38,962 --> 00:51:40,662
做我今天所说的所有事情，

1113
00:51:40,731 --> 00:51:42,030
所以要注意

1114
00:51:42,099 --> 00:51:43,098
所以我们叫一个细节。

1115
00:51:43,167 --> 00:51:44,699
我们称之为细节的原因，

1116
00:51:44,768 --> 00:51:46,568
几乎总是正确的一面，

1117
00:51:46,637 --> 00:51:51,740
这通常更大，无论发生什么

1118
00:51:51,809 --> 00:51:54,143
由主人左边的控制。

1119
00:51:54,212 --> 00:51:55,677
在这里也是如此。

1120
00:51:55,746 --> 00:51:58,313
Cuz右边的图表显示了什么

1121
00:51:58,382 --> 00:51:59,280
左边的计算器。

1122
00:51:59,349 --> 00:52:01,216
所以如果你在左边的计算器中改变一些东西，

1123
00:52:01,285 --> 00:52:03,719
点击它的图形按钮，它会更改细节。

1124
00:52:03,788 --> 00:52:08,123
所以主人以这种方式控制细节。

1125
00:52:08,192 --> 00:52:10,693
现在，这就是这些东西的样子

1126
00:52:10,761 --> 00:52:12,461
在横向模式下并排。

1127
00:52:12,530 --> 00:52:14,630
但如果你切换到竖屏怎么办？

1128
00:52:14,699 --> 00:52:17,632
那么，在纵向，它只是显示你的细节，但是

1129
00:52:17,701 --> 00:52:22,204
你可以从左边滑动，让主屏来

1130
00:52:22,273 --> 00:52:24,773
在它的顶部，然后做任何你想要的。

1131
00:52:24,842 --> 00:52:26,074
它仍然更新实用程序

1132
00:52:26,143 --> 00:52:27,476
你可以把它擦干净。

1133
00:52:30,047 --> 00:52:31,212
那就是分割视图控制器。

1134
00:52:31,281 --> 00:52:32,348
超级简单

1135
00:52:32,416 --> 00:52:35,717
再次，希望你看到有三个MVC

1136
00:52:35,786 --> 00:52:37,886
分割视图控制器的MVC，以及这些主控和

1137
00:52:37,887 --> 00:52:39,987
上面这儿。

1138
00:52:40,057 --> 00:52:41,089
详细MVC。

1139
00:52:41,158 --> 00:52:44,459
主要细节作为视图

1140
00:52:44,528 --> 00:52:45,427
该分割视图控制器。

1141
00:52:45,496 --> 00:52:48,764
请注意，分割视图控制器本身没有UI。

1142
00:52:48,833 --> 00:52:50,432
它在实际上并没有画出任何东西，

1143
00:52:50,501 --> 00:52:55,103
它只是使用UI或这些MVC的视图绘制。

1144
00:52:55,172 --> 00:52:57,873
我猜，它绘制了两者之间的垂直线，

1145
00:52:57,942 --> 00:53:01,743
这可能是由分割视图绘制的。

1146
00:53:01,812 --> 00:53:03,479
最复杂的一个和

1147
00:53:03,547 --> 00:53:07,616
最常用的是导航控制器。

1148
00:53:07,685 --> 00:53:12,354
另一个在其视图中使用其他MVC的MVC。

1149
00:53:12,423 --> 00:53:16,358
所以，这里我们看到两个MVC在这个屏幕上，

1150
00:53:16,427 --> 00:53:19,027
基于导航控制器的MVC。

1151
00:53:19,096 --> 00:53:22,231
而且它显示另一个MVC，

1152
00:53:22,300 --> 00:53:24,700
我打电话给所有设置MVC。

1153
00:53:26,470 --> 00:53:29,004
在这个特别的看法，你正在看。

1154
00:53:29,073 --> 00:53:31,139
看到顶部有一个灰色的bar说

1155
00:53:31,208 --> 00:53:32,841
那里的设置？

1156
00:53:32,910 --> 00:53:35,844
灰色的bar，其实是透明的

1157
00:53:35,913 --> 00:53:38,214
显示MVC背后的所有设置。

1158
00:53:39,216 --> 00:53:41,450
金达，一点点弄脏了。

1159
00:53:41,519 --> 00:53:45,253
导航控制器绘制灰色条。

1160
00:53:45,322 --> 00:53:46,522
那个和一个工具栏在底部，

1161
00:53:46,590 --> 00:53:48,657
我会在一秒钟内谈论这是唯一的事情

1162
00:53:48,726 --> 00:53:51,193
导航控制器实际上在其中看到。

1163
00:53:51,262 --> 00:53:55,029
其余的视图，它填补了另一个MVC。

1164
00:53:55,098 --> 00:53:56,598
从另一个MVC的视图，

1165
00:53:56,666 --> 00:53:58,734
在这种情况下所有设置的MVC。

1166
00:54:02,906 --> 00:54:05,107
内容都是这个“所有设置MVC”。

1167
00:54:06,544 --> 00:54:08,577
就像标签栏控制器一样

1168
00:54:08,645 --> 00:54:11,213
那个标签栏的项目就像图标一样

1169
00:54:11,281 --> 00:54:11,846
标题就可以了。

1170
00:54:11,915 --> 00:54:13,949
与导航控制器相同。

1171
00:54:14,018 --> 00:54:16,484
那个字设置在顶部，

1172
00:54:16,553 --> 00:54:20,522
导航控制器MVC通过询问得到这个词

1173
00:54:20,591 --> 00:54:23,626
该MVC目前正在显示您的标题。

1174
00:54:25,696 --> 00:54:29,898
它从这个var导航项中得到。

1175
00:54:29,967 --> 00:54:31,065
这是一个UI视图控件的东西，

1176
00:54:31,134 --> 00:54:34,002
就像标签栏项目有所有标签栏的东西，导航

1177
00:54:34,071 --> 00:54:37,306
有所有的导航，UI导航的东西。

1178
00:54:37,375 --> 00:54:39,474
所以如果你看导航项的API，

1179
00:54:39,543 --> 00:54:42,110
它有东西在那里像标题，我会显示

1180
00:54:42,179 --> 00:54:44,812
你另一个属性，它将要使用一秒钟

1181
00:54:44,881 --> 00:54:46,282
更多的信息要画。

1182
00:54:48,018 --> 00:54:51,420
如果我实际上点击了这个表格视图，

1183
00:54:51,489 --> 00:54:55,157
如果我点击一般权利，那么一个新的MVC就是

1184
00:54:55,226 --> 00:54:59,427
要放在旧设置的顶部。

1185
00:54:59,496 --> 00:55:02,597
现在，旧的设置是完全不可见的

1186
00:55:02,666 --> 00:55:03,399
它还在那里

1187
00:55:04,435 --> 00:55:05,767
这就像一叠卡，

1188
00:55:05,836 --> 00:55:07,736
在那里我把一张新卡放在了顶部。

1189
00:55:07,804 --> 00:55:11,005
另一张卡不再在屏幕上，好的，

1190
00:55:11,074 --> 00:55:12,374
你再也看不到了。

1191
00:55:13,910 --> 00:55:16,811
但它仍然存在于内存中，在导航控制器中。

1192
00:55:16,880 --> 00:55:20,081
所以现在我们有三个MVC参与了

1193
00:55:20,150 --> 00:55:23,185
导航控制器，导航控制器的MVC，

1194
00:55:23,253 --> 00:55:26,788
现在在这一个背后的所有设置，

1195
00:55:26,857 --> 00:55:31,059
而这一个，一般设置MVC。

1196
00:55:31,128 --> 00:55:32,494
现在，顺便说一句，

1197
00:55:32,562 --> 00:55:35,463
您可以沿着底部的工具栏按钮。

1198
00:55:35,532 --> 00:55:37,098
它们看起来类似于标签栏，

1199
00:55:37,167 --> 00:55:38,934
但他们有点不一样。

1200
00:55:39,002 --> 00:55:42,470
这是用工具栏项，var在

1201
00:55:42,539 --> 00:55:45,941
一般设置MVC，不在导航控制器。

1202
00:55:46,010 --> 00:55:48,944
所以当新的MVC滑入，工具栏按钮在

1203
00:55:49,013 --> 00:55:51,713
底部会改变，因为它们被连接

1204
00:55:51,782 --> 00:55:54,916
无论发生在卡牌上方的事情。

1205
00:55:54,985 --> 00:55:58,519
还要注意有一个后退按钮。

1206
00:55:58,588 --> 00:55:59,454
你看到后退按钮？

1207
00:55:59,522 --> 00:56:01,055
这被称为设置。

1208
00:56:01,124 --> 00:56:03,658
该按钮通过导航自动放在那里

1209
00:56:03,727 --> 00:56:04,826
控制器。

1210
00:56:04,894 --> 00:56:05,927
如果你点击，

1211
00:56:05,996 --> 00:56:07,563
它会回到另一张卡片。

1212
00:56:07,631 --> 00:56:10,666
所有的设置，所以这一切都为你做。

1213
00:56:12,336 --> 00:56:14,002
但是如果我点击这里的某个地方，

1214
00:56:14,070 --> 00:56:18,106
像Accessibility那样，那么它去另一个MVC。

1215
00:56:18,175 --> 00:56:21,376
现在我们已经看到四个MVC到目前为止这个事情。

1216
00:56:21,445 --> 00:56:24,179
如果我点击这里的较大文本，我还没有

1217
00:56:24,248 --> 00:56:25,013
另一个MVC ..

1218
00:56:25,081 --> 00:56:27,015
现在我们有五个MVC。

1219
00:56:27,083 --> 00:56:29,418
所以这些MVC只是堆叠在上面

1220
00:56:29,486 --> 00:56:32,320
每个新的都是它自己的世界。

1221
00:56:32,389 --> 00:56:34,422
这完全是自己的。

1222
00:56:34,491 --> 00:56:37,592
当然，如果我们开始按下后退按钮

1223
00:56:37,661 --> 00:56:40,862
在左边，它返回到前一个。

1224
00:56:40,931 --> 00:56:43,698
注意后退按钮的标题是均匀的

1225
00:56:43,767 --> 00:56:45,934
成为以前的MVC的标题

1226
00:56:46,003 --> 00:56:49,103
你知道当你点击它会发生什么。

1227
00:56:49,172 --> 00:56:51,506
我们可以一路回到所有的设置

1228
00:56:51,575 --> 00:56:52,207
最顶级

1229
00:56:52,275 --> 00:56:53,675
现在没有后退按钮，因为

1230
00:56:53,744 --> 00:56:54,576
没有其他卡。

1231
00:56:56,146 --> 00:56:57,779
那就是导航控制器

1232
00:56:57,847 --> 00:56:59,214
外观和作品像。

1233
00:56:59,282 --> 00:57:02,750
好的，你们都看过这个UI，我确定在应用中。

1234
00:57:02,819 --> 00:57:04,652
超级常见

1235
00:57:04,721 --> 00:57:07,222
所以让我们来谈谈一下导航控制器的一些

1236
00:57:07,291 --> 00:57:08,490
在幕后工作。

1237
00:57:09,559 --> 00:57:10,959
你如何使这个事情发挥作用。

1238
00:57:11,027 --> 00:57:13,194
那么什么时候需要导航控制器？

1239
00:57:13,263 --> 00:57:16,431
好吧，让我们看看你有一个MVC，就在那里

1240
00:57:16,499 --> 00:57:19,701
你在角落里还有一堆UI

1241
00:57:19,770 --> 00:57:22,304
你想添加，但只是不适合。

1242
00:57:22,373 --> 00:57:24,305
你想要做的辅助功能和

1243
00:57:24,374 --> 00:57:27,175
较大的文字和我们在上一张幻灯片中看到的一切。

1244
00:57:27,244 --> 00:57:27,976
但是显然，

1245
00:57:28,044 --> 00:57:29,744
它不会都适合一个手机屏幕

1246
00:57:29,813 --> 00:57:30,945
你需要更多的空间。

1247
00:57:31,014 --> 00:57:35,116
那么你所做的就是创建一个控制所有这些的MVC

1248
00:57:35,185 --> 00:57:39,120
UI完全独立于此。

1249
00:57:39,189 --> 00:57:40,722
它只是知道如何管理。

1250
00:57:40,791 --> 00:57:42,624
现在他们可能会分享一个模型，因为也许他们是

1251
00:57:42,693 --> 00:57:44,292
所有查看设置数据库。

1252
00:57:44,361 --> 00:57:45,127
没关系。

1253
00:57:45,195 --> 00:57:48,163
但他们并没有以任何方式相互交谈。

1254
00:57:48,231 --> 00:57:49,397
他们唯一的时间相互交谈，

1255
00:57:49,466 --> 00:57:50,932
是当它第一次来到屏幕上时，

1256
00:57:51,001 --> 00:57:52,634
你会看到一会儿。

1257
00:57:54,271 --> 00:57:55,938
所以我现在有两个MVC，

1258
00:57:56,006 --> 00:57:59,941
控制我想要呈现的所有UI。

1259
00:58:00,010 --> 00:58:01,810
所以让我们使用NavigationController来做

1260
00:58:01,878 --> 00:58:03,244
这些都在屏幕上。

1261
00:58:03,313 --> 00:58:04,913
所以这里有一个NavigationController，

1262
00:58:04,982 --> 00:58:07,281
这只是MVC。

1263
00:58:07,350 --> 00:58:11,586
它没有真正有一个模型是好的，但它有一个看法。

1264
00:58:11,655 --> 00:58:14,989
在这个视图里面有一个特殊的var指向

1265
00:58:15,058 --> 00:58:17,359
到它的视图叫做RootViewController，

1266
00:58:17,427 --> 00:58:20,729
这只是MVC控制器的一点

1267
00:58:20,798 --> 00:58:23,098
在根本是基卡。

1268
00:58:23,166 --> 00:58:25,167
我们在上一页看到的所有设置。

1269
00:58:26,303 --> 00:58:27,001
所以只有这个吧。

1270
00:58:27,070 --> 00:58:28,670
你只是把它放在一些东西上，

1271
00:58:28,739 --> 00:58:29,471
现在你会有一个MVC。

1272
00:58:29,540 --> 00:58:31,839
一旦你这样做，一旦你这样做，

1273
00:58:31,908 --> 00:58:33,909
它将采取MVC的视图和

1274
00:58:33,978 --> 00:58:36,444
把它放在这个小灰色的bar里。

1275
00:58:36,513 --> 00:58:38,780
它会要求它的导航项目

1276
00:58:38,849 --> 00:58:40,382
标题，并获得标题。

1277
00:58:41,918 --> 00:58:42,350
完美的例子

1278
00:58:42,418 --> 00:58:43,785
这是超级简单。

1279
00:58:43,853 --> 00:58:48,323
然后让我们说你在这个UI里面有一个按钮，或者

1280
00:58:48,392 --> 00:58:51,259
像表格中的一行，像让我更多的设置或

1281
00:58:51,328 --> 00:58:52,627
无障碍或无处不在

1282
00:58:52,696 --> 00:58:53,862
你触摸了

1283
00:58:53,931 --> 00:58:57,832
现在，当你触摸到这一点，它将会创建其中之一

1284
00:58:57,901 --> 00:59:00,368
MVC在右边，它创建它在那一刻。

1285
00:59:00,437 --> 00:59:02,804
一碰到它就会创建一个新的。

1286
00:59:02,873 --> 00:59:05,273
每一次你去一张新卡，

1287
00:59:05,341 --> 00:59:06,374
它创建一个新的。

1288
00:59:06,443 --> 00:59:08,843
不回来，但每次你前往一张新卡，

1289
00:59:08,912 --> 00:59:10,278
它总是创造一个新的。

1290
00:59:10,347 --> 00:59:11,613
这是我会说三个或者

1291
00:59:11,682 --> 00:59:12,614
在这张幻灯片中四次

1292
00:59:12,682 --> 00:59:13,715
以确保你了解它。

1293
00:59:15,418 --> 00:59:18,686
这个进入一个新活动的活动叫做segueing。

1294
00:59:18,755 --> 00:59:23,891
这个特殊的段落叫做一个节目或者一个节目。

1295
00:59:23,960 --> 00:59:26,561
这只是意味着导航控制中的一个

1296
00:59:26,630 --> 00:59:28,463
一堆卡。

1297
00:59:28,531 --> 00:59:31,199
现在当你这样做时，你会得到后退按钮

1298
00:59:31,268 --> 00:59:33,134
免费，它只是自动出现在那里，因为

1299
00:59:33,203 --> 00:59:35,036
像我说的顶级酒吧

1300
00:59:35,105 --> 00:59:38,740
由导航控制器的部分视图绘制。

1301
00:59:38,809 --> 00:59:41,409
当您点击后退按钮时，

1302
00:59:41,478 --> 00:59:43,745
当然，这里发生的事情很有趣。

1303
00:59:43,814 --> 00:59:47,883
当然这会滑回去，但MVC怎么了？

1304
00:59:47,952 --> 00:59:49,717
不见了。

1305
00:59:49,786 --> 00:59:52,054
从堆中取消分配。

1306
00:59:53,089 --> 00:59:55,023
所以当你回去的时候，

1307
00:59:55,092 --> 00:59:58,526
顶上的任何卡都被丢弃。

1308
00:59:58,595 --> 01:00:01,696
所以MVC，因为你在这里得到的照片，

1309
01:00:01,765 --> 01:00:03,464
他们很短暂。

1310
01:00:03,533 --> 01:00:05,901
MVC并没有真正坚持长时间。

1311
01:00:05,969 --> 01:00:07,502
现在在导航控制器上的根卡，

1312
01:00:07,571 --> 01:00:08,704
它会坚持很久，

1313
01:00:08,772 --> 01:00:11,439
只要该导航控制器在屏幕上。

1314
01:00:11,508 --> 01:00:14,108
但是大多数MVC来来去去。

1315
01:00:14,177 --> 01:00:17,445
而且它们的模型往往是持续的。

1316
01:00:17,514 --> 01:00:18,379
当您创建一个新的MVC时，

1317
01:00:18,448 --> 01:00:20,715
您通常将其挂接到数据库或网络或

1318
01:00:20,784 --> 01:00:22,184
有些东西，持续的东西

1319
01:00:22,252 --> 01:00:24,452
所以这就是为什么它显示新的东西。

1320
01:00:24,521 --> 01:00:27,189
或者它是一个MVC，每次都显示新的东西。

1321
01:00:28,758 --> 01:00:31,627
所以这就是导航控制器的工作原理。

1322
01:00:34,797 --> 01:00:36,397
我会谈谈一下我们如何勾结所有这一切。

1323
01:00:36,466 --> 01:00:38,333
因为我们当然会这样做

1324
01:00:38,401 --> 01:00:42,104
控制Xcode中的拖动，这就是我们如何钩住所有东西。

1325
01:00:42,172 --> 01:00:43,938
但是我想谈谈一下代码

1326
01:00:44,007 --> 01:00:44,806
背后，所以你知道。

1327
01:00:44,875 --> 01:00:48,310
在这些viewController中有一个重要的var，

1328
01:00:48,379 --> 01:00:49,277
像标签栏控制器，和

1329
01:00:49,346 --> 01:00:50,912
导航控制器和分割视图控制器。

1330
01:00:50,981 --> 01:00:52,547
它被称为viewController，和

1331
01:00:52,615 --> 01:00:56,017
它是一个可选的UIViewControllers数组。

1332
01:00:56,086 --> 01:00:57,318
这意味着不同的东西取决于

1333
01:00:57,387 --> 01:01:02,457
你在哪一个

1334
01:01:02,525 --> 01:01:07,194
每个选项卡，最左边的选项卡的MVC为0，然后为1，

1335
01:01:07,263 --> 01:01:10,632
2，3，4只是其余的MVC。

1336
01:01:10,701 --> 01:01:14,001
对于分割视图，0始终为主，1为始终

1337
01:01:14,070 --> 01:01:16,905
细节，在这个数组中从来没有其他的。

1338
01:01:16,974 --> 01:01:21,743
对于导航控制，0是基卡，而1，2，3，

1339
01:01:21,812 --> 01:01:25,513
4，等等，是堆叠在顶部，顺序。

1340
01:01:25,582 --> 01:01:27,315
所以这样你可以得到他们。

1341
01:01:27,383 --> 01:01:32,520
现在，我们通常不是这个吧，可以设置吧

1342
01:01:32,589 --> 01:01:35,623
我们通常不设这个吧，我们不设置东西，

1343
01:01:35,692 --> 01:01:38,993
我们可以使用我们在UI中所做的事情，我将会展示它们

1344
01:01:39,062 --> 01:01:41,629
你甚至在导航控制器，有推(push)和

1345
01:01:41,698 --> 01:01:45,934
弹(pop)出方法来推动MVC并将其从堆栈中弹出。

1346
01:01:47,537 --> 01:01:51,272
现在，这个var ViewControllers很好，但是

1347
01:01:51,341 --> 01:01:53,642
如何获取Split View Controller或

1348
01:01:53,710 --> 01:01:56,477
如果你在一个？

1349
01:01:56,546 --> 01:01:59,380
好的，如果我是所有的设置MVC或

1350
01:01:59,449 --> 01:02:04,052
我是我们在标签上看到的健康数据之一

1351
01:02:04,121 --> 01:02:06,687
酒吧，我如何获得导航控制器我在，

1352
01:02:06,756 --> 01:02:08,823
或者我所在的分割视图或者我在的标签栏？

1353
01:02:08,892 --> 01:02:11,826
所有UIViewControllers都有这三个vars，

1354
01:02:11,895 --> 01:02:13,461
标签栏控制器，分割视图控制器和

1355
01:02:13,529 --> 01:02:14,528
导航控制器

1356
01:02:14,597 --> 01:02:17,231
如果你是在这些东西之一将返回

1357
01:02:17,300 --> 01:02:18,867
你进来的那个

1358
01:02:18,936 --> 01:02:21,702
如果你不在一个，它将返回零。

1359
01:02:21,771 --> 01:02:22,604
这就是你如何发现

1360
01:02:22,673 --> 01:02:24,039
您所在的Split View Controller

1361
01:02:24,107 --> 01:02:25,941
而且可以使用组合

1362
01:02:26,009 --> 01:02:27,141
例如，如果您是分割视图中的主人，

1363
01:02:27,142 --> 01:02:28,274
这两件事情。

1364
01:02:28,344 --> 01:02:31,513
你可以通过说，找到你的细节MVC

1365
01:02:31,582 --> 01:02:33,415
我在分裂视图控制器是什么？

1366
01:02:33,483 --> 01:02:36,017
获取其视图控制器，查看View Controller子1

1367
01:02:36,086 --> 01:02:38,653
因为这总是细节。

1368
01:02:38,721 --> 01:02:39,521
所以我只是点了一下，并且得到了。

1369
01:02:39,522 --> 01:02:40,322
你看到了吧?

1370
01:02:40,390 --> 01:02:43,058
我使用问号，可选链接在那里

1371
01:02:43,126 --> 01:02:44,992
因为我可能不在分割视图控制器。

1372
01:02:45,061 --> 01:02:46,694
那么显然会返回零

1373
01:02:46,763 --> 01:02:49,864
我的细节，这很好，如果我不在，它将是零

1374
01:02:49,933 --> 01:02:51,666
一个分割视图控制器显然没有细节。

1375
01:02:54,237 --> 01:02:55,904
现在，我们如何把这些东西连接起来？

1376
01:02:55,972 --> 01:02:58,439
我们当然会用图形来做。

1377
01:02:58,508 --> 01:03:00,775
我们先来看看分割视图

1378
01:03:00,843 --> 01:03:02,510
我们怎么做

1379
01:03:02,579 --> 01:03:05,279
现在创建一个新的视图控制器，无论是一个

1380
01:03:05,348 --> 01:03:07,215
的这些视图控制器的视图控制器我们

1381
01:03:07,284 --> 01:03:09,517
正在谈论或只是一个常规的视图控制器。

1382
01:03:09,586 --> 01:03:12,186
你下到对象托盘，把它拖出去

1383
01:03:12,255 --> 01:03:15,456
进入你的故事板就像一个按钮，除了你只是

1384
01:03:15,525 --> 01:03:17,825
拖动到开放空间，并在那里创建。

1385
01:03:17,894 --> 01:03:20,562
现在，当您拖动分割视图控制器时，它是

1386
01:03:20,630 --> 01:03:24,666
实际上会拖出一些空，细节和主人。

1387
01:03:25,602 --> 01:03:26,467
你永远不想要

1388
01:03:26,536 --> 01:03:28,236
我不知道为什么它真的这样做。

1389
01:03:28,305 --> 01:03:29,737
只是删除那些。

1390
01:03:29,806 --> 01:03:31,839
你显然会像你的MVC那样

1391
01:03:31,908 --> 01:03:34,208
计算器和您的图形视图控制器坐在

1392
01:03:34,277 --> 01:03:36,410
你的故事板，你会拖动分割视图

1393
01:03:36,479 --> 01:03:38,779
控制器，你会把它连接到那些。

1394
01:03:38,848 --> 01:03:42,083
所以你会删除任何额外的垃圾出来。

1395
01:03:42,152 --> 01:03:45,319
然后你就像我们一样按Ctrl +拖动，

1396
01:03:45,388 --> 01:03:48,422
我们最喜欢的手势在脸部构建器中，是Ctrl +拖动。

1397
01:03:48,491 --> 01:03:50,992
我们只是从分割视图控制器中Ctrl +拖动

1398
01:03:51,061 --> 01:03:53,194
对master和detail，所以我起来。

1399
01:03:53,263 --> 01:03:55,263
所以这就是这样的。

1400
01:03:55,332 --> 01:03:57,432
在这里我有左边的分割视图控制器。

1401
01:03:57,501 --> 01:03:59,767
我有顶部的计算器视图控制

1402
01:03:59,836 --> 01:04:02,236
底部有一个图形和控制视图。

1403
01:04:02,305 --> 01:04:03,370
所以我只是要控制，

1404
01:04:03,439 --> 01:04:04,972
从分割视图控制器拖动，

1405
01:04:05,041 --> 01:04:06,174
计算器控制器。

1406
01:04:06,243 --> 01:04:08,510
这个黑色的窗口会出现。

1407
01:04:08,578 --> 01:04:12,914
我将从列表中选择主视图控制器

1408
01:04:12,983 --> 01:04:16,951
那会把这一个挂在我的主人身上。

1409
01:04:17,020 --> 01:04:20,155
然后，我要按Ctrl +拖动到底部，黑色

1410
01:04:20,223 --> 01:04:22,924
窗口出来我要选择Detail View Controller

1411
01:04:22,993 --> 01:04:24,659
那么它会建立连接。

1412
01:04:25,829 --> 01:04:27,361
好的，就这么简单。

1413
01:04:27,430 --> 01:04:29,363
现在你已经拥有了主人的拆分视图

1414
01:04:29,432 --> 01:04:31,566
您的控制器的计算器和

1415
01:04:31,635 --> 01:04:34,169
这将是一个图形视图控制器的细节。

1416
01:04:35,405 --> 01:04:37,205
现在，这里有一件有趣的事情，

1417
01:04:37,274 --> 01:04:39,774
这个拆分视图在iPhone上不起作用。

1418
01:04:39,843 --> 01:04:43,344
它适用于iPhone plus，iPhone 6 plus或

1419
01:04:43,413 --> 01:04:46,013
七加，大的那种，但不行

1420
01:04:46,082 --> 01:04:48,783
一个普通的iPhone，它只是不够的屏幕不动产

1421
01:04:48,851 --> 01:04:52,053
真的做分割视图的事情，所以我们做不到。

1422
01:04:52,122 --> 01:04:54,989
那么，我们真正想做的就是建立一个UI

1423
01:04:55,058 --> 01:04:56,191
适用于所有设备。

1424
01:04:56,259 --> 01:04:59,827
所以要做到这一点，我们做的是我们要包装

1425
01:04:59,896 --> 01:05:02,763
master 和detail ，如果我们想要的。

1426
01:05:02,832 --> 01:05:05,466
我们要将它们包装在导航控制器中。

1427
01:05:05,535 --> 01:05:06,901
然后当他们在iPhone上时，

1428
01:05:06,969 --> 01:05:08,102
他们不会使用分割视图部分，

1429
01:05:08,171 --> 01:05:09,838
他们只需使用导航控制器。

1430
01:05:11,041 --> 01:05:13,808
这真的很酷，它如何显示出来。

1431
01:05:13,876 --> 01:05:17,178
包装视图控制器的方式在那里，

1432
01:05:17,246 --> 01:05:19,047
你想把它包装在导航控制器中，

1433
01:05:19,116 --> 01:05:20,282
你只需去编辑器菜单，

1434
01:05:20,350 --> 01:05:22,116
我们嵌入和堆叠视图的同一个地方，

1435
01:05:22,185 --> 01:05:23,151
其中一些。

1436
01:05:23,220 --> 01:05:26,887
并且您选择您的MVC的整个场景，和

1437
01:05:26,956 --> 01:05:29,623
你去编辑器菜单和

1438
01:05:29,692 --> 01:05:31,993
你说嵌入在导航控制器。

1439
01:05:32,062 --> 01:05:34,295
所以我选择了顶部，计算和控制

1440
01:05:34,363 --> 01:05:35,563
当我这样做，

1441
01:05:35,632 --> 01:05:38,199
它将放在导航控制器中。

1442
01:05:38,268 --> 01:05:40,067
你看到了吗？

1443
01:05:40,136 --> 01:05:42,236
现在，我看到了翻转的视图，它指向一个导航

1444
01:05:42,305 --> 01:05:44,372
控制器，所以这个翻盖视图的主人其实是

1445
01:05:44,441 --> 01:05:46,808
那个导航控制器，然后导航

1446
01:05:46,876 --> 01:05:50,311
控制器根视图控制器是计算器。

1447
01:05:50,379 --> 01:05:52,146
因此，如果您使用的是可以进行拆分视图的设备，

1448
01:05:52,215 --> 01:05:53,114
像一个iPad或一个加号，

1449
01:05:53,183 --> 01:05:55,316
你将得到整个分割视图效果。

1450
01:05:55,385 --> 01:05:56,684
但如果你只是一个iPhone，

1451
01:05:56,753 --> 01:05:58,486
它不会做分割视图。

1452
01:05:58,555 --> 01:06:00,721
它只是要做导航控制器。

1453
01:06:00,790 --> 01:06:01,989
所以，当你看细节，

1454
01:06:02,058 --> 01:06:04,192
它会滑入它。

1455
01:06:04,261 --> 01:06:06,761
而如果你在iPad上的横屏，

1456
01:06:06,830 --> 01:06:09,764
你会同时看到Master和Detail。

1457
01:06:09,833 --> 01:06:13,568
现在，你也可以做同样的事情 - 是的，等等

1458
01:06:13,637 --> 01:06:15,703
UINavigationController是master，

1459
01:06:15,771 --> 01:06:17,639
正如我所说的。

1460
01:06:17,707 --> 01:06:20,074
所以你可以做同样的事情与细节。

1461
01:06:20,143 --> 01:06:22,410
现在为什么要用细节做这个？

1462
01:06:22,479 --> 01:06:24,111
因为你已经完成了与主人和

1463
01:06:24,180 --> 01:06:26,513
所以你必须点击主人才能得到细节，

1464
01:06:26,582 --> 01:06:28,516
所以你已经有一个导航控制器，

1465
01:06:28,585 --> 01:06:29,584
这是真的。

1466
01:06:29,653 --> 01:06:32,186
但是对于细节来说真是太好了

1467
01:06:32,255 --> 01:06:35,223
在导航控制器中你得到那个小标题栏，

1468
01:06:35,292 --> 01:06:36,524
你知道小灰标题栏吗？

1469
01:06:36,593 --> 01:06:37,391
所以现在，你的master和

1470
01:06:37,460 --> 01:06:39,561
你的detail都有顶部的标题栏

1471
01:06:39,629 --> 01:06:40,961
他们很好地配对。

1472
01:06:41,030 --> 01:06:42,930
所以如果你想要你的细节标题，

1473
01:06:42,999 --> 01:06:43,598
这是一件好事。

1474
01:06:43,666 --> 01:06:45,566
唯一要小心的事情是

1475
01:06:45,635 --> 01:06:48,269
现在你的细节不是一个图形视图控制器。

1476
01:06:48,338 --> 01:06:50,638
您的细节现在是导航控制器。

1477
01:06:50,706 --> 01:06:52,540
所以如果你想获得图形视图控制器和

1478
01:06:52,609 --> 01:06:54,342
喜欢说话，告诉它什么图或

1479
01:06:54,410 --> 01:06:56,911
像这样，你需要得到根视图

1480
01:06:56,980 --> 01:06:58,580
导航控制器的控制器。

1481
01:06:59,982 --> 01:07:01,549
所以这只是微妙的差异

1482
01:07:01,617 --> 01:07:03,685
如果您将细节包裹在导航控制器中，

1483
01:07:03,753 --> 01:07:05,853
细节已经成为导航控制器。

1484
01:07:05,922 --> 01:07:07,588
很容易得到图形视图控制器，

1485
01:07:07,657 --> 01:07:09,724
cuz是导航控制器的根视图控制器。

1486
01:07:12,095 --> 01:07:15,096
那就是如何连接分割视图

1487
01:07:15,165 --> 01:07:17,298
它跨越平台，所有设备。

1488
01:07:18,568 --> 01:07:21,302
我们要谈谈的最后一件事是断断续续。

1489
01:07:21,370 --> 01:07:25,406
所以我们知道如何连接分割视图控制器

1490
01:07:25,475 --> 01:07:26,974
我们知道如何做一个导航控件，

1491
01:07:27,043 --> 01:07:29,376
我们只需将其嵌入到导航控制器中。

1492
01:07:29,445 --> 01:07:31,346
我没有谈论标签栏控制器的方式，

1493
01:07:31,414 --> 01:07:32,446
但这很容易。

1494
01:07:32,515 --> 01:07:35,450
您只需拖动标签栏控制器并按住CTRL +拖动即可

1495
01:07:35,518 --> 01:07:38,152
对于您想要显示的所有MVC，

1496
01:07:38,221 --> 01:07:42,223
你甚至可以拖动小图标

1497
01:07:42,291 --> 01:07:43,724
把它们放在一起。

1498
01:07:43,793 --> 01:07:46,227
您甚至可以在界面构建器中以文本形式设置图标

1499
01:07:46,296 --> 01:07:46,961
与检查员。

1500
01:07:47,029 --> 01:07:49,797
所以，标签栏，这么简单，我甚至不想浪费时间

1501
01:07:49,866 --> 01:07:52,633
显示它，但是我们知道如何联系起来和控制

1502
01:07:52,702 --> 01:07:56,971
拖动和线路，或嵌入做导航控制器。

1503
01:07:57,040 --> 01:07:59,540
我们如何从一个到另一个，如在导航

1504
01:07:59,609 --> 01:08:02,109
控制器，我们如何从所有设置转到设置

1505
01:08:02,178 --> 01:08:03,244
从设置到可访问性，

1506
01:08:03,312 --> 01:08:07,081
和更大的文本的可访问性？

1507
01:08:07,149 --> 01:08:09,651
我们如何设置这个转换或我们如何做

1508
01:08:09,719 --> 01:08:13,354
这样我们在我们的计算器分割视图中按一个按钮

1509
01:08:13,423 --> 01:08:16,557
并且它导致该图被一个新的图替换？

1510
01:08:16,626 --> 01:08:17,157
我们该怎么做？

1511
01:08:17,226 --> 01:08:19,226
我们用所谓的段落来做。

1512
01:08:19,295 --> 01:08:20,628
我刚才提到这个。

1513
01:08:23,032 --> 01:08:24,832
这些是存在的种类。

1514
01:08:24,900 --> 01:08:26,066
有一个show segue。

1515
01:08:26,135 --> 01:08:28,436
这意味着，如果您在导航控制器中，

1516
01:08:28,504 --> 01:08:29,537
滑一张卡片。

1517
01:08:31,441 --> 01:08:32,740
有显示详细信息，

1518
01:08:32,809 --> 01:08:34,208
如果您是导航控制器，

1519
01:08:34,277 --> 01:08:36,044
仍然意味着滑动一张卡片。

1520
01:08:36,112 --> 01:08:37,578
但是，如果您在Split View中，

1521
01:08:37,647 --> 01:08:40,982
这意味着把这个新的MVC放在细节的地方。

1522
01:08:41,051 --> 01:08:42,683
这就是为什么它被称为显示细节。

1523
01:08:42,752 --> 01:08:44,552
所以显示细节的行为有所不同

1524
01:08:44,621 --> 01:08:45,653
无论你是在Split View还是

1525
01:08:45,722 --> 01:08:48,122
无论您是在导航控制器。

1526
01:08:48,191 --> 01:08:50,591
Modal segue，这很有趣。

1527
01:08:50,660 --> 01:08:53,227
它占用了整个屏幕，并让它

1528
01:08:53,296 --> 01:08:57,831
您正在切入自己的整个屏幕的MVC。

1529
01:08:57,900 --> 01:09:00,034
现在，这些对于用户来说可能有些令人不安，

1530
01:09:00,103 --> 01:09:01,869
我不能回到我所在的地方，

1531
01:09:01,938 --> 01:09:03,804
cuz没有后退按钮或任何东西。

1532
01:09:03,873 --> 01:09:05,239
无论什么MVC出现

1533
01:09:05,308 --> 01:09:07,775
接管屏幕必须提供一些UI才能离开

1534
01:09:07,844 --> 01:09:10,945
有取消或完成，或某事。

1535
01:09:11,013 --> 01:09:13,915
所以我们试图远离莫代尔，如果可以的话。

1536
01:09:13,983 --> 01:09:18,019
所以Popover和Modal是一样的，但是

1537
01:09:18,087 --> 01:09:20,621
而不是接管整个屏幕，它只是放在了

1538
01:09:20,690 --> 01:09:22,656
一个小窗口，一个小窗口，

1539
01:09:22,725 --> 01:09:24,958
你已经看到，特别是在iPad上。

1540
01:09:25,027 --> 01:09:28,229
它仍然是模态的，因为如果你点击任何地方，

1541
01:09:28,297 --> 01:09:29,797
popover消失了。

1542
01:09:29,866 --> 01:09:32,233
所以它本质上是模态的。

1543
01:09:32,302 --> 01:09:33,634
这比起模式有点好一点，

1544
01:09:33,703 --> 01:09:35,737
因为你真的可以看到背景有点灰白了。

1545
01:09:35,805 --> 01:09:37,772
如果你不想在popover中有什么，

1546
01:09:37,840 --> 01:09:39,541
只需点击别的地方，它就会消失。

1547
01:09:39,609 --> 01:09:42,076
所以是的，popover比一点点更好。

1548
01:09:42,145 --> 01:09:44,078
但它只适用于相当大的屏幕，

1549
01:09:44,147 --> 01:09:46,247
除非你有一个非常小的窗口弹出窗口。

1550
01:09:47,183 --> 01:09:51,319
现在我要强调了

1551
01:09:51,387 --> 01:09:54,421
第二次我之前说的话总是创造

1552
01:09:54,490 --> 01:09:56,824
一个新的MVC实例。

1553
01:09:56,893 --> 01:10:00,695
所有这些，所有的，所有的，modal，popover，显示，

1554
01:10:00,764 --> 01:10:01,495
在最小的时候，

1555
01:10:01,564 --> 01:10:04,265
显示细节，甚至在分割视图中显示细节。

1556
01:10:04,334 --> 01:10:07,635
如果你有一个计算器，你说图表我的功能和

1557
01:10:07,704 --> 01:10:09,470
你转到图形视图控制器，

1558
01:10:09,539 --> 01:10:11,372
它抛出那里的那个

1559
01:10:11,441 --> 01:10:14,908
在那里放一个新的，总是创造新的MVC。

1560
01:10:14,977 --> 01:10:18,379
所以认为这些MVC是短暂的，他们还活着，

1561
01:10:18,448 --> 01:10:20,280
他们做他们的工作，他们离开了。

1562
01:10:20,349 --> 01:10:23,784
他们不会生活在你身边，长生命周期。

1563
01:10:23,853 --> 01:10:25,686
现在主人和分裂视图。

1564
01:10:25,755 --> 01:10:27,121
导航的根视图，

1565
01:10:27,190 --> 01:10:28,823
他们往往生命周期相当长。

1566
01:10:28,891 --> 01:10:31,526
但即使是那些，如果分割视图，如果那个导航

1567
01:10:31,594 --> 01:10:33,428
要离开屏幕，他们也走了。

1568
01:10:35,698 --> 01:10:37,398
那么我们如何使这些变化发生？

1569
01:10:37,467 --> 01:10:39,233
当然，我们使用控制拖动。

1570
01:10:39,302 --> 01:10:41,569
我们喜欢使用控制拖动，所以在这里

1571
01:10:41,637 --> 01:10:43,404
示例是计算器示例。

1572
01:10:43,472 --> 01:10:44,672
我有一个拆分视图。

1573
01:10:44,740 --> 01:10:46,874
在我的计算器里，右上角

1574
01:10:46,943 --> 01:10:49,477
我有一个按钮很难看到，但是

1575
01:10:49,545 --> 01:10:51,111
它是一张图的一张照片。

1576
01:10:51,180 --> 01:10:52,813
那就是按钮，当我按下它，

1577
01:10:52,882 --> 01:10:55,549
它会在我的计算器中进行任何图形化。

1578
01:10:55,618 --> 01:10:59,019
所以如果我输入例如m余弦，

1579
01:10:59,088 --> 01:11:04,258
它会画一个余弦波，那就是那个按钮。

1580
01:11:04,327 --> 01:11:07,661
所以我刚进入界面生成器，控制拖动

1581
01:11:07,730 --> 01:11:10,564
从那个按钮到那里的细节。

1582
01:11:10,633 --> 01:11:11,532
放开时，

1583
01:11:11,601 --> 01:11:13,634
它只会放一个黑色的窗户，

1584
01:11:13,703 --> 01:11:15,502
我会给你一些细节。

1585
01:11:15,571 --> 01:11:16,003
看起来像这样。

1586
01:11:16,072 --> 01:11:18,106
我会选择我想要的segue。

1587
01:11:18,174 --> 01:11:21,675
那么，由于这是Split视图，如果可以的话，

1588
01:11:21,744 --> 01:11:23,177
我要展示细节。

1589
01:11:23,245 --> 01:11:25,079
将其放在分割视图的右侧。

1590
01:11:25,148 --> 01:11:27,348
现在，如果我在同一个故事板，但是

1591
01:11:27,417 --> 01:11:29,583
我在一个iPhone非加，

1592
01:11:29,652 --> 01:11:31,251
那么即使我在这里挑选展示细节，

1593
01:11:31,320 --> 01:11:33,754
它仍然要做导航控制器展示，

1594
01:11:33,823 --> 01:11:36,291
因为没有分割视图侧，当我在iPhone上。

1595
01:11:37,760 --> 01:11:39,894
所以我选择我想要的segue类型

1596
01:11:39,962 --> 01:11:41,229
它创建了segue。

1597
01:11:41,297 --> 01:11:43,564
它出现在你的故事板上，

1598
01:11:43,633 --> 01:11:45,232
甚至可以点击并检查。

1599
01:11:45,301 --> 01:11:47,467
其实你总是想点击

1600
01:11:47,536 --> 01:11:49,170
那件事和检查它。

1601
01:11:49,239 --> 01:11:52,173
你不想在这里设置这个东西

1602
01:11:52,242 --> 01:11:53,841
是标识符。

1603
01:11:53,910 --> 01:11:56,677
每个segue都有一个标识符，它只是字符串和

1604
01:11:56,745 --> 01:12:00,013
该标识符是您在代码中使用的标识符

1605
01:12:00,082 --> 01:12:02,649
谈论这个段落。

1606
01:12:02,718 --> 01:12:04,252
我会谈谈你有什么

1607
01:12:04,320 --> 01:12:07,120
一直在谈论关于segues，任何时刻在这里。

1608
01:12:07,189 --> 01:12:08,389
所以总是这样做。

1609
01:12:08,457 --> 01:12:09,223
而你想设置它，

1610
01:12:09,291 --> 01:12:12,059
标识符就是那种说什么的东西

1611
01:12:12,128 --> 01:12:12,660
segue是的。

1612
01:12:12,729 --> 01:12:14,995
所以在这种情况下，它显示一个图表，所以

1613
01:12:15,064 --> 01:12:16,764
我称这个表图。

1614
01:12:19,802 --> 01:12:22,236
这就是你如何设置你的段落。

1615
01:12:22,304 --> 01:12:24,204
导航控制器也是如此。

1616
01:12:24,273 --> 01:12:25,673
如果你有一个导航控制器和

1617
01:12:25,742 --> 01:12:28,209
你有一个按钮，导致另一张卡片滑过你

1618
01:12:28,278 --> 01:12:30,445
只需控制从该按钮拖动到另一个MVC。

1619
01:12:30,513 --> 01:12:33,915
然后你使用show segue，它会工作。

1620
01:12:33,983 --> 01:12:35,049
一切都在里面，

1621
01:12:35,117 --> 01:12:37,751
嵌入导航控制器当然。

1622
01:12:37,820 --> 01:12:39,720
那么你可以用这些标识来做什么呢？

1623
01:12:39,789 --> 01:12:42,457
实际上可能会导致发生

1624
01:12:42,525 --> 01:12:45,425
代码，与performSegue withIdentifier，但是

1625
01:12:45,494 --> 01:12:47,961
我不会说这个，我们永远不会这样做。

1626
01:12:48,030 --> 01:12:49,329
我们总是会有按钮，

1627
01:12:49,398 --> 01:12:50,764
好吧，我不会说我们永远不会这样做，

1628
01:12:50,833 --> 01:12:52,767
但是我们不会在你的任务三中这样做，

1629
01:12:52,835 --> 01:12:53,267
这是肯定的。

1630
01:12:53,336 --> 01:12:54,301
这很罕见

1631
01:12:54,370 --> 01:12:56,303
但是你可以用performSegue来做。

1632
01:12:56,372 --> 01:12:59,006
但是标识符的使用不是很重要

1633
01:12:59,075 --> 01:13:00,774
发生的事情发生了

1634
01:13:00,843 --> 01:13:02,643
当按下按钮时自动。

1635
01:13:02,712 --> 01:13:04,645
这是为了准备一个segue。

1636
01:13:04,714 --> 01:13:08,148
这是最重要的方法

1637
01:13:08,217 --> 01:13:11,552
多个MVC编程正在为segue准备

1638
01:13:11,620 --> 01:13:15,489
方法，我会在这里一会儿给你看，好的。

1639
01:13:15,558 --> 01:13:18,058
并记住，我们都在追求一个新的MVC

1640
01:13:18,127 --> 01:13:20,227
新鲜的，所以它总是生的。

1641
01:13:20,296 --> 01:13:22,830
所以我们必须做好准备，做这些事情。

1642
01:13:24,734 --> 01:13:25,466
这是方法。

1643
01:13:25,534 --> 01:13:27,334
它被称为准备segue，和

1644
01:13:27,403 --> 01:13:30,972
它也有一个sender参数。

1645
01:13:31,040 --> 01:13:34,375
沿着第一个参数传递的segue

1646
01:13:34,444 --> 01:13:37,611
只是一个容纳有趣的容器

1647
01:13:37,680 --> 01:13:39,613
关于segue的信息。

1648
01:13:39,682 --> 01:13:42,049
例如，标识符，显示图。

1649
01:13:43,585 --> 01:13:47,187
非常重要的是，你所控制的控制器

1650
01:13:47,256 --> 01:13:48,455
也是因为整体在这里，

1651
01:13:48,524 --> 01:13:51,292
你假设正在准备这个MVC

1652
01:13:51,360 --> 01:13:52,593
来屏幕

1653
01:13:52,661 --> 01:13:53,794
做这样的工作

1654
01:13:53,862 --> 01:13:57,431
你从这个小小的对象得到这个东西。

1655
01:13:57,499 --> 01:14:00,301
发件人有点像按钮，

1656
01:14:00,370 --> 01:14:02,636
当我们在那里采取行动(action)时，按钮发送者(sender)。

1657
01:14:02,705 --> 01:14:05,505
这正是什么对象煽动这个。

1658
01:14:05,574 --> 01:14:08,108
所以在计算器的例子中，你会有一个按钮

1659
01:14:08,177 --> 01:14:11,044
点击导致这个segue，它将是那个按钮。

1660
01:14:11,113 --> 01:14:12,646
好的，这个按钮导致了segue。

1661
01:14:12,715 --> 01:14:16,884
但是，任何事情，当我们看到这个例子是任何事情

1662
01:14:16,952 --> 01:14:20,220
的所有设置，我们点击表格视图单元格

1663
01:14:20,289 --> 01:14:23,257
没有按钮，但是单元格在所谓的表视图中，

1664
01:14:23,325 --> 01:14:25,692
我们将在下一周再谈谈一周。

1665
01:14:25,761 --> 01:14:27,561
所以可以是发件人(sender)。

1666
01:14:27,630 --> 01:14:30,364
或者您可能已经在上一张幻灯片上执行了删除，

1667
01:14:30,433 --> 01:14:32,066
这实际上让你设置发件人(sender)

1668
01:14:32,134 --> 01:14:35,769
你已经告诉任何你想要的，也可以是零。

1669
01:14:35,838 --> 01:14:36,971
我们不这么用。

1670
01:14:38,307 --> 01:14:40,774
我是第一件事

1671
01:14:40,843 --> 01:14:42,242
做将要得到的标识符。

1672
01:14:42,311 --> 01:14:43,477
请注意，它可以是零

1673
01:14:43,546 --> 01:14:47,447
我会说，如果让我们从那里走出来。

1674
01:14:47,516 --> 01:14:49,950
我需要这个标识符，我需要知道我是谁

1675
01:14:50,019 --> 01:14:52,486
因为我可能有三个按钮

1676
01:14:52,555 --> 01:14:55,355
在我的计算器上，分为三种不同的东西。

1677
01:14:55,424 --> 01:14:57,424
现在你不会在任务三，但你可以

1678
01:14:57,493 --> 01:14:59,192
有多个按钮分隔到不同的东西。

1679
01:14:59,261 --> 01:15:02,062
所以你需要知道你在说什么。

1680
01:15:02,131 --> 01:15:05,032
所以你打开它，然后你检查的情况。

1681
01:15:05,101 --> 01:15:07,301
而在显示图形的情况下，

1682
01:15:07,370 --> 01:15:10,204
这是我们要在这里做的那个，

1683
01:15:10,272 --> 01:15:16,010
我们将准备图形化的MVC来完成它的工作。

1684
01:15:16,078 --> 01:15:20,314
现在，为了与图形化MVC交谈，

1685
01:15:20,383 --> 01:15:22,983
我们必须将其作为图形控制器。

1686
01:15:23,052 --> 01:15:25,653
现在该目的地视图控制器的类型

1687
01:15:25,722 --> 01:15:29,623
在segue对象中只是UIViewController，

1688
01:15:29,692 --> 01:15:32,626
它不知道它是一个图形视图控制器或

1689
01:15:32,695 --> 01:15:35,262
像这样的东西只是UIViewController。

1690
01:15:35,330 --> 01:15:37,064
所以我们必须使用，

1691
01:15:37,133 --> 01:15:40,734
记得“as？”我告诉你，你可以投掷任何东西。

1692
01:15:40,803 --> 01:15:44,438
不只是任何对象，你可以转一个UIViewController来尝试

1693
01:15:44,507 --> 01:15:47,007
并将其转换为特定的视图控制器。

1694
01:15:47,076 --> 01:15:49,910
所以在这里我要尝试投射目的地视图

1695
01:15:49,979 --> 01:15:51,445
控制器成为图形控制器。

1696
01:15:51,514 --> 01:15:54,014
我要承担图形控制器的类型

1697
01:15:54,083 --> 01:15:56,884
我的图MVC的控制器。

1698
01:15:56,953 --> 01:15:58,819
如果我能做到这一点，我应该是

1699
01:15:58,888 --> 01:16:01,555
因为我知道这是show graph segue，所以

1700
01:16:01,623 --> 01:16:03,224
我最好是，如果，

1701
01:16:03,292 --> 01:16:05,959
如果我不是那么可能我想在这里提出一个例外。

1702
01:16:06,028 --> 01:16:07,961
因为我真的希望能够做到这一点。

1703
01:16:08,030 --> 01:16:10,364
也许我在那里用感叹号而不是

1704
01:16:10,432 --> 01:16:14,101
作为问号，因为如果我这样做，那将是坏的

1705
01:16:14,169 --> 01:16:15,836
它并不是graphcontroller。

1706
01:16:15,905 --> 01:16:17,505
但无论如何，我得到graphcontroller所以

1707
01:16:17,573 --> 01:16:22,409
现在VC，这个变量VC是类型graphcontroller，所以

1708
01:16:22,478 --> 01:16:24,511
我可以开始设置vars，

1709
01:16:24,580 --> 01:16:27,948
调用方法，无论我需要做什么来准备

1710
01:16:28,017 --> 01:16:30,417
图控制器做它的工作。

1711
01:16:30,486 --> 01:16:30,918
现在在计算器的情况下，

1712
01:16:30,987 --> 01:16:33,954
我在做什么是我要以某种方式去

1713
01:16:34,023 --> 01:16:36,390
设置你控制的图形的模型

1714
01:16:36,459 --> 01:16:39,260
一些东西来显示我想要的图形。

1715
01:16:39,328 --> 01:16:41,095
根据我的计算器是什么

1716
01:16:41,164 --> 01:16:43,130
所以，我准备做它做的事情。

1717
01:16:43,198 --> 01:16:46,033
我几乎不会再和这个事情说话了。

1718
01:16:46,102 --> 01:16:49,803
所以我会给它所需要的所有信息

1719
01:16:49,872 --> 01:16:51,572
去找工作

1720
01:16:51,641 --> 01:16:55,242
这是一次设置和

1721
01:16:55,311 --> 01:16:57,411
这就是MVC需要工作的方式，面向对象。

1722
01:16:57,480 --> 01:16:59,580
他们设置一次，然后他们只是自己生活，

1723
01:16:59,648 --> 01:17:00,414
他们做自己的工作。

1724
01:17:00,483 --> 01:17:03,384
他们不会和带领他们的人交谈

1725
01:17:03,452 --> 01:17:04,585
给任何人

1726
01:17:04,654 --> 01:17:05,453
他们自己生活。

1727
01:17:06,989 --> 01:17:09,923
所以你可以做任何你想要到这里，试图做到这一点。

1728
01:17:09,992 --> 01:17:12,292
有一件事要警告你，而且

1729
01:17:12,361 --> 01:17:14,295
一半你会跳过这个。

1730
01:17:14,363 --> 01:17:16,062
当你做这个准备

1731
01:17:16,131 --> 01:17:17,832
的图形控制器，

1732
01:17:17,900 --> 01:17:22,269
该图形控制器的outlet尚未设置。

1733
01:17:24,140 --> 01:17:26,840
我告诉你，IOS真的真的挂了这些outlet

1734
01:17:26,909 --> 01:17:29,442
很快，但这是一个不太麻烦的情况

1735
01:17:29,511 --> 01:17:30,744
他们足够快了

1736
01:17:30,813 --> 01:17:34,414
当你做vc.property1 =任何，

1737
01:17:34,483 --> 01:17:37,651
vc.callMethodToSetItUp，当时，

1738
01:17:37,720 --> 01:17:39,953
没有一个vc的outlet设置。

1739
01:17:40,022 --> 01:17:41,588
所以你不能在UI中做任何事情。

1740
01:17:41,657 --> 01:17:44,058
所以如果你正在收集什么信息，

1741
01:17:44,126 --> 01:17:44,859
在UI中做，

1742
01:17:44,927 --> 01:17:47,360
你必须将它存储在某些vars或某物中。

1743
01:17:47,429 --> 01:17:49,496
而后来，无论是在确定了

1744
01:17:49,565 --> 01:17:52,165
那些出口中心，或者我会教你看法

1745
01:17:52,234 --> 01:17:53,701
控制器生命周期下周。

1746
01:17:53,770 --> 01:17:55,669
还有其他的方法会在以后发生，

1747
01:17:55,738 --> 01:17:58,438
您可以确定outlet已设置。

1748
01:17:58,507 --> 01:18:01,008
所以这是红色的，任何时候我把东西放在里面，

1749
01:18:01,077 --> 01:18:02,342
你真的要注意

1750
01:18:02,411 --> 01:18:04,778
所以在图形控件中没有设置outlet

1751
01:18:04,847 --> 01:18:07,715
准备时，准备的过程。

1752
01:18:09,418 --> 01:18:11,652
你也可以防止发生事件，

1753
01:18:11,720 --> 01:18:14,454
如果计算器和你试图打图，

1754
01:18:14,523 --> 01:18:16,289
你正在二进制操作的中间，

1755
01:18:16,358 --> 01:18:17,624
待处理二进制操作

1756
01:18:17,693 --> 01:18:19,827
那么你不能图表。

1757
01:18:19,896 --> 01:18:21,895
没有办法绘制待处理的二进制操作。

1758
01:18:21,964 --> 01:18:24,631
三次，三次是什么图？

1759
01:18:24,700 --> 01:18:25,532
没什么。

1760
01:18:25,601 --> 01:18:27,001
所以，你想阻止它。

1761
01:18:27,069 --> 01:18:29,202
所以，在你的任务三，你会想使用这个

1762
01:18:29,271 --> 01:18:31,071
方法并且能够控制共享执行段，

1763
01:18:31,140 --> 01:18:32,639
你会返回false的。

1764
01:18:32,708 --> 01:18:36,277
当你正在等待操作的中间，好吗？

1765
01:18:37,480 --> 01:18:39,780
好了 今天就讲到这里

1766
01:18:39,849 --> 01:18:41,381
本周没有星期五部分。

1767
01:18:41,450 --> 01:18:44,785
下周五部分将进行性能分析

1768
01:18:44,853 --> 01:18:46,453
这将是一个额外的信用项目

1769
01:18:46,522 --> 01:18:48,255
在作业三，这样做。

1770
01:18:48,323 --> 01:18:49,923
你会看到，当它熄灭。

1771
01:18:49,991 --> 01:18:50,824
下周我要做

1772
01:18:50,893 --> 01:18:52,892
关于所有这些多个MVC的东西的演示。

1773
01:18:52,961 --> 01:18:55,195
我将开始谈论View Controller生命周期。

1774
01:18:55,264 --> 01:18:57,564
然后是超重要的话题，协议(Protocol)和

1775
01:18:57,633 --> 01:19:02,436
委托(Delegate)

1776
01:19:02,504 --> 01:19:04,504
UI的东西，如滚动视图和表视图。

1777
01:19:04,573 --> 01:19:07,341
我们将在下周开始你所学到的所有东西

1778
01:19:07,410 --> 01:19:08,275
现在有点基础。

1779
01:19:08,343 --> 01:19:10,811
Swift和视图和多个MVC。

1780
01:19:10,879 --> 01:19:12,946
一个你现在得到的基础，你可以开始做这些

1781
01:19:13,014 --> 01:19:14,715
更强大的对象。

1782
01:19:14,784 --> 01:19:18,685
现在，作业三已经在课堂上了。

1783
01:19:18,754 --> 01:19:20,154
你现在可以开始吧。

1784
01:19:20,223 --> 01:19:22,189
它真的有两个要点。

1785
01:19:22,257 --> 01:19:25,759
一个是自定义UI视图，进行图形化。

1786
01:19:25,828 --> 01:19:28,461
一个真正的自定义MVC，做图形。

1787
01:19:28,530 --> 01:19:30,264
那个事情完全独立于你

1788
01:19:30,333 --> 01:19:31,732
计算器

1789
01:19:31,801 --> 01:19:33,867
其实我建议你创建一个新的应用程序

1790
01:19:33,936 --> 01:19:35,736
创建MVC。

1791
01:19:35,805 --> 01:19:37,671
因为如果你不想被你的计算器污染，

1792
01:19:37,739 --> 01:19:40,341
它只是一个通用的图形化MVC。

1793
01:19:40,409 --> 01:19:41,275
一旦你有了，

1794
01:19:41,343 --> 01:19:43,710
你会把它与你的计算器相结合

1795
01:19:43,779 --> 01:19:44,444
就像我在说这个，

1796
01:19:44,513 --> 01:19:46,013
你要点击一个按钮，和

1797
01:19:46,082 --> 01:19:48,449
它将会绘制您计算器中的内容。

1798
01:19:48,517 --> 01:19:50,517
所以你今天可以开始，因为你已经有了

1799
01:19:50,585 --> 01:19:52,319
知道您需要了解的关于UI视图的一切

1800
01:19:52,388 --> 01:19:53,654
做一个自定义绘图方法。

1801
01:19:53,723 --> 01:19:55,422
所以你可以开始绘制你的图形

1802
01:19:55,490 --> 01:19:57,458
构建自定义图形视图。

1803
01:19:57,526 --> 01:20:00,360
你甚至可以建立自定义MVC，因为你是

1804
01:20:00,429 --> 01:20:03,230
将其构建为单个MVC启动。

1805
01:20:03,299 --> 01:20:05,533
但你要等到星期一去尝试

1806
01:20:05,601 --> 01:20:07,334
把它连接到你的计算器，因为你是

1807
01:20:07,402 --> 01:20:10,036
要看我做分裂视图的演示

1808
01:20:10,105 --> 01:20:11,572
所有的东西，看到发生。

1809
01:20:11,641 --> 01:20:13,573
当你开始抱着你的两个时，它会帮助你

1810
01:20:13,642 --> 01:20:16,509
MVC的图形和计算器在一起。

1811
01:20:16,578 --> 01:20:18,278
因为你下星期一需要

1812
01:20:18,347 --> 01:20:21,514
这项任务不会在下周一到期。

1813
01:20:21,583 --> 01:20:24,385
好的，所以你有一个很好的10或11天才能完成。

1814
01:20:24,453 --> 01:20:27,054
但我强烈建议您使用接下来的几天

1815
01:20:27,123 --> 01:20:29,056
前进，并开始在它的视图部分。

1816
01:20:29,124 --> 01:20:32,158
因为这是任务的一半以上

1817
01:20:32,227 --> 01:20:34,628
你可以大开头。

1818
01:20:34,696 --> 01:20:36,563
最后一件事是最后一次阅读作业

1819
01:20:36,632 --> 01:20:37,631
今天也出去了

1820
01:20:37,700 --> 01:20:40,334
到期日几乎是下周三。

1821
01:20:41,470 --> 01:20:43,403
但是这样做会是这样的

1822
01:20:43,472 --> 01:20:45,338
您已阅读整个Swift文档。

1823
01:20:45,407 --> 01:20:47,107
所以在这个任务结束之前，

1824
01:20:47,176 --> 01:20:49,443
你应该觉得你知道那里的一切。

1825
01:20:49,512 --> 01:20:51,145
现在当然，我不希望你知道每一个

1826
01:20:51,214 --> 01:20:53,280
关于每一件事情的单一细节。

1827
01:20:53,348 --> 01:20:54,681
但我期待你

1828
01:20:54,750 --> 01:20:57,317
如果你喜欢做一个嵌套的函数，我希望你

1829
01:20:57,386 --> 01:20:59,152
能够知道去哪里去找那个。

1830
01:20:59,221 --> 01:21:02,890
或者你想做可选的链接和

1831
01:21:02,958 --> 01:21:05,592
你不会记得你知道去哪里去看看。

1832
01:21:05,661 --> 01:21:06,660
这是一个参考文件。

1833
01:21:06,728 --> 01:21:08,362
所以你想知道那里有什么。

1834
01:21:08,430 --> 01:21:11,632
即使你根本不记得。

1835
01:21:11,700 --> 01:21:12,699
就这样吧。

1836
01:21:12,768 --> 01:21:14,201
下节课再见

1837
01:21:14,270 --> 01:21:24,878
>>更多，请访问我们的stanford.edu。


1
00:00:00,401 --> 00:00:04,336
[MUSIC]

2
00:00:04,404 --> 00:00:10,575
斯坦福大学。 >>欢迎来到斯坦福CS193P，

3
00:00:10,644 --> 00:00:15,414
开发iOS应用程序，2017年冬季。

4
00:00:15,482 --> 00:00:19,318
这是第7讲，今天我们要谈谈

5
00:00:19,386 --> 00:00:23,688
更多关于Swift的信息。一旦我们这样做，

6
00:00:23,757 --> 00:00:27,159
我们可以介绍一些我们需要的技术

7
00:00:27,227 --> 00:00:31,129
做更复杂的UIKit对象，

8
00:00:31,198 --> 00:00:34,899
滚动视图可以是我们今天网络的第一个例子

9
00:00:34,968 --> 00:00:38,603
演示在最后，我们向您展示如何使用滚动视图。

10
00:00:38,672 --> 00:00:42,708
我想在Swift中谈论的第一件事是处理错误。所以

11
00:00:42,777 --> 00:00:46,778
很远，我们还没有打过任何方法

12
00:00:46,847 --> 00:00:51,749
可能会产生错误，或者我们称之为抛出错误。和

13
00:00:51,818 --> 00:00:55,020
我们总是可以很清楚地告诉这些方法

14
00:00:55,089 --> 00:00:58,323
在任何API。因为宣布时，

15
00:00:58,392 --> 00:01:01,059
他们会把这个词抛出来。和

16
00:01:01,128 --> 00:01:04,329
throws意味着在处理这个方法的某个地方，

17
00:01:04,398 --> 00:01:07,866
它可能，但不能保证，它会抛出

18
00:01:07,934 --> 00:01:11,803
一个错误。所以当我们把这个错误抛出来的时候，

19
00:01:11,871 --> 00:01:16,040
我们必须抓住(catch)错误。我们抓住的方式是，

20
00:01:16,109 --> 00:01:18,677
首先，每次我们称之为方法

21
00:01:18,745 --> 00:01:21,813
那可以抛出一个错误，我们必须使用这个词try。所以

22
00:01:21,882 --> 00:01:24,949
我们必须尝试该方法，因为它可能会失败。

23
00:01:25,018 --> 00:01:27,152
所以这就是为什么我们用这个词来试试。但

24
00:01:27,220 --> 00:01:29,020
如果我们想抓住回来的错误，

25
00:01:29,089 --> 00:01:32,390
我们实际上必须在那里做一点尝试

26
00:01:32,459 --> 00:01:37,729
叫做做构造。所以我们必须说do{，和

27
00:01:37,798 --> 00:01:42,800
那么一些代码中有一些尝试。then}catch，

28
00:01:42,869 --> 00:01:47,338
然后让错误让我们抓住投掷

29
00:01:47,407 --> 00:01:50,242
错误变成一个变量，在这种情况下称为错误。

30
00:01:50,310 --> 00:01:53,311
我们可以说，让我们想要的任何变量名。

31
00:01:53,380 --> 00:01:55,880
那会变成有错误的变量。

32
00:01:55,949 --> 00:01:59,017
然后在那个大括号中，我们处理错误。和

33
00:01:59,085 --> 00:02:01,853
那么在我们处理之后，我们的代码就会继续下去。所以

34
00:02:01,922 --> 00:02:04,957
我们抓到错误，我们处理它，我们继续前进。

35
00:02:05,025 --> 00:02:08,760
如果我们想要，如果我们的功能抛出，

36
00:02:08,829 --> 00:02:12,531
我们可以通过使用关键字throw在那里重新抛出错误

37
00:02:12,599 --> 00:02:17,636
在我们的第二个，小卷曲的空间。现在这个错误

38
00:02:17,704 --> 00:02:21,439
这被扔给你，它必须是一定的

39
00:02:21,508 --> 00:02:25,744
类型。该类型称为错误。这是一个协议，

40
00:02:25,813 --> 00:02:28,981
不过我稍后会在这个演讲中谈论，但是

41
00:02:29,049 --> 00:02:31,082
这是一个非常简单的小类型。

42
00:02:31,151 --> 00:02:34,720
而在UIKit中，当UIKit方法抛出错误时，

43
00:02:34,788 --> 00:02:37,889
他们抛出一个这种NSError类型的错误。所以

44
00:02:37,958 --> 00:02:42,226
你可以去看看NSError的文档

45
00:02:42,295 --> 00:02:46,498
看看NSError是什么。它有一个错误代码，它有一个错误

46
00:02:46,567 --> 00:02:50,335
域，如发生错误的地方。而且，

47
00:02:50,404 --> 00:02:54,038
甚至有一些事情像发生了什么的描述，

48
00:02:54,107 --> 00:02:57,342
为什么它失败了，这样的事情。

49
00:02:57,411 --> 00:03:00,812
现在，有时我们称之为抛出的函数，

50
00:03:00,881 --> 00:03:05,383
我们知道肯定不会失败。这是

51
00:03:05,452 --> 00:03:10,155
我们很少知道这一点，但如果我们确定，

52
00:03:10,224 --> 00:03:14,926
我们可以使用另一个版本的try，这是try! 只是

53
00:03:14,994 --> 00:03:18,630
像感叹号意味着强制它在一个可选的，

54
00:03:18,699 --> 00:03:22,267
这里的感叹号意味着强制它本质上。

55
00:03:22,336 --> 00:03:25,303
如果我们在这里调用context.save()

56
00:03:25,372 --> 00:03:28,974
无论什么功能，如果我们称之为它，它会抛出，

57
00:03:29,043 --> 00:03:32,043
我们的应用程序会崩溃，好的。这就是try!

58
00:03:32,111 --> 00:03:35,913
手段。这意味着尝试，我知道这不会抛出。

59
00:03:35,982 --> 00:03:39,217
如果是这样，我的应用程序崩溃还没有

60
00:03:39,286 --> 00:03:44,189
另一个尝试，这是try?  try？

61
00:03:44,258 --> 00:03:48,994
意味着尝试调用抛出的方法，和

62
00:03:49,063 --> 00:03:51,763
如果它抛出，只要给我回去没有。

63
00:03:52,832 --> 00:03:53,665
好吧

64
00:03:53,734 --> 00:03:56,534
那当然是我们的变数

65
00:03:56,603 --> 00:04:00,838
分配这个方法的结果，我叫这个方法，

66
00:04:00,907 --> 00:04:04,509
errorProneFunctionThatReturns- AnInt。无论回报如何，

67
00:04:04,577 --> 00:04:07,145
它现在将返回一个可选的版本。

68
00:04:07,213 --> 00:04:09,247
所以错误的函数返回一个int，

69
00:04:09,316 --> 00:04:11,483
返回一个int显然。但x，

70
00:04:11,552 --> 00:04:15,720
这让x =，x将是一个可选的int

71
00:04:15,789 --> 00:04:18,589
明显的原因是因为如果错误倾向功能返回

72
00:04:18,658 --> 00:04:23,428
一个int投掷，它不得不抛弃我们，好吗？所以

73
00:04:23,496 --> 00:04:28,200
那是什么尝试？是。尝试？试一试，如果失败了，

74
00:04:28,268 --> 00:04:31,169
只是给我回来没有。如果我这样做，我不会去

75
00:04:31,238 --> 00:04:33,271
看看错误。我不知道是什么

76
00:04:33,340 --> 00:04:37,642
我忽略了这里的错误。我知道有一个错误，但是

77
00:04:37,711 --> 00:04:42,213
这就是我在尝试中所知道的一切案件。所以这很简单

78
00:04:42,282 --> 00:04:45,049
错误机制工作得很好。

79
00:04:45,118 --> 00:04:48,786
在Swift，他们真的学到了别的教训

80
00:04:48,855 --> 00:04:52,891
语言越来越多，过于复杂

81
00:04:52,959 --> 00:04:56,728
抛出正在抛出调用堆栈的错误

82
00:04:56,796 --> 00:05:00,398
所有这些事情，Swift都很直截了当，

83
00:05:00,467 --> 00:05:04,335
看到整个错误处理，好吗？

84
00:05:04,404 --> 00:05:07,572
现在，另一个完全不同的话题，扩展。

85
00:05:07,641 --> 00:05:12,109
所以，扩展允许你添加一个方法或一个var，

86
00:05:12,178 --> 00:05:16,180
即使是另一个类或结构枚举，你可以

87
00:05:16,249 --> 00:05:19,750
甚至没有代码，好的，它被称为扩展

88
00:05:19,819 --> 00:05:23,822
因为它扩展了这个类。所以，这是一个具体的例子，

89
00:05:23,891 --> 00:05:26,524
我希望你明白为什么我们可以使用扩展名。

90
00:05:26,593 --> 00:05:29,360
记住我们上次做我们的应用程序时

91
00:05:29,429 --> 00:05:33,064
我们去了我们的故事板，我们包装了细节

92
00:05:33,133 --> 00:05:36,267
导航控制器中的分割视图

93
00:05:36,336 --> 00:05:39,037
它打破了我们的代码。对，它打破了我们的代码

94
00:05:39,106 --> 00:05:41,572
准备segue因为该代码正在寻找

95
00:05:41,641 --> 00:05:44,509
一个Face View控制器，它找到一个导航控制器

96
00:05:44,578 --> 00:05:47,745
代替。而我们解决的方式是我们只是看看是否

97
00:05:47,814 --> 00:05:50,348
首先是导航控制器。如果是，我们看

98
00:05:50,417 --> 00:05:53,150
在导航控制器的可见视图控制器处，

99
00:05:53,219 --> 00:05:56,654
现在我们再次看到我们的Face View控制器。现在，

100
00:05:56,723 --> 00:06:01,092
我们可以将该代码放入UIViewController的扩展

101
00:06:01,161 --> 00:06:04,228
通过创建一个新的var，你可以看到它在这里

102
00:06:04,297 --> 00:06:06,832
称为contentViewController，我们可以调用新的var

103
00:06:06,900 --> 00:06:09,701
任何我们想要的，我喜欢contentViewController cuz

104
00:06:09,769 --> 00:06:12,136
如果是导航控制器，那就是内容。

105
00:06:12,205 --> 00:06:14,338
如果它不是一个导航控制器，它只是自我。

106
00:06:14,407 --> 00:06:15,606
这是视图控制器本身。

107
00:06:15,675 --> 00:06:19,744
这是它自己的内容。所以我可以添加这个，所以

108
00:06:19,812 --> 00:06:23,448
我将这个var实际添加到UIViewController。所以现在

109
00:06:23,517 --> 00:06:28,085
UIViewController了解这个var，它有这个新的var。

110
00:06:28,154 --> 00:06:31,022
现在我没有子类UIViewController来做，

111
00:06:31,091 --> 00:06:33,291
我只是扩展UIViewController。所以

112
00:06:33,360 --> 00:06:36,961
你UIViewController和UIViewController的所有子类

113
00:06:37,030 --> 00:06:40,298
现在将有这个var。它使得我们所拥有的代码

114
00:06:40,367 --> 00:06:42,867
准备，看起来像这样，

115
00:06:42,936 --> 00:06:45,470
绿色部分在两个地方都一样。

116
00:06:45,539 --> 00:06:47,838
它将所有代码更改为

117
00:06:47,907 --> 00:06:53,278
只是这个简单的代码行。 segue的目的地，

118
00:06:53,346 --> 00:06:58,717
contentViewController作为我的MVC。我认为幻灯片说

119
00:06:58,786 --> 00:07:00,985
destinationViewController-应该是

120
00:07:01,054 --> 00:07:05,423
segue.destination.contentView-控制器。所以，

121
00:07:05,492 --> 00:07:08,893
它只是清理我们的代码并准备segue。但

122
00:07:08,962 --> 00:07:10,995
我们有UIViewControllers的扩展，

123
00:07:11,064 --> 00:07:12,731
纯粹是一个UIViewController的东西。

124
00:07:12,799 --> 00:07:15,500
它与我们的情感视图控制器无关，

125
00:07:15,569 --> 00:07:18,269
这样的事情我们纯粹扩展了UIViewController

126
00:07:18,338 --> 00:07:23,575
有新的功能。现在，他们的代码中的扩展，

127
00:07:23,644 --> 00:07:26,644
他们可以指自己。当他们自称时，

128
00:07:26,713 --> 00:07:29,381
他们是指他们所在的课程，所以在这种情况下，

129
00:07:29,450 --> 00:07:31,549
自我意味着UIViewController

130
00:07:31,618 --> 00:07:33,718
正在执行这个var是有道理的，

131
00:07:33,786 --> 00:07:37,989
对？这些有一些限制

132
00:07:38,057 --> 00:07:41,960
扩展。所以扩展不能代替

133
00:07:42,029 --> 00:07:44,696
一切物体都像子类化

134
00:07:44,765 --> 00:07:48,132
像这样的东西。有一点是你不能重新实现

135
00:07:48,201 --> 00:07:51,903
已经在那里的东西所以，你不能覆盖

136
00:07:51,971 --> 00:07:55,707
或具有扩展名的子类。你只能添加新的东西

137
00:07:55,775 --> 00:07:58,610
那不是在那里而事实上，如果UIViewController是

138
00:07:58,678 --> 00:08:01,479
要实现这个var contentViewController，

139
00:08:01,547 --> 00:08:04,181
它的版本将赢得 - 没有赢的扩展。

140
00:08:04,250 --> 00:08:06,751
实际上，当您尝试添加时，甚至可能会收到错误

141
00:08:06,820 --> 00:08:08,853
已经在那里的东西的扩展。

142
00:08:08,922 --> 00:08:10,621
所以它不是我们的替代或压倒一切

143
00:08:10,690 --> 00:08:13,658
这样的事情，就是增加新的东西。和一个巨大的

144
00:08:13,727 --> 00:08:18,763
扩展的限制是不能有任何存储。

145
00:08:21,234 --> 00:08:25,403
扩展可以只有一个vars必须被计算vars。

146
00:08:25,472 --> 00:08:27,705
他们不能有任何存储的vars，好的，

147
00:08:27,774 --> 00:08:30,975
扩展没有存储。他们纯粹是为了

148
00:08:31,044 --> 00:08:35,880
添加代码，好吧。现在，扩展的这个功能是

149
00:08:35,949 --> 00:08:39,450
很容易被初学者滥用Swift。

150
00:08:39,519 --> 00:08:42,019
他们开始说，很酷，我只是添加这个代码

151
00:08:42,088 --> 00:08:43,521
扩展这里，我会添加新的代码和

152
00:08:43,590 --> 00:08:45,657
在那里有一个扩展，我会把它添加到那里。

153
00:08:45,725 --> 00:08:48,359
而且你开始得到这种凌乱的情况

154
00:08:48,428 --> 00:08:50,194
扩展不是真的有道理

155
00:08:50,263 --> 00:08:53,264
你添加到的类。所以我会建议你

156
00:08:53,332 --> 00:08:56,134
随着扩展就要慢慢而稳定。

157
00:08:56,202 --> 00:08:59,904
不要太多使用它们现在说了，扩展

158
00:08:59,973 --> 00:09:04,075
对于很好地构建你的代码，可以是超级强大的。

159
00:09:04,144 --> 00:09:06,611
好的，特别是当我开始谈论协议时。

160
00:09:06,679 --> 00:09:09,280
它们可以是建筑的一个基本方面

161
00:09:09,349 --> 00:09:12,350
像一个功能编程方法来构建你的应用程序。

162
00:09:12,418 --> 00:09:15,052
但是我没有时间教给你们一切。所以

163
00:09:15,121 --> 00:09:17,088
你只需要知道

164
00:09:17,156 --> 00:09:18,489
关于扩展以进入自己

165
00:09:18,558 --> 00:09:21,459
有点麻烦所以要小心扩展，好吗？

166
00:09:21,527 --> 00:09:23,695
轻轻地使用它们但在未来当你开始

167
00:09:23,764 --> 00:09:26,631
有一天，你会变得越来越严重的iOS开发者

168
00:09:26,699 --> 00:09:28,966
想学习如何使用扩展名

169
00:09:29,035 --> 00:09:34,238
优势没有滥用他们，好吗？下一个话题，

170
00:09:34,307 --> 00:09:38,910
协议，超级，重要主题在这里。

171
00:09:38,978 --> 00:09:41,545
有多少人遇到了协议

172
00:09:41,614 --> 00:09:46,384
其他语言？没人看？那么一两个人。

173
00:09:46,453 --> 00:09:50,121
所以它让我感到惊讶，但协议，

174
00:09:50,190 --> 00:09:54,325
而非常简单，也是非常强大的。所以，

175
00:09:54,394 --> 00:09:58,296
协议是一种声明类型的方法

176
00:09:58,365 --> 00:10:02,233
这真的只是意味着这些方法和vars没有

177
00:10:02,302 --> 00:10:06,937
一般执行这是一个协议。

178
00:10:07,006 --> 00:10:10,742
一个协议，你会看到，是一种类型。但你本质上是

179
00:10:10,811 --> 00:10:14,712
只是定义了几种方法。或者甚至一些vars，

180
00:10:14,781 --> 00:10:17,982
这是本协议的一部分。然后我们要使用

181
00:10:18,051 --> 00:10:21,052
如您所见，该协议更好地定义了我们的API。

182
00:10:21,120 --> 00:10:26,557
它允许您创建一个API，让呼叫者通过

183
00:10:26,626 --> 00:10:30,628
任何他们想要的 - 任何类，或结构体，或枚举甚至，

184
00:10:30,696 --> 00:10:34,866
他们想要您创建的这个API。但它允许你，

185
00:10:34,934 --> 00:10:38,970
谁接收它，以确保该类，或

186
00:10:39,039 --> 00:10:41,405
枚举或结构体，实现某些方法或

187
00:10:41,474 --> 00:10:45,176
你需要的vars所以这就是这一切。

188
00:10:45,245 --> 00:10:47,912
这是关于API设计。我们想要构建API

189
00:10:47,980 --> 00:10:51,282
我们可以在我们的API中正确地表达我们想要的和

190
00:10:51,351 --> 00:10:54,318
不再。好的，只是我们需要做的方法和变量

191
00:10:54,387 --> 00:10:57,288
无论这个功能要做什么，或者什么，和

192
00:10:57,357 --> 00:11:01,292
不是额外的东西。所以，协议只是一个集合

193
00:11:01,361 --> 00:11:04,062
的方法和属性声明。

194
00:11:04,130 --> 00:11:07,798
这是一个协议。但协议是一种类型。它的

195
00:11:07,867 --> 00:11:11,202
一个完整的类型。它可以提供任何可以使用类型的地方，

196
00:11:11,271 --> 00:11:15,506
像一个浮动您可以使用一种协议类型。

197
00:11:15,574 --> 00:11:19,243
协议是一流的类型。绝对一流

198
00:11:19,312 --> 00:11:23,781
类型。实现方法和vars下

199
00:11:23,850 --> 00:11:26,851
协议，因为协议只是它们的声明，

200
00:11:26,919 --> 00:11:29,554
实施发生在哪里？那么多，

201
00:11:29,622 --> 00:11:33,557
它发生在声明的类和结构体和枚举中

202
00:11:33,626 --> 00:11:36,827
实施该协议，或符合该协议，

203
00:11:36,896 --> 00:11:39,897
我们说。所以如果我是一个结构，我想说是的，

204
00:11:39,966 --> 00:11:43,467
我想遵守协议x，那么我必须实现

205
00:11:43,536 --> 00:11:46,938
var中的所有方法都在协议x中，对吗？

206
00:11:47,006 --> 00:11:48,672
Cuz协议x只是一个声明，

207
00:11:48,741 --> 00:11:50,708
这不是一个实现。现在，

208
00:11:50,777 --> 00:11:54,778
您还可以在扩展中的协议上执行，

209
00:11:54,847 --> 00:11:56,714
但我要把它放在架子上，

210
00:11:56,783 --> 00:11:59,016
再谈几个幻灯片。但

211
00:11:59,085 --> 00:12:02,353
主要协议，实现发生在

212
00:12:02,422 --> 00:12:05,155
符合或实施课程，

213
00:12:05,224 --> 00:12:10,127
结构和枚举。现在，三个部分是一个协议。

214
00:12:10,196 --> 00:12:12,029
一个是协议的声明。

215
00:12:12,098 --> 00:12:14,332
真的很简单它看起来就像宣布一个类，

216
00:12:14,400 --> 00:12:16,868
一个结构体或一个枚举。但是没有实现，

217
00:12:16,936 --> 00:12:20,271
好的。第二部分是类或结构

218
00:12:20,340 --> 00:12:23,608
枚举声称符合该协议。

219
00:12:23,676 --> 00:12:25,943
这声称它实现了该协议。和

220
00:12:26,012 --> 00:12:28,646
那当然还有那个类的实际代码，

221
00:12:28,715 --> 00:12:31,883
结构或枚举，声称实现协议，

222
00:12:31,952 --> 00:12:33,785
实际上实现了协议。就是这样了，

223
00:12:33,853 --> 00:12:35,819
那些是使用协议的三个部分。

224
00:12:35,888 --> 00:12:40,458
两者的声明然后执行。现在，

225
00:12:40,527 --> 00:12:42,994
我会谈谈协议的一个功能，

226
00:12:43,063 --> 00:12:45,563
称为可选方法。这不是可选的，

227
00:12:45,632 --> 00:12:47,966
像可选类型。这是不同的可选项。

228
00:12:48,034 --> 00:12:51,502
这意味着协议中的方法是可选的，

229
00:12:51,571 --> 00:12:53,071
你不必执行它们，而且

230
00:12:53,139 --> 00:12:55,906
你仍然可以说你实现这个协议。

231
00:12:55,975 --> 00:12:58,910
现在这是一个Objective-C的事情。这不是真的

232
00:12:58,979 --> 00:13:01,946
一个Swift的东西当你有协议和

233
00:13:02,015 --> 00:13:04,315
它有一堆方法，如果你是struct或

234
00:13:04,384 --> 00:13:06,784
class你想说你实行那个协议，

235
00:13:06,852 --> 00:13:09,287
你必须实现所有这些，

236
00:13:09,355 --> 00:13:13,925
好吧。在Objective-C中，虽然不是这样，

237
00:13:13,993 --> 00:13:16,827
在Objective-C中，一些方法可能是可选的

238
00:13:16,896 --> 00:13:20,164
在这种情况下，您可以声称实施该协议

239
00:13:20,233 --> 00:13:23,868
没有实现那些。所以，如果我们有一个协议有这些

240
00:13:23,937 --> 00:13:26,437
可选的东西，它必须被标记为objc。

241
00:13:26,506 --> 00:13:30,408
所以你把这个小@objc放在协议之前，和

242
00:13:30,477 --> 00:13:32,743
说这是一个Objective-C协议。和

243
00:13:32,812 --> 00:13:35,346
那么在声明里面你可以放这个词

244
00:13:35,414 --> 00:13:39,283
“可选”在你想要的任何功能或变量之前

245
00:13:39,351 --> 00:13:44,154
使可选。所以这将被用于某些事情

246
00:13:44,223 --> 00:13:46,090
所谓的代表团，我将在几点谈论

247
00:13:46,159 --> 00:13:49,860
幻灯片是一个被提出的Objective-C的东西。

248
00:13:49,929 --> 00:13:52,931
因为它在UIKit这么广泛地被带来

249
00:13:52,999 --> 00:13:57,334
前进到Swift使用这个@objc协议，好吗？

250
00:13:57,403 --> 00:13:59,971
但回到一般的协议。所以让我们来看看

251
00:14:00,040 --> 00:14:01,705
在什么协议看起来要声明。

252
00:14:01,774 --> 00:14:05,710
所以这里是一个名为SomeProtocol的协议的声明。

253
00:14:05,779 --> 00:14:07,612
你可以看到它看起来就像宣布一个类，

254
00:14:07,681 --> 00:14:09,279
一个结构体或一个枚举，对吗。

255
00:14:09,348 --> 00:14:11,582
你得到的关键字是协议而不是类，

256
00:14:11,651 --> 00:14:14,551
结构体或枚举。然后你得到了这个名字。

257
00:14:14,620 --> 00:14:19,991
之后，虽然有一个冒号和其他协议。

258
00:14:20,060 --> 00:14:23,227
这些协议称为继承协议。

259
00:14:23,296 --> 00:14:26,331
一些协议继承这两个协议。和

260
00:14:26,399 --> 00:14:28,532
这意味着任何想要说是的人，

261
00:14:28,601 --> 00:14:29,800
我实现一些协议，

262
00:14:29,869 --> 00:14:31,235
他们也必须实施这些。

263
00:14:31,303 --> 00:14:33,704
好的，他们正在做所有这三个协议。

264
00:14:33,773 --> 00:14:37,074
一些协议，和它的两个继承协议。

265
00:14:37,143 --> 00:14:41,879
所以协议基本上有多个继承。多少

266
00:14:41,947 --> 00:14:45,482
人们知道多重继承是在对象中

267
00:14:45,551 --> 00:14:47,785
为本？所以只有你们几个。所以多重继承

268
00:14:47,854 --> 00:14:49,753
只是意味着你可以有两个父类，或者

269
00:14:49,822 --> 00:14:52,923
三个父类一些语言支持。

270
00:14:52,992 --> 00:14:56,460
Swift没有。但是Swift确实支持多个

271
00:14:56,529 --> 00:15:00,764
你可以继承的协议，好吗？

272
00:15:00,833 --> 00:15:04,768
现在，里面的协议，你可以有属性和

273
00:15:04,837 --> 00:15:09,440
你可以有功能。如果你有一个var，一个属性，

274
00:15:09,508 --> 00:15:12,376
你必须说是否是一个get set属性或

275
00:15:12,445 --> 00:15:15,112
只有得到只有你在大括号得到

276
00:15:15,181 --> 00:15:18,582
组。卷曲支撑得到。所以你必须把它卷曲

277
00:15:18,651 --> 00:15:21,752
在那里支持一些东西，说你会不会

278
00:15:21,821 --> 00:15:27,224
get set var或者你是否只是一个get-only var。

279
00:15:27,293 --> 00:15:32,496
协议期望的任何功能会使事情发生变化

280
00:15:32,565 --> 00:15:35,966
实现它，就像一个结构体实现它一样，

281
00:15:36,035 --> 00:15:39,904
你必须标记它变异。现在如果一个类

282
00:15:39,972 --> 00:15:41,905
实施这个协议，没关系，

283
00:15:41,974 --> 00:15:44,775
类不必标记自己变异。

284
00:15:44,844 --> 00:15:46,877
实际上甚至可以说，

285
00:15:46,946 --> 00:15:49,847
我希望这个协议只能由类实现。

286
00:15:49,916 --> 00:15:52,583
而你这样做就是把词语放在后面

287
00:15:52,651 --> 00:15:55,719
结肠看到黄色类在那里SomeProtocol

288
00:15:55,788 --> 00:15:58,256
:class  - 这意味着这个SomeProtocol只能是

289
00:15:58,324 --> 00:15:59,756
由参考类型实现。和

290
00:15:59,825 --> 00:16:02,426
在这种情况下，您不必在其中放入任何mutatin。

291
00:16:02,495 --> 00:16:04,428
但是如果你允许你的协议

292
00:16:04,497 --> 00:16:07,097
由枚举，特别是由结构体实现，

293
00:16:07,166 --> 00:16:09,934
显然，你必须在那里进行突变。

294
00:16:11,871 --> 00:16:15,973
您也可以在协议初始化器中指定。

295
00:16:16,042 --> 00:16:16,940
你基本上说，

296
00:16:17,009 --> 00:16:19,410
任何想实现这个SomeProtocol的人都必须是

297
00:16:19,478 --> 00:16:23,814
能够用这些参数进行初始化，好吗？

298
00:16:23,883 --> 00:16:27,451
如果你这样做，顺便说一句，你是一个类，

299
00:16:27,520 --> 00:16:32,456
好的，那么你必须标记所需的初始化程序。我会

300
00:16:32,525 --> 00:16:37,895
告诉你。好的，那么一个类或者怎么样

301
00:16:37,964 --> 00:16:42,733
一个结构体或枚举说是的，我实现SomeProtocol？

302
00:16:42,802 --> 00:16:46,336
它这样做。一个类，就在它的超类之后，

303
00:16:46,405 --> 00:16:48,639
只是放一个逗号，协议会这样做。

304
00:16:48,708 --> 00:16:51,208
你可以在那里实现任何数量的协议。

305
00:16:51,277 --> 00:16:54,244
所以这个类叫SomeClass有一个SuperClass，

306
00:16:54,313 --> 00:16:57,247
它被称为一些类的SuperClass，它也实现

307
00:16:57,316 --> 00:17:00,984
两个协议，SomeProtocol和AnotherProtocol。

308
00:17:01,053 --> 00:17:03,721
现在在SomeClass的实现中必须

309
00:17:03,790 --> 00:17:07,357
实现这两个协议中的所有方法和变量

310
00:17:07,426 --> 00:17:10,027
除非它是一个Objective-C协议，它们被标记

311
00:17:10,096 --> 00:17:12,163
可选的。好的，那里的方法是可选的。

312
00:17:12,231 --> 00:17:16,600
这是唯一的例外。好吧。结构或

313
00:17:16,669 --> 00:17:19,937
枚举。完全一样，只是他们没有父类。

314
00:17:20,006 --> 00:17:22,439
所以这里是一个枚举，说实现这两个

315
00:17:22,508 --> 00:17:24,975
协议好吗？这里是一个结构，说它

316
00:17:25,044 --> 00:17:27,678
实现这两个协议。现在，

317
00:17:27,747 --> 00:17:32,482
您可以执行任意数量的协议。和

318
00:17:32,551 --> 00:17:35,420
正如我所说，必须要求。的原因

319
00:17:35,488 --> 00:17:38,322
这里必须要求的是，

320
00:17:38,391 --> 00:17:42,159
如果一个子类，子类是SomeClass就在那里，和

321
00:17:42,228 --> 00:17:45,095
它所有的初始退出游戏，

322
00:17:45,164 --> 00:17:47,698
这不再是一个很好的初学者。

323
00:17:47,767 --> 00:17:48,665
因为也许这是必需的。

324
00:17:48,734 --> 00:17:50,468
你需要一个初始化器，你需要一个覆盖，所以

325
00:17:50,536 --> 00:17:52,569
现在你有你自己的新的指定的初始化程序，

326
00:17:52,638 --> 00:17:55,072
等等。那会是坏的，因为这将意味着

327
00:17:55,141 --> 00:17:58,075
SomeClass的子类将不再符合

328
00:17:58,144 --> 00:18:00,945
那个协议，这是不允许的。

329
00:18:01,014 --> 00:18:03,981
如果类符合协议，如SomeProtocol，

330
00:18:04,050 --> 00:18:06,884
它的所有子类都必须继续这样做。和

331
00:18:06,953 --> 00:18:10,721
他们将继承除了init以外的父类，

332
00:18:10,790 --> 00:18:14,191
是一个可以不遵守规则的事情

333
00:18:14,259 --> 00:18:19,563
在里面。好的？有一件非常有趣的是你

334
00:18:19,632 --> 00:18:22,499
被允许添加协议一致性到一个结构体，

335
00:18:22,568 --> 00:18:26,403
一个类或使用扩展名的枚举。只要你可以

336
00:18:26,472 --> 00:18:29,539
做没有任何存储。您可以在扩展程序中执行此操作。

337
00:18:29,608 --> 00:18:32,443
你只是说，扩展的东西，哪里是什么

338
00:18:32,512 --> 00:18:35,312
类，结构或枚举，冒号，SomeProtocol。

339
00:18:35,381 --> 00:18:38,182
而且说，我正在创建该类的扩展，

340
00:18:38,251 --> 00:18:40,651
结构或枚举，实现此协议。

341
00:18:40,720 --> 00:18:41,918
然后在那个扩展中，

342
00:18:41,987 --> 00:18:45,790
你必须实现协议的所有方法。好的，

343
00:18:45,859 --> 00:18:50,727
明白我在说什么让我们

344
00:18:50,796 --> 00:18:54,198
谈论协议是类型。我是什么意思

345
00:18:54,267 --> 00:18:56,867
说协议是一种类型？所以我在这里举个例子。

346
00:18:56,936 --> 00:18:59,803
我有一个协议叫做可移动和

347
00:18:59,872 --> 00:19:02,439
它只有一个功能，称为变异功能

348
00:19:02,508 --> 00:19:06,144
移动到点现在我在这里有两个数据结构。

349
00:19:06,212 --> 00:19:09,513
一个是一个叫Car的类，它是可移动的。

350
00:19:09,582 --> 00:19:12,950
好吧，汽车是可以移动的，但汽车也有其他的方法

351
00:19:13,018 --> 00:19:16,887
像changeOil。你改变了汽油的油。和

352
00:19:16,956 --> 00:19:19,056
类似地，我有这个结构称为Shape。

353
00:19:19,125 --> 00:19:22,259
它也实现了Moveabl。看，看，突变func

354
00:19:22,328 --> 00:19:24,861
移动到点它实际上实现了。但它也

355
00:19:24,930 --> 00:19:26,931
有一个叫做draw的功能。因为它是一个形状和

356
00:19:26,999 --> 00:19:30,168
它可以在屏幕上绘制。好的，所有的

357
00:19:32,972 --> 00:19:35,539
这两个类中的两个实现该协议移动到。

358
00:19:35,607 --> 00:19:39,343
你看到了吗？所以你看到他们都可以移动吗？

359
00:19:39,411 --> 00:19:41,612
好的，一辆车是可动的。形状可移动。

360
00:19:41,681 --> 00:19:45,583
这就是我们如何描述这些。所以我创造了两点

361
00:19:45,651 --> 00:19:48,785
变成这里。当然是一辆普锐斯，

362
00:19:48,854 --> 00:19:51,322
它等于一辆新车。然后我创造了一个广场，

363
00:19:51,391 --> 00:19:53,991
当然这是一种形状。所以我有一个普锐斯和

364
00:19:54,060 --> 00:19:56,360
一个广场在这里让我们看看我们可以做什么与普锐斯和

365
00:19:56,428 --> 00:20:00,497
广场。首先，我可以创建一个var的类型

366
00:20:00,566 --> 00:20:05,936
可移动称为thingToMove，我可以将其分配给Prius。

367
00:20:06,005 --> 00:20:09,573
因为普锐斯是可移动的。所以如果我有一个var

368
00:20:09,642 --> 00:20:12,776
是可移动的，当然可以把普锐斯放在那里。

369
00:20:12,845 --> 00:20:17,681
大家明白了吗我甚至可以说，thingToMove，

370
00:20:17,750 --> 00:20:21,218
移动到这一点，因为thingToMove是一个可移动的。

371
00:20:21,287 --> 00:20:24,622
所以，如果它是一个可移动的，它必须实现移动点。所以

372
00:20:24,690 --> 00:20:29,092
我可以这么说但是，我不能说，thingToMove，

373
00:20:29,161 --> 00:20:32,929
换油这是关键的事情要了解，

374
00:20:32,998 --> 00:20:39,636
好的？即使我把一个Prius放在thingToMove中，

375
00:20:39,705 --> 00:20:43,741
那个var不是一辆车，它是一个可移动的。

376
00:20:43,809 --> 00:20:47,211
可移动的不知道如何改变油。汽车做。

377
00:20:47,279 --> 00:20:51,748
但可移动的不要。那么重要的是它的类型

378
00:20:51,817 --> 00:20:54,652
来发送消息，而不是实际在那里。

379
00:20:56,155 --> 00:20:59,923
大家明白了吗现在，我当然也可以说

380
00:20:59,992 --> 00:21:02,759
thingToMove = square。这也是完全合法的。好的，

381
00:21:02,828 --> 00:21:05,062
平方是不是一个类，它是一个结构体。好的，

382
00:21:05,131 --> 00:21:08,031
它不是一辆汽车，它是一种形状。但他们都是可以移动的

383
00:21:08,100 --> 00:21:10,601
varableToMove类型为Moveable可以保存

384
00:21:10,669 --> 00:21:13,303
任何一件事。其实我甚至可以创造

385
00:21:13,372 --> 00:21:18,376
一个数组，thingsToMove，它是一个可移动的数组

386
00:21:18,444 --> 00:21:20,244
那么我可以把普锐斯和广场都放在那里，

387
00:21:20,312 --> 00:21:22,980
即使他们完全不同，

388
00:21:23,048 --> 00:21:24,781
事物类型

389
00:21:24,850 --> 00:21:27,517
他们都可以进去，他们都是可移动的。

390
00:21:27,586 --> 00:21:30,520
所以，该数组中的事物的类型是可移动的。

391
00:21:30,589 --> 00:21:34,091
它实际上是没有关系的。好的，

392
00:21:34,160 --> 00:21:38,061
大家都很酷吗？好吧，我也可以

393
00:21:38,130 --> 00:21:40,964
一个将“可移动”作为参数的函数，

394
00:21:41,033 --> 00:21:44,801
像幻灯片，滑块是一个可移动，和

395
00:21:44,870 --> 00:21:48,271
我可以说，滑块移动到那个位置，因为论证，

396
00:21:48,340 --> 00:21:51,174
滑块，是一个可移动，所以我们可以说移动。和

397
00:21:51,243 --> 00:21:55,012
我可以说幻灯片普锐斯，滑一个广场。

398
00:21:55,081 --> 00:21:58,816
它工作得很好顺便说一句，你可以有参数

399
00:21:58,885 --> 00:22:01,419
到需要多个协议的功能。

400
00:22:01,487 --> 00:22:03,320
例如我可以有一个功能，滑动和

401
00:22:03,389 --> 00:22:08,159
滑块具有可移动的参数x，

402
00:22:08,227 --> 00:22:10,160
另一个协议，我没有在这里展示，

403
00:22:10,229 --> 00:22:12,563
叫Slippery。这就是和声的意思。

404
00:22:12,632 --> 00:22:14,932
这意味着这两个协议。所以

405
00:22:15,001 --> 00:22:17,968
那里面slipAndSlide，我可以发送x可移动的东西，

406
00:22:18,036 --> 00:22:20,070
喜欢移动，我也可以发送它Slippery的东西，

407
00:22:20,139 --> 00:22:23,841
无论是那些。请注意，我不能说slipAndSlide

408
00:22:23,909 --> 00:22:27,711
普锐斯，因为普锐斯没有实施滑，好吗？

409
00:22:27,780 --> 00:22:31,548
普锐斯不符合Slippery协议，所以不能

410
00:22:31,617 --> 00:22:35,352
传过来，斯威夫特甚至不能让我这么说。

411
00:22:35,421 --> 00:22:37,887
好的，大家明白我的意思是现在的协议

412
00:22:37,956 --> 00:22:41,225
一种？这只是一种类型，任何符合它的东西

413
00:22:41,293 --> 00:22:43,927
类型可以存储在某些东西，或通过

414
00:22:43,996 --> 00:22:47,330
在那种类型的东西现在我要拍几张幻灯片

415
00:22:47,399 --> 00:22:51,368
这里谈谈高级协议的使用。我

416
00:22:51,436 --> 00:22:54,771
不会要求你在九，十周内这样做

417
00:22:54,840 --> 00:22:57,874
因为它有一些先进的用途。但我认为是这样

418
00:22:57,943 --> 00:23:00,944
重要的是，你明白这是存在的，因为所有

419
00:23:01,013 --> 00:23:05,015
Swift的标准库，阵列和字典，

420
00:23:05,083 --> 00:23:09,886
所有的东西，都是使用协议实现的。

421
00:23:09,955 --> 00:23:13,124
所以，协议可以做的一件事我不会问

422
00:23:13,192 --> 00:23:16,126
你要做的是它可以限制类型

423
00:23:16,195 --> 00:23:19,129
的通用。每个人都知道什么是通用的，对吧？

424
00:23:19,198 --> 00:23:21,832
一组尖括号t。

425
00:23:21,901 --> 00:23:26,237
这意味着数组可以在那里保存任何类型。但是，

426
00:23:26,305 --> 00:23:29,206
这个t的数组可以限于这样的事情

427
00:23:29,275 --> 00:23:31,641
实施一个协议。所以这里是一个例子，

428
00:23:31,710 --> 00:23:36,580
这是范围。当我展示你的范围，几个讲座之前。

429
00:23:36,649 --> 00:23:41,385
我说这是范围<T>。好的，

430
00:23:41,454 --> 00:23:46,090
因为它只是范围<T>的原因是因为

431
00:23:46,158 --> 00:23:49,693
实际范围界限或T界限只是一个变量名

432
00:23:49,762 --> 00:23:52,862
基本上这种类型，colon comparable。

433
00:23:52,931 --> 00:23:57,067
好的，所以一个范围只能是一系列实现的东西

434
00:23:57,136 --> 00:24:00,971
协议可比较。幸运的是实现

435
00:24:01,040 --> 00:24:05,809
可比。浮点实现可比。字符和

436
00:24:05,878 --> 00:24:08,612
字符串实现可比性等等所以这些东西全部

437
00:24:08,681 --> 00:24:10,981
实现Comparable，所以你可以有一系列的int，

438
00:24:11,050 --> 00:24:13,616
一系列的浮标，无论如何。现在，

439
00:24:13,685 --> 00:24:17,921
为什么范围想要在其范围内的东西是可比的？

440
00:24:17,990 --> 00:24:20,590
那是因为它要确保它的下限

441
00:24:20,659 --> 00:24:22,259
总是小于它的上限。

442
00:24:23,763 --> 00:24:25,529
我想在另一张幻灯片中，我说这是开始索引

443
00:24:25,597 --> 00:24:28,698
结束指数。其实不是范围，范围结构，

444
00:24:28,767 --> 00:24:31,935
这是可数的范围，这些东西有

445
00:24:32,004 --> 00:24:36,540
那。你很少使用一个直线范围。

446
00:24:36,609 --> 00:24:38,241
你几乎总是使用可数的范围，

447
00:24:38,310 --> 00:24:41,645
或封闭的可数范围，或其中之一。但无论如何，所以

448
00:24:41,714 --> 00:24:45,081
这就是为什么它需要可以通用的类型

449
00:24:45,150 --> 00:24:46,717
可比较所以

450
00:24:46,786 --> 00:24:50,220
能够通过一些协议来限制这种通用类型

451
00:24:50,288 --> 00:24:54,558
真的超级强大好的，因为它允许你

452
00:24:54,627 --> 00:24:59,362
构建更广泛的通用数据结构。

453
00:24:59,431 --> 00:25:00,297
因为你可以这样做

454
00:25:00,366 --> 00:25:02,833
他们必须执行某些事情才能奏效。

455
00:25:02,901 --> 00:25:07,538
好吧。现在，也可以使用

456
00:25:07,606 --> 00:25:11,875
泛型声明协议。所以你可以有协议，

457
00:25:11,944 --> 00:25:16,947
var中的方法可能是通用类型。所以，

458
00:25:17,016 --> 00:25:18,849
现在你可以有这些协议类型的元。

459
00:25:18,917 --> 00:25:21,919
但是您可以使用这些协议

460
00:25:21,987 --> 00:25:26,056
描述可以处理泛型类型的行为。

461
00:25:26,125 --> 00:25:28,625
或者可能在实现某些通用类型的工作

462
00:25:28,694 --> 00:25:32,496
协议。现在，这可能很难你

463
00:25:32,564 --> 00:25:35,899
想象一下这可能会去哪里，但真的可以去。

464
00:25:35,968 --> 00:25:39,036
好的，所以你真的打开了很多的力量

465
00:25:39,105 --> 00:25:42,973
通过添加泛型。并约束这些泛型

466
00:25:43,041 --> 00:25:47,144
使用协议。再次记得你好

467
00:25:47,213 --> 00:25:49,913
通过协议获得多重继承。我是

468
00:25:49,982 --> 00:25:51,948
以CountableRange的形式向您展示一个例子。

469
00:25:52,017 --> 00:25:55,852
所以CountableRange是你使用的结构类型

470
00:25:55,921 --> 00:26:00,490
3 .. <5。记得我向你表明了这一点。喜欢，如果你正在做一个4

471
00:26:00,559 --> 00:26:03,226
在你想要提出5非包容性，

472
00:26:03,295 --> 00:26:05,862
使用三点点五你得到这个可数范围。

473
00:26:05,931 --> 00:26:08,365
那么，他认为CountableRange是什么。

474
00:26:08,434 --> 00:26:11,434
CountableRange是一个实现ton的结构体

475
00:26:11,503 --> 00:26:13,070
的协议。

476
00:26:13,138 --> 00:26:14,771
这里有一些它实现的有趣的。

477
00:26:14,840 --> 00:26:19,142
IndexableBase给它开始起始索引和结束

478
00:26:19,211 --> 00:26:22,012
索引，我向你展示了这种幻灯片的错误

479
00:26:22,081 --> 00:26:26,416
作为范围，它也实现了这个方法索引

480
00:26:26,485 --> 00:26:29,019
后。所以，一个范围可以向前移动你可以永远

481
00:26:29,087 --> 00:26:31,955
找到下一个索引。它也有下标，

482
00:26:32,023 --> 00:26:35,459
所以你可以采取一个范围，并得到下标三分之一

483
00:26:35,528 --> 00:26:38,795
它会让你在那里的第四个。对，

484
00:26:38,864 --> 00:26:41,331
所以协议叫做IndexableBase。那就是

485
00:26:41,399 --> 00:26:44,400
另一个协议叫Indexable。其实

486
00:26:44,469 --> 00:26:48,505
从IndexableBase继承索引offsetBy。

487
00:26:48,573 --> 00:26:51,274
所以现在你可以通过这个范围来改变

488
00:26:51,343 --> 00:26:53,944
下一个，你可以向前移动更远。

489
00:26:54,013 --> 00:26:56,780
还有BidirectionalIndexable。

490
00:26:56,849 --> 00:27:00,584
现在你可以后退，索引之前，好的。所以

491
00:27:00,652 --> 00:27:03,253
这些东西就像startIndex，索引之后，索引偏移量，

492
00:27:03,321 --> 00:27:05,789
索引之前，这些只是这些协议中的方法。

493
00:27:07,226 --> 00:27:10,527
它还实现了这个非常重要的协议

494
00:27:10,596 --> 00:27:14,798
序列。 Sequence中的主要方法是makeIterator。

495
00:27:14,866 --> 00:27:18,068
这给了一个可以做的东西的对象。

496
00:27:18,137 --> 00:27:20,837
所以一个范围，这就是为什么范围适用于，

497
00:27:20,906 --> 00:27:24,274
因为它实现了Sequence协议。和

498
00:27:24,343 --> 00:27:26,210
它还实现了收集协议。

499
00:27:26,278 --> 00:27:28,912
但是Collection只是一个可索引的序列。

500
00:27:28,980 --> 00:27:31,381
所以它实现了这两个协议

501
00:27:31,450 --> 00:27:34,250
是集合实现这两个协议。

502
00:27:34,319 --> 00:27:37,154
那么苹果为什么会这么麻烦呢

503
00:27:37,222 --> 00:27:39,523
拿一些像CountableRange一样简单的东西

504
00:27:39,592 --> 00:27:42,025
使其实现所有这些可笑的协议？

505
00:27:42,094 --> 00:27:46,129
那么这就是为什么。因为Array也实现了全部

506
00:27:46,198 --> 00:27:49,799
那些协议，所以有字典和集合和

507
00:27:49,868 --> 00:27:53,336
String.UTF16View。可以让你看到Unicode的东西

508
00:27:53,405 --> 00:27:56,673
字符串中的字符。所有这些事情都做。所以他们是

509
00:27:56,742 --> 00:28:01,278
所有共享相同的基本API描述他们的行为。

510
00:28:01,347 --> 00:28:02,645
即使他们有很大的不同。

511
00:28:02,714 --> 00:28:05,582
数组与范围完全不同。一套

512
00:28:05,650 --> 00:28:09,052
不同于数组。当然，一个人物，

513
00:28:09,120 --> 00:28:12,322
UTF16View，不同于任何这些东西。

514
00:28:12,390 --> 00:28:14,224
他们是字典。所以这些都是不同的东西。

515
00:28:14,293 --> 00:28:16,994
但他们分享可转换的行为，

516
00:28:17,062 --> 00:28:19,362
是一系列的东西，是东西的收藏，

517
00:28:19,431 --> 00:28:20,630
他们分享所有这些行为。

518
00:28:20,699 --> 00:28:24,101
所以这些协议描述和等待，

519
00:28:24,169 --> 00:28:27,204
还有更多。因为这件事我告诉过你

520
00:28:27,272 --> 00:28:30,773
扩展可以用于向协议添加代码，

521
00:28:30,842 --> 00:28:33,343
好的。现在有限制，当然是因为两者

522
00:28:33,411 --> 00:28:36,746
协议和扩展可以没有存储。

523
00:28:36,815 --> 00:28:38,281
所以如果你扩展一个协议和

524
00:28:38,350 --> 00:28:40,250
给它一些实际的实现，

525
00:28:40,319 --> 00:28:43,020
通过实现协议中的一些方法。

526
00:28:43,088 --> 00:28:46,790
您只能在协议中使用其他方法。要么

527
00:28:46,859 --> 00:28:48,558
从其他协议继承的方法，

528
00:28:48,627 --> 00:28:50,894
对？您不能使用任何存储。

529
00:28:50,962 --> 00:28:52,362
所有你可以做的是调用其他方法和变量。但

530
00:28:52,430 --> 00:28:55,231
当你这么做时，你会感到惊讶。

531
00:28:55,300 --> 00:28:56,400
那可以让你做什么，

532
00:28:56,468 --> 00:29:00,570
在这种情况下，如果你考虑Sequence。我告诉过你

533
00:29:00,639 --> 00:29:02,739
顺序大多只是让你成为一个真正的东西。

534
00:29:02,807 --> 00:29:06,076
所以，你可以通过字符串的字符或

535
00:29:06,144 --> 00:29:10,147
通过阵列或通过范围或任何。好，

536
00:29:10,215 --> 00:29:13,817
如果你只是实现一种方法，苹果已经提供了

537
00:29:13,886 --> 00:29:17,253
序列协议的扩展。实现两个

538
00:29:17,322 --> 00:29:19,889
基于能够迭代的十几种其他方法

539
00:29:19,958 --> 00:29:24,494
通过。像包含，这个东西包含在这里

540
00:29:24,563 --> 00:29:28,197
序列？或者通过分隔符加入，这将需要

541
00:29:28,266 --> 00:29:31,301
顺序中的每一件事情，将它变成一个字符串，和

542
00:29:31,369 --> 00:29:34,070
通过你说的任何分隔符加入，就像一个逗号，和

543
00:29:34,139 --> 00:29:37,507
给你一个字符串。好的？或最小和最大。

544
00:29:37,576 --> 00:29:39,976
最小的东西是什么，还是最大的东西？

545
00:29:40,045 --> 00:29:40,743
当然在这种情况下，

546
00:29:40,812 --> 00:29:43,813
该序列必须有什么，可比较

547
00:29:43,882 --> 00:29:47,217
项目？你必须能够比较它们。如果你要

548
00:29:47,286 --> 00:29:50,954
做最小或最大即使我告诉你的那些很酷的功能，

549
00:29:51,023 --> 00:29:53,991
过滤和地图，记得那些？那闭包了

550
00:29:54,059 --> 00:29:56,493
您可以将数组从一件事映射到另一件事。

551
00:29:56,561 --> 00:29:58,361
你可以做同样的事情与一个范围。和

552
00:29:58,430 --> 00:30:01,798
该代码不在Array中。在这个扩展中

553
00:30:01,867 --> 00:30:07,137
序列。好的，所以现在你实际上是继承了

554
00:30:07,205 --> 00:30:10,140
真正的实现，真正的功能。和

555
00:30:10,209 --> 00:30:13,410
你是多重继承它，好吗？和

556
00:30:13,478 --> 00:30:15,445
你这样做是通用的

557
00:30:15,514 --> 00:30:18,815
该代码适用于数组，字符串字符等，

558
00:30:18,884 --> 00:30:23,020
一样。好的，希望这样给你一些感觉

559
00:30:23,088 --> 00:30:26,356
喜欢哇，如果你有这些协议，你该怎么办？

560
00:30:26,424 --> 00:30:29,826
如果您使用协议设计了您的API。

561
00:30:29,894 --> 00:30:33,229
然后，您可以使用扩展名添加这样的代码。

562
00:30:33,298 --> 00:30:37,133
你可以希望看到，特别是使用泛型，你可以

563
00:30:37,202 --> 00:30:41,471
看看如何重用很多代码。现在这个办法，我

564
00:30:41,540 --> 00:30:45,142
实际上以前提到过。这种重点关注的方法

565
00:30:45,210 --> 00:30:47,777
事物的行为而不是存储的行为。

566
00:30:47,846 --> 00:30:54,150
导致了一种称为功能编程的方法。

567
00:30:54,219 --> 00:30:56,786
再次，我不能教你不幸的是，但是

568
00:30:56,855 --> 00:30:59,556
我想让你知道它存在。也许你可以拿

569
00:30:59,624 --> 00:31:01,725
一个课程，在这里你可以了解它。

570
00:31:01,794 --> 00:31:05,128
如果你出去外面的世界，自学

571
00:31:05,197 --> 00:31:08,365
如果你必须自己这是非常强大的机制

572
00:31:08,433 --> 00:31:10,433
编程。和协议和

573
00:31:10,502 --> 00:31:13,803
generics 这个。因为协议和泛型

574
00:31:13,872 --> 00:31:17,240
都是关于事物的行为，而不是他们的行为

575
00:31:17,308 --> 00:31:22,178
存储。好的，好的这就是我不幸的是

576
00:31:22,247 --> 00:31:24,247
有时间谈论函数式编程和

577
00:31:24,316 --> 00:31:26,750
协议。现在让我们回来了

578
00:31:26,818 --> 00:31:27,851
高级协议和

579
00:31:27,919 --> 00:31:30,720
开始谈论协议的几个简单用法。

580
00:31:30,788 --> 00:31:33,923
这是一个简单的协议，你现在可以使用

581
00:31:33,992 --> 00:31:37,194
你的计算器。它被称为CustomStringConvertible。

582
00:31:37,262 --> 00:31:41,064
而在协议中它只是一个var。

583
00:31:41,133 --> 00:31:44,801
这是一个get-only var称为描述。看起来很熟悉

584
00:31:44,870 --> 00:31:48,005
哪个是一个字符串如果您实现此协议，

585
00:31:48,073 --> 00:31:50,707
那么当你打印时，如果你做反斜杠，

586
00:31:50,775 --> 00:31:54,211
把你的东西放在里面。它会打电话

587
00:31:54,279 --> 00:31:57,681
这个描述得到它的描述。对了

588
00:31:57,749 --> 00:32:02,518
现在，如果你说，打印报价\（你的CalculatorBrain，

589
00:32:02,587 --> 00:32:06,590
在你的视图控制器，），它可能打印出一些

590
00:32:06,658 --> 00:32:09,959
十六进制数字和CalculatorBrain这个字

591
00:32:10,028 --> 00:32:14,264
无用。但是如果你把冒号的CustomStringConvertible放在后面

592
00:32:14,332 --> 00:32:18,134
你的结构CalculatorBrain，现在，当你打印出来，

593
00:32:18,203 --> 00:32:21,337
它将打印出描述。换一种说法，

594
00:32:21,406 --> 00:32:24,541
方程式，对，因为你实现描述

595
00:32:24,609 --> 00:32:27,444
已经。我有意地选择了名称描述

596
00:32:27,513 --> 00:32:29,979
以便您可以实现CustomStringConvertible

597
00:32:30,048 --> 00:32:33,583
自动。但是你也必须说你实现

598
00:32:33,651 --> 00:32:35,218
它。你不能只是实现描述和

599
00:32:35,286 --> 00:32:37,820
期待它工作。你必须说，是的，我实行

600
00:32:37,889 --> 00:32:40,290
CustomString可以通过放在那里。

601
00:32:40,359 --> 00:32:42,292
所以尝试一下。去找你的计算器

602
00:32:42,361 --> 00:32:44,327
放这个冒号CustomStringConvertible。和

603
00:32:44,395 --> 00:32:47,230
然后，在你的控制器的某个地方，打印出你的

604
00:32:47,298 --> 00:32:51,834
CalculatorBrain with \（）。看看你有什么，好吗？

605
00:32:51,903 --> 00:32:56,540
协议的另一个很简单的使用是委托，好吗？

606
00:32:56,608 --> 00:32:59,809
这真的是我们一直在这里领导的地方，

607
00:32:59,878 --> 00:33:03,713
在协议的用例方面。这不会

608
00:33:03,782 --> 00:33:06,048
使用我正在谈论的任何其他东西，泛型或

609
00:33:06,117 --> 00:33:07,617
扩展，没有一个，好吗？

610
00:33:07,686 --> 00:33:10,853
这只是协议的最简单可能的使用，

611
00:33:10,922 --> 00:33:12,555
尽管它使用Objective-C协议

612
00:33:12,624 --> 00:33:15,925
因为这些协议中有很多可选的方法。

613
00:33:15,994 --> 00:33:18,928
但这是我们将如何实现这个MVC

614
00:33:18,997 --> 00:33:21,531
我们谈论的是盲目的，结构化的

615
00:33:21,600 --> 00:33:24,901
通讯。代表和数据源，记住

616
00:33:24,970 --> 00:33:28,371
从讲座2？这就是我们如何实现它，

617
00:33:28,439 --> 00:33:31,307
我们将通过协议实现。所以这是怎么回事

618
00:33:31,376 --> 00:33:35,679
它发挥，使用协议来做这个授权。第一，

619
00:33:35,747 --> 00:33:39,416
UIView的东西，好吧，像一个ScrollView，例如，

620
00:33:39,484 --> 00:33:43,353
或者TableView，我们将在下周讨论。

621
00:33:43,421 --> 00:33:47,423
它声明一个协议，它有所有的意志和

622
00:33:47,492 --> 00:33:49,759
应该和做我正在谈论的方法。

623
00:33:49,827 --> 00:33:52,929
所以我会滚动到这里，或者我应该允许滚动

624
00:33:52,998 --> 00:33:55,999
这个方向？这些方法，它实现

625
00:33:56,068 --> 00:33:58,768
一个只是列出了这些方法的协议。

626
00:33:58,837 --> 00:34:00,770
它将成为Objective-C协议，

627
00:34:00,839 --> 00:34:03,406
他们几乎都是可选的，好吗？所以

628
00:34:03,475 --> 00:34:07,877
只是声明该协议。然后视图添加了公共API

629
00:34:07,946 --> 00:34:12,615
对自己来说，这是一种称为代理或弱势的财产

630
00:34:12,684 --> 00:34:17,621
有时是数据源。那种类型是那个协议，

631
00:34:19,224 --> 00:34:22,458
好的？所以任何事情都可以分配给那个var，

632
00:34:22,527 --> 00:34:27,197
只要它实现该协议。视图使用这个

633
00:34:27,266 --> 00:34:29,932
delegate属性本身得到答案，

634
00:34:30,001 --> 00:34:33,670
我应该滚动这里，告诉人们，我只是滚动

635
00:34:33,739 --> 00:34:36,540
在这里，好吗？它将这些消息发送给代理，

636
00:34:36,608 --> 00:34:38,608
因为委托可以实现，

637
00:34:38,677 --> 00:34:41,077
该协议的方法，所以我们可以发送给他们。

638
00:34:41,146 --> 00:34:43,746
如果没有委托，如果代理为nil，

639
00:34:43,815 --> 00:34:47,116
因为这个weak delegate属性，由于它很weak，

640
00:34:47,185 --> 00:34:51,521
它必须是一个可选的。所有weak属性都是可选的。

641
00:34:51,590 --> 00:34:53,189
所以可能是零。如果没有，

642
00:34:53,257 --> 00:34:55,458
那么ScrollView只是不会和代表交谈。

643
00:34:55,527 --> 00:34:57,828
它不会问任何问题或告诉任何事情。

644
00:34:59,264 --> 00:35:03,166
现在，控制器声明它实现了

645
00:35:03,235 --> 00:35:05,201
协议。这就是它所说的。

646
00:35:05,270 --> 00:35:08,438
它必须说在顶部，你知道，如果视图，类UIView，

647
00:35:08,506 --> 00:35:11,107
类计算器视图控制器，无论如何

648
00:35:11,176 --> 00:35:14,411
UIViewController逗号UIScrollViewDelegate。所以

649
00:35:14,479 --> 00:35:18,214
它说，我实现了。然后控制器设置

650
00:35:18,283 --> 00:35:23,119
本身就是这个观点的代表，现在是合法的

651
00:35:23,188 --> 00:35:25,455
因为控制器声称实现该协议。

652
00:35:25,524 --> 00:35:28,024
所以现在可以把它变成一个类型

653
00:35:28,093 --> 00:35:30,260
那个协议。最后，

654
00:35:30,329 --> 00:35:32,428
控制器实现所需的任何方法。

655
00:35:32,497 --> 00:35:34,630
因为它们大概是可选的，它可以选择和

656
00:35:34,699 --> 00:35:36,699
选择它想要的。

657
00:35:36,768 --> 00:35:40,103
那些已经和应该的方法现在将开始

658
00:35:40,172 --> 00:35:43,339
发送给它的ScrollView或什么，好吗？

659
00:35:43,408 --> 00:35:45,107
所以现在这个视图与控制器挂钩了。

660
00:35:45,176 --> 00:35:48,278
这个观点不知道他在说什么。所有它知道

661
00:35:48,347 --> 00:35:50,680
这个代表是它实现那些应该和

662
00:35:50,749 --> 00:35:52,015
做了事情这一切都知道，

663
00:35:52,084 --> 00:35:54,684
所以它是一个完全通用和可重用的视图。

664
00:35:54,753 --> 00:35:58,221
但它可以与控制器进行通信。这个机制

665
00:35:58,290 --> 00:36:01,524
的代理，你会发现这一切都在整个iOS。

666
00:36:01,593 --> 00:36:05,194
任何复杂的iOS对象都会使用委托

667
00:36:05,263 --> 00:36:07,430
需要谈谈控制器

668
00:36:07,499 --> 00:36:10,934
以复杂的方式。虽然这是全部设计的，

669
00:36:11,003 --> 00:36:13,770
之前的Swift和pre-closures，这样的事情。

670
00:36:13,839 --> 00:36:17,006
很多时候，关闭可能是一个更好的解决方案

671
00:36:17,075 --> 00:36:22,145
比代理。所以，代理 - 一点点，

672
00:36:22,213 --> 00:36:26,182
你叫什么，向后兼容的东西。

673
00:36:26,250 --> 00:36:28,184
但是，如果你要做iOS，你还是要知道，

674
00:36:28,253 --> 00:36:32,422
因为它只是iOS的无处不在。顺便一提，

675
00:36:32,490 --> 00:36:35,792
不要在你的家庭作业中使用授权三。

676
00:36:35,860 --> 00:36:37,927
我想我甚至可以把它作为一项必要的任务。

677
00:36:37,996 --> 00:36:40,730
你不能这样做，不要使用委托。我从不

678
00:36:40,798 --> 00:36:43,399
在任务完成之后教你什么，

679
00:36:43,468 --> 00:36:47,603
你知道，开始了。代理不是

680
00:36:47,672 --> 00:36:51,140
作业三。好的，让我们快速看一下

681
00:36:51,209 --> 00:36:53,909
这对于ScrollView来说看起来像代码。第一，

682
00:36:53,978 --> 00:36:56,512
ScrollView将会有一个var调用委托。

683
00:36:56,581 --> 00:36:59,382
它将是UIScrollViewDelegate类型的可选项

684
00:36:59,451 --> 00:37:02,852
因为它很弱协议UIScrollViewDelegate

685
00:37:02,921 --> 00:37:06,356
看起来像这样。它有这些可选功能，

686
00:37:06,425 --> 00:37:08,325
像scrollViewDidScroll和

687
00:37:08,393 --> 00:37:11,327
在ScrollView中给我viewForZooming，

688
00:37:11,395 --> 00:37:15,297
那么控制器会说，是的，我实现

689
00:37:15,366 --> 00:37:18,734
UIScrollViewDelegate通过做小或紫色或

690
00:37:18,803 --> 00:37:22,538
蓝色或任何代码。并在viewDidLoad中，视图

691
00:37:22,607 --> 00:37:26,075
控制器会说，ScrollView的代理是我。

692
00:37:26,144 --> 00:37:28,678
所以ScrollView，请给我发这些消息。和

693
00:37:28,746 --> 00:37:32,281
那么它只会实现它想要的任何方法。

694
00:37:32,350 --> 00:37:35,752
我们将在今天将要做的演示中看到这一点。

695
00:37:35,821 --> 00:37:37,386
好的，那就是代理。

696
00:37:37,455 --> 00:37:42,925
我们现在转到使用授权的第一类，

697
00:37:42,994 --> 00:37:44,794
它是ScrollView。在谈论ScrollView之前，

698
00:37:44,863 --> 00:37:46,462
我想向您展示一下ScrollView如何工作，

699
00:37:46,531 --> 00:37:47,930
这个古老的视频我有。

700
00:37:47,999 --> 00:37:50,599
这就像，我不知道，iPhone 1或什么。但

701
00:37:50,668 --> 00:37:52,202
如果你看看滚动的方式，

702
00:37:52,270 --> 00:37:54,036
它实际上是非常复杂的。

703
00:37:54,105 --> 00:37:56,805
它可以有一个水平滚动的东西，

704
00:37:56,874 --> 00:37:58,441
像股票图表，和

705
00:37:58,510 --> 00:38:01,110
在它的内部，有垂直滚动ScrollView。

706
00:38:01,179 --> 00:38:03,646
那就是ScrollViews里面的ScrollViews，好吗？

707
00:38:03,715 --> 00:38:06,483
而ScrollView的智能足以知道你是否滑动

708
00:38:06,551 --> 00:38:11,687
横向或垂直使其滚动。现在来谈谈

709
00:38:11,756 --> 00:38:15,525
关于你如何把东西放在ScrollView中，所以你可以滚动

710
00:38:15,593 --> 00:38:19,795
在它周围。但是您可以通过添加子视图来实现。所以

711
00:38:19,864 --> 00:38:22,698
我们来看看我们如何将一个视图添加到普通视图中。所以

712
00:38:22,767 --> 00:38:26,002
我创建一个视图，就像一个标志视图。我设定了框架，

713
00:38:26,071 --> 00:38:28,203
这是它的父视图。

714
00:38:28,272 --> 00:38:30,940
然后我只是添加到它的父视图。所以在这里，我在说

715
00:38:31,009 --> 00:38:34,043
view.addSubview（logo）视图可能是顶级视图

716
00:38:34,112 --> 00:38:37,213
在我看来控制器。或者我们知道有一个var

717
00:38:37,282 --> 00:38:40,883
为此看法。所以一个ScrollView是类似的。但

718
00:38:40,952 --> 00:38:44,153
在你做这些之前，你做的很重要

719
00:38:44,221 --> 00:38:48,124
step，即设置scrollView的contentSize。

720
00:38:48,192 --> 00:38:51,427
所以这是一个var contentSize。这是一个CGSize。

721
00:38:51,496 --> 00:38:54,230
它将会是你将要有多大的空间

722
00:38:54,299 --> 00:38:56,932
滚动所以你必须首先设置。它的

723
00:38:57,001 --> 00:38:59,669
非常重要的是设置第一。但是之后呢，

724
00:38:59,738 --> 00:39:02,705
你只需添加查看，就像你以前一样。

725
00:39:02,774 --> 00:39:07,777
所以在这里，我添加了，这个标志视图在2700和

726
00:39:07,846 --> 00:39:12,449
50下来就是这样，所以现在的ScrollView是

727
00:39:12,517 --> 00:39:15,418
去滚动。在这里，我添加了另一个。

728
00:39:15,486 --> 00:39:17,987
我们再加两个意见，好的，我们在那里有两个意见。和

729
00:39:18,056 --> 00:39:21,490
现在，ScrollView正在滚动

730
00:39:21,559 --> 00:39:24,293
在这个内容区域。你看，它只是滚动。

731
00:39:24,362 --> 00:39:27,229
其实你甚至会看到内容区域的白色

732
00:39:27,298 --> 00:39:30,733
当你滚动来做到这一点。现在，当然，

733
00:39:30,802 --> 00:39:33,870
你可以重新定位视图。让我们把这个大

734
00:39:33,938 --> 00:39:35,538
在角落的鸟瞰图。和

735
00:39:35,606 --> 00:39:38,207
那么我们把斯坦福标志放在一起，使它重叠。

736
00:39:38,276 --> 00:39:40,777
然后我们随时可以随时更改我们的contentSize

737
00:39:40,845 --> 00:39:44,113
我们想没有任何额外的空间，对，

738
00:39:44,182 --> 00:39:47,317
并包含整件事情。那么如果我们这样做，那么，

739
00:39:47,385 --> 00:39:50,720
当我们滚动时，我们没有看到

740
00:39:50,789 --> 00:39:55,024
那里的白色背景。这就是ScrollView的工作原理，

741
00:39:55,093 --> 00:39:57,693
不能简单这一切都是关于内容大小的。

742
00:39:57,762 --> 00:39:59,595
如果您忘记设置内容大小，

743
00:39:59,664 --> 00:40:03,533
滚动视图将无法正常工作。如果你还没记得别的话

744
00:40:03,601 --> 00:40:07,170
这个讲座，请记住。一旦滚动，

745
00:40:07,239 --> 00:40:10,239
您可以找到有关它在哪里的信息。

746
00:40:10,308 --> 00:40:12,041
你可以找到左上角的

747
00:40:12,109 --> 00:40:15,412
滚动视图在哪里的示例。使用scrollView的

748
00:40:15,480 --> 00:40:18,480
contentOffset点，它会告诉你x和

749
00:40:18,549 --> 00:40:21,484
这个东西在左上角的y。你可以

750
00:40:21,552 --> 00:40:25,554
也只是说，当前的矩形在哪里

751
00:40:25,623 --> 00:40:29,826
显示scrollView，在视图中显示的位置

752
00:40:29,894 --> 00:40:33,596
后面就像斯坦福大学的鸟瞰？但是要做到这一点，

753
00:40:33,665 --> 00:40:36,432
不要忘记那些是不同的坐标系。

754
00:40:36,501 --> 00:40:37,100
他们有不同的看法

755
00:40:37,169 --> 00:40:38,101
他们有不同的坐标系。

756
00:40:38,169 --> 00:40:40,670
所以你必须转换，好吧。

757
00:40:40,739 --> 00:40:43,606
你会转换scrollView的边界，对，

758
00:40:43,675 --> 00:40:44,440
scrollView的界限，

759
00:40:44,509 --> 00:40:46,943
这在scrollView的坐标系中。你是

760
00:40:47,011 --> 00:40:49,579
将它转换为视图的坐标系

761
00:40:49,648 --> 00:40:53,749
像天线。看，我在做空转，

762
00:40:53,818 --> 00:40:56,452
转换该矩形。现在为什么是这些矩形

763
00:40:56,521 --> 00:40:58,554
不一样？那么很多原因。

764
00:40:58,623 --> 00:41:01,324
一个，你正在淘汰，所以它总是在变化。

765
00:41:01,392 --> 00:41:04,360
二，你可能会放大，所以可能会有很大的不同。

766
00:41:04,428 --> 00:41:07,262
如果你放大在那个scrollView比那个小

767
00:41:07,331 --> 00:41:10,299
矩形可能代表一大块天线或它

768
00:41:10,368 --> 00:41:13,603
可能代表一个小小的天空。谁知道。

769
00:41:13,672 --> 00:41:14,837
所以你会使用我们已经看到的这种方法。

770
00:41:14,906 --> 00:41:18,374
当我们做绘图的例子时，我们看到了。

771
00:41:18,443 --> 00:41:21,944
我把中心从我的父视图转换成我的视图

772
00:41:22,013 --> 00:41:25,148
这里。我只是将绑定转换为scrollView。从

773
00:41:25,216 --> 00:41:27,916
scrollView到我感兴趣的任何视图

774
00:41:27,985 --> 00:41:33,489
在...好的现在，

775
00:41:33,558 --> 00:41:36,359
我们如何创造这些东西？很简单

776
00:41:36,428 --> 00:41:41,297
我们将它从故事板中的公用程序区域拖出。

777
00:41:41,365 --> 00:41:44,299
它只是一个视图，所以你可以做UIView，scrollView框架

778
00:41:44,368 --> 00:41:47,503
如果你愿意的话，99％的时间我们把它拉出来。

779
00:41:47,572 --> 00:41:49,572
您也可以选择已经在您的视图

780
00:41:49,640 --> 00:41:53,676
故事板，然后去嵌入并说“嵌入在 - >滚动”

781
00:41:53,745 --> 00:41:55,211
视图。它会把它放在scrollView里面。可以，然后呢

782
00:41:55,279 --> 00:42:00,149
这是另一种做法。然后你只需添加任何东西

783
00:42:00,218 --> 00:42:02,918
你太大的看法是。你想滚动的视图。

784
00:42:02,987 --> 00:42:04,453
您只需将其添加为scrollView的子视图。但

785
00:42:04,522 --> 00:42:07,524
当然，你不会忘记设置contentSize。

786
00:42:08,960 --> 00:42:11,861
好的？就这样，使用起来真的很简单。

787
00:42:11,930 --> 00:42:15,264
你可以通过编程方式滚动，

788
00:42:15,333 --> 00:42:18,367
显然，用户会有触摸。

789
00:42:18,436 --> 00:42:20,636
他们可以只是平息，

790
00:42:20,705 --> 00:42:23,906
但是你也可以通过scrollRectToVisible来做到这一点，

791
00:42:23,975 --> 00:42:26,375
它将采取一个矩形并做它

792
00:42:26,444 --> 00:42:29,211
希望完全适合屏幕。它会做到最小

793
00:42:29,280 --> 00:42:31,847
获取该矩形所需的滚动量，

794
00:42:31,916 --> 00:42:35,818
在屏幕上。你可以在scrollView中做很多其他的事情，

795
00:42:35,887 --> 00:42:38,554
我没有时间谈论像控制一样

796
00:42:38,623 --> 00:42:41,857
这种行为只能垂直滚动或

797
00:42:41,926 --> 00:42:44,994
它会在第一个动作中显示出来

798
00:42:45,063 --> 00:42:48,530
你是什​​么意思，做什么你可以闪光

799
00:42:48,599 --> 00:42:53,168
当屏幕上出现事件时滚动指示灯。

800
00:42:53,237 --> 00:42:57,240
您也可以偏移您正在滚动的实际内容

801
00:42:57,308 --> 00:42:58,808
过了一点点

802
00:42:58,877 --> 00:43:01,043
这在导航控制器中发生了很多。

803
00:43:01,112 --> 00:43:03,946
有时在顶部的酒吧，这是半不透明的，或

804
00:43:04,015 --> 00:43:07,049
半透明，不够透明

805
00:43:07,118 --> 00:43:09,819
无论你在看什么，你的应用

806
00:43:09,887 --> 00:43:12,421
您的滚动视图。所以你会补偿一点，

807
00:43:12,490 --> 00:43:15,825
您将被该导航的高度所抵消的内容

808
00:43:15,893 --> 00:43:18,394
画。所以有一堆东西在那里我不能

809
00:43:18,462 --> 00:43:22,564
真的在说另一大部分是放大。

810
00:43:22,633 --> 00:43:25,001
所以，我们已经在滚动视图中讨论过平移

811
00:43:25,070 --> 00:43:27,403
您还可以使用您的捏捏放大和

812
00:43:27,472 --> 00:43:32,007
出。所以放大和缩小，工作方式，

813
00:43:32,076 --> 00:43:35,611
所有UIViews都有一个称为它们的变换的属性。

814
00:43:35,680 --> 00:43:40,316
这是一个仿射变换，意味着它有translate，scale，

815
00:43:40,385 --> 00:43:44,253
和rotate。当你捏在一个视图上时，

816
00:43:44,321 --> 00:43:47,490
它所做的一切正在影响其转型的比例，

817
00:43:47,559 --> 00:43:51,060
什么都不做现在对于大多数视图，

818
00:43:51,129 --> 00:43:53,395
所有的意见，这将扩大比例。所以

819
00:43:53,464 --> 00:43:56,265
如果你放大了很大，你会有很大的像素。

820
00:43:56,334 --> 00:43:59,869
看起来真的很颗粒。但如果这个视图想要，

821
00:43:59,938 --> 00:44:03,172
它可以使它看起来真的很好，缩放后

822
00:44:03,241 --> 00:44:07,710
完成，例如，UIImageView这样做。如果你放大

823
00:44:07,779 --> 00:44:11,647
在一个UI图像上，它有更多的分辨率，它会

824
00:44:11,716 --> 00:44:14,816
在放大时向他们显示，您可以这样做

825
00:44:14,885 --> 00:44:18,020
例如，用你的计算器。如果你有你的计算器

826
00:44:18,089 --> 00:44:19,421
一个滚动视图，你不会去。

827
00:44:19,490 --> 00:44:22,859
但是如果你这样做，如果你有图表的一部分，你可以，

828
00:44:22,927 --> 00:44:25,561
当它被夹住时，当它完成捏，你可以

829
00:44:25,630 --> 00:44:29,365
重新画图，给它很好的平滑曲线，对，所以

830
00:44:29,434 --> 00:44:32,301
它不会全部像素化。好吧，

831
00:44:32,370 --> 00:44:35,371
我会在下一张幻灯片中告诉你如何做到这一点。所以，

832
00:44:35,440 --> 00:44:38,774
关于放大滚动视图的两件事情，尽管如此

833
00:44:38,843 --> 00:44:41,310
必须知道。一个是你必须设置最小和

834
00:44:41,379 --> 00:44:44,880
最大缩放倍数。这就是你放大的距离

835
00:44:44,949 --> 00:44:47,049
你被允许放大多远。和

836
00:44:47,118 --> 00:44:51,754
默认情况下这些是1.0和1.0，这意味着没有缩放

837
00:44:51,823 --> 00:44:55,324
没有缩小。所以你必须设置这些东西。所以

838
00:44:55,393 --> 00:44:58,027
如果将最小缩放比例设置为0.5，

839
00:44:58,096 --> 00:45:01,030
意味着您将缩小到正常尺寸的一半。

840
00:45:01,099 --> 00:45:02,597
如果将最大缩放比例设置为2.0，则表示

841
00:45:02,666 --> 00:45:05,034
你会缩小到正常尺寸的两倍。好的，所以

842
00:45:05,103 --> 00:45:08,838
您可以决定要让用户放大多少

843
00:45:08,906 --> 00:45:13,408
出来另一件是你需要一个委托方法。

844
00:45:13,477 --> 00:45:16,278
缩放在没有授权的情况下不起作用。所以

845
00:45:16,347 --> 00:45:18,881
你必须实现这个委托方法

846
00:45:18,949 --> 00:45:21,950
viewForZooming（在scrollView中），你所要做的就是

847
00:45:22,019 --> 00:45:24,253
返回滚动视图中的视图，

848
00:45:24,322 --> 00:45:28,056
其中一个子视图，您将要放大的。

849
00:45:28,125 --> 00:45:33,162
而这就是变形的转变。

850
00:45:33,231 --> 00:45:38,400
当然，您也可以以编程方式放大。

851
00:45:38,469 --> 00:45:39,835
它不只是压缩来缩放。

852
00:45:39,904 --> 00:45:42,438
您可以设置缩放比例。这里有一些关于如何的例子

853
00:45:42,507 --> 00:45:45,574
去做。所以在这里我将缩放比例设置为1.2，现在我要去了

854
00:45:45,643 --> 00:45:48,810
设置为1.0。看到它恢复正常的大小。

855
00:45:48,879 --> 00:45:53,449
1.2我被放大了20％好或同样的事情与rect。如果我放

856
00:45:53,518 --> 00:45:56,052
在那里有一个小矩形，我说缩放到那个rect

857
00:45:56,120 --> 00:45:58,354
它会放大缩小，尽可能大。

858
00:45:58,422 --> 00:46:00,723
或者如果我有一个更大的矩形

859
00:46:00,792 --> 00:46:03,025
我说缩放直到它会缩小它

860
00:46:03,094 --> 00:46:05,327
矩形适合。好吧，这样做最小

861
00:46:05,396 --> 00:46:10,599
缩放以在屏幕上获得该矩形。

862
00:46:10,668 --> 00:46:12,835
还有很多其他委托方法，

863
00:46:12,903 --> 00:46:15,604
除了缩放视图之外，还有至少十几个

864
00:46:15,673 --> 00:46:18,341
滚动视图。例如，如果你想做这件事情

865
00:46:18,409 --> 00:46:21,077
你放大的地方，然后你想重绘

866
00:46:21,145 --> 00:46:22,978
要摆脱像素化，你会实现

867
00:46:23,047 --> 00:46:27,983
scrollViewDidEndZooming with view atScale。和

868
00:46:28,052 --> 00:46:30,452
这会告诉你什么时候挤压已经停止了

869
00:46:30,521 --> 00:46:33,089
现在你可以重绘。当然，如果你重画

870
00:46:33,157 --> 00:46:35,657
在新比例的方式，你会重置

871
00:46:35,726 --> 00:46:38,060
你的变革，视野的转变，

872
00:46:38,129 --> 00:46:41,329
回到身份转换。否则，你会的

873
00:46:41,398 --> 00:46:44,433
两者都绘制它，它将被缩放，因为你是

874
00:46:44,502 --> 00:46:47,202
仿射变换也很像素化。所以，你没有

875
00:46:47,271 --> 00:46:48,871
想要同时进行这些事情。

876
00:46:48,939 --> 00:46:52,441
所以你重置，你会在这里重置你的转换。

877
00:46:54,311 --> 00:46:58,181
好的，所以其余的将是演示，所以

878
00:46:58,249 --> 00:47:00,916
让我来谈谈这里有什么。

879
00:47:00,985 --> 00:47:04,320
我会做的演示是滚动视图演示，显然。

880
00:47:04,388 --> 00:47:05,321
我会告诉你如何做到这一点

881
00:47:05,390 --> 00:47:07,022
我会给你一些其他的东西，像扩展，

882
00:47:07,091 --> 00:47:09,958
像这样的东西。星期五我们有

883
00:47:10,027 --> 00:47:13,195
仪器。好的，性能测试。真的很重要，如果

884
00:47:13,264 --> 00:47:15,630
你想在作业3中做额外的学分，

885
00:47:15,699 --> 00:47:16,398
这是一个好的，

886
00:47:16,467 --> 00:47:19,068
你必须弄清楚为什么你的计算器，

887
00:47:19,137 --> 00:47:22,404
图形的东西不如你想要的那样好。

888
00:47:22,473 --> 00:47:24,974
星期一，作业3，你现在在做什么，

889
00:47:25,043 --> 00:47:27,877
您的绘图计算器在演讲之前到期。和

890
00:47:27,945 --> 00:47:30,112
那么周一的话题将是多线程。

891
00:47:30,180 --> 00:47:32,047
我们将要采取我们今天在做的演示，

892
00:47:32,116 --> 00:47:33,682
这将是非常缓慢，

893
00:47:33,751 --> 00:47:35,551
我们将使用更好的表现

894
00:47:35,620 --> 00:47:39,722
多线程。星期三我们要进去

895
00:47:39,791 --> 00:47:43,792
TableView，是UIKit的重要组成部分。

896
00:47:43,861 --> 00:47:46,061
将有一个作业，一个TableView作业

897
00:47:46,130 --> 00:47:49,498
周三出来这将在下周三。和

898
00:47:49,567 --> 00:47:51,667
没有更多的阅读作业。我可以告诉

899
00:47:51,735 --> 00:47:54,770
和你们中的一些人交谈，你们没有阅读任何内容

900
00:47:54,838 --> 00:47:59,041
他们非常密切。你知道吗，我不会问你，

901
00:47:59,109 --> 00:48:02,678
我不会测试你的，因为它是由你来决定的

902
00:48:02,746 --> 00:48:04,680
很多你想在这个课上学习。

903
00:48:04,749 --> 00:48:06,415
这只是其中任何一件事情

904
00:48:06,483 --> 00:48:08,250
这是你得到的。但

905
00:48:08,319 --> 00:48:12,888
我真的鼓励你至少穿过这些零件

906
00:48:12,957 --> 00:48:15,491
在那里你不明白，和

907
00:48:15,560 --> 00:48:18,226
认识到这个事实，我真的不明白这一点。

908
00:48:18,295 --> 00:48:21,396
好的，因为当你从这个班毕业时，

909
00:48:21,465 --> 00:48:23,532
这是你知道的，你正在开始使用iOS

910
00:48:23,600 --> 00:48:26,168
这个班。当你毕业后，你会知道，

911
00:48:26,237 --> 00:48:27,770
好的，这是我要回去的东西

912
00:48:27,838 --> 00:48:30,706
真的明白好多了好的，好的

913
00:48:30,775 --> 00:48:35,343
这个演示将再次开始。

914
00:48:35,412 --> 00:48:38,180
所以我将在单一视图中创建一个新的Xcode项目

915
00:48:38,249 --> 00:48:40,815
应用。我要叫卡西尼(Cassini)，

916
00:48:40,884 --> 00:48:44,486
我们要做一些与出现的图像的东西

917
00:48:44,555 --> 00:48:47,823
从Cassini探测器返回到土星。

918
00:48:47,892 --> 00:48:50,793
我会把它放在我把我所有地图放在同一个地方，

919
00:48:50,861 --> 00:48:55,264
主目录Developer文件夹下。在这里，我要走了

920
00:48:55,333 --> 00:48:58,600
xBetets和AppDelegate和LaunchScreen出来

921
00:48:58,669 --> 00:49:02,571
再来一次。我实际上不会移动info.plist

922
00:49:02,639 --> 00:49:07,075
尽管今天我们要看看。所以

923
00:49:07,144 --> 00:49:09,378
我们将把它们放在支持文件中。

924
00:49:11,148 --> 00:49:13,582
现在，我上次向你展示了如何重命名

925
00:49:13,651 --> 00:49:17,553
一个ViewController，如果它像这样的通用名称。

926
00:49:17,621 --> 00:49:19,120
你知道，另一件事我们可以做到这一点

927
00:49:19,189 --> 00:49:22,757
ViewController，只是删除它。所以我要去这里，

928
00:49:22,826 --> 00:49:26,162
右键点击它，并将其删除。并删除所有引用

929
00:49:26,230 --> 00:49:29,264
在这里，我要去我的故事板

930
00:49:29,333 --> 00:49:33,068
还有这个ViewController。顺便说一句，如果我去看看

931
00:49:33,136 --> 00:49:35,671
在这个ViewController的身份检查员身上。

932
00:49:35,740 --> 00:49:37,640
它仍然试图成为ViewController类，

933
00:49:37,708 --> 00:49:40,876
即使我从我的应用程序中删除了，没关系。

934
00:49:40,945 --> 00:49:43,345
但是我会通过从我的删除中修复它

935
00:49:43,414 --> 00:49:47,083
故事板。好的，所以现在没有任何ViewController。

936
00:49:48,419 --> 00:49:51,420
现在，我需要一个视图控制器为我的应用程序和

937
00:49:51,489 --> 00:49:54,022
它将被称为ImageViewController。

938
00:49:54,091 --> 00:49:57,659
它将是一个通用的，可重复使用的MVC进行显示

939
00:49:57,728 --> 00:50:02,598
一个图像。每当我建立一个MVC，我总是想看看我是否

940
00:50:02,666 --> 00:50:05,300
因此可以建立一个很好的通用可重用的

941
00:50:05,369 --> 00:50:08,537
也许我可以在我正在建立的其他应用程序中使用它。

942
00:50:08,605 --> 00:50:11,039
并且它给我作为API的纪律

943
00:50:11,108 --> 00:50:14,410
设计师甚至想到我的公共和私人API。

944
00:50:14,478 --> 00:50:17,513
所以，我们继续这样做，让我们创建一个新的文件。

945
00:50:17,582 --> 00:50:20,249
Coco Touch Class当然可以，我们称之为

946
00:50:20,318 --> 00:50:24,119
ImageViewController，它是UIViewController的一个子类。

947
00:50:24,188 --> 00:50:25,687
好的，非常仔细的在这里，

948
00:50:25,756 --> 00:50:28,824
我不想把它放在顶层。我想把它放下

949
00:50:28,893 --> 00:50:34,296
在这里我的其他文件是。好的

950
00:50:34,364 --> 00:50:36,865
我的ImageViewController在这里。我不需要

951
00:50:36,934 --> 00:50:40,669
现在无论如何，任何ViewController的生命周期。我

952
00:50:40,738 --> 00:50:45,206
也不会离开这个MVC。所以我不需要任何

953
00:50:45,275 --> 00:50:48,410
的。我其实我要去跟他说，

954
00:50:48,478 --> 00:50:51,212
因为它是一个很好的可重复使用的图像显示的东西。

955
00:50:51,281 --> 00:50:55,217
所以，你可以想象我可能想成为它的任何一个

956
00:50:55,286 --> 00:50:59,521
时间我想显示一个图像。当我有一个新的类时

957
00:50:59,590 --> 00:51:04,092
这个我最喜欢做的第一件事是想想什么

958
00:51:04,161 --> 00:51:09,598
是我的模特儿吗？因为这个MVC是什么样的模型？

959
00:51:09,667 --> 00:51:13,102
所以如果我能确定什么是模型，它会帮助我

960
00:51:13,171 --> 00:51:16,304
想清楚这个MVC是什么。

961
00:51:16,373 --> 00:51:18,340
所以这显示了一个图像，所以

962
00:51:18,409 --> 00:51:22,144
我会拥有我的模型(model)，我会公开的

963
00:51:22,213 --> 00:51:26,014
其他人可以设置我的模型，我将要成立

964
00:51:26,083 --> 00:51:29,084
图片的网址。因为我的MVC是什么？

965
00:51:29,153 --> 00:51:31,519
它显示一个图像。就是这样，一个图像淋浴。所以，

966
00:51:31,588 --> 00:51:36,124
似乎有一个图像的URL将是一个很好的模型

967
00:51:36,193 --> 00:51:42,130
为了它。现在，我们回到我们这里的故事板

968
00:51:42,199 --> 00:51:44,733
为此创建一个MVC。所以我只是要抢

969
00:51:44,801 --> 00:51:48,671
视图控制器。把它拖出这里。去吧

970
00:51:48,739 --> 00:51:52,140
身份检查员，再次，我会把它设置为

971
00:51:52,209 --> 00:51:56,512
一个ImageViewController，对吧？现在，

972
00:51:56,580 --> 00:52:00,248
我可以通过拖动更多的东西来开始构建我的UI

973
00:52:00,317 --> 00:52:03,319
在，但我认为这可能是有价值的一点，显示

974
00:52:03,387 --> 00:52:06,121
你如何在代码中构建一些UI。它会很简单，

975
00:52:06,190 --> 00:52:08,690
但是我们将在代码中构建一些UI。这里的UI是什么

976
00:52:08,759 --> 00:52:12,994
一开始就只是一个ImageViewController或

977
00:52:13,063 --> 00:52:16,765
一个UIImageView，对吧？我只是要显示一个图像

978
00:52:16,834 --> 00:52:20,268
UIImageView，这个类UIImageView。顺便一提，

979
00:52:20,337 --> 00:52:23,973
有一件事在这里缺少，你可以告诉这个警告。

980
00:52:24,041 --> 00:52:25,774
我们点击这个警告，看看它说的话。

981
00:52:25,842 --> 00:52:28,109
它说ImageViewController是无法访问的。

982
00:52:28,178 --> 00:52:32,047
还记得吗没有办法得到这个。那是因为

983
00:52:32,116 --> 00:52:35,885
没有箭头进入任何地方。

984
00:52:35,953 --> 00:52:37,953
如果我运行这个应用程序，它会崩溃和

985
00:52:38,021 --> 00:52:41,423
说，没有初始的View Controller。所以，

986
00:52:41,492 --> 00:52:43,058
您如何设置初始View Controller？好，

987
00:52:43,127 --> 00:52:45,494
您选择要作为初始视图的View Controller

988
00:52:45,562 --> 00:52:48,831
因此，您可以在此处查看属性检查器

989
00:52:48,899 --> 00:52:52,200
它是View Controller的一个属性。在这里

990
00:52:52,269 --> 00:52:55,337
在视图控制器之后的标题是，是初始

991
00:52:55,405 --> 00:52:58,807
视图控制器。所以，我点击了，看看发生了什么。

992
00:52:58,876 --> 00:53:01,343
你有一个小进入箭头。所以

993
00:53:01,411 --> 00:53:04,012
现在这个东西跑了，它会直接进入这个

994
00:53:04,081 --> 00:53:06,882
视图控制器。哪个是我们想要开始的地方

995
00:53:06,951 --> 00:53:08,617
最终我们会有其他MVC，但是

996
00:53:08,686 --> 00:53:12,454
我们从这个开始。好吧，

997
00:53:12,523 --> 00:53:15,790
回到我的ImageViewController这里。我说我想

998
00:53:15,859 --> 00:53:19,261
在代码中构建UI。我知道我需要ImageView

999
00:53:19,330 --> 00:53:22,798
我刚刚开始使用私有的var imageView：

1000
00:53:22,867 --> 00:53:26,168
是UIImageView。事实上，我会

1001
00:53:26,236 --> 00:53:28,937
在这里创建它。没有理由不只是说，

1002
00:53:29,006 --> 00:53:32,341
这个，它将用CGRect零创建它。

1003
00:53:32,409 --> 00:53:34,976
这就像说框架：CGRect.zero，

1004
00:53:35,045 --> 00:53:38,246
这与做到这一点是一样的，但你知道我们没有

1005
00:53:38,315 --> 00:53:41,350
需要额外的代码。所以现在我创建了这个图像

1006
00:53:41,418 --> 00:53:44,486
看，它在任何它的左上角

1007
00:53:44,554 --> 00:53:46,988
超级视野是，它没有任何超级视野，而且

1008
00:53:47,057 --> 00:53:49,057
它的零大小为零。所以这不是有用的，但是

1009
00:53:49,126 --> 00:53:52,461
当然，一旦我设置了一个图像，我将调整它的大小

1010
00:53:52,529 --> 00:53:56,331
以适应该图像。而谈到设置一个图像

1011
00:53:56,400 --> 00:54:00,502
在其中，我想象当我在imageView中设置一个图像时，

1012
00:54:00,571 --> 00:54:05,773
我会做一些改变框架的事情，

1013
00:54:05,842 --> 00:54:07,643
我的imageView，和类似的东西。

1014
00:54:07,712 --> 00:54:09,778
所以我会在这里创建一个私人的var

1015
00:54:09,846 --> 00:54:12,614
称为形象，这将是一个UIImage和

1016
00:54:12,683 --> 00:54:15,650
它将被计算，它将有一个获得和

1017
00:54:15,719 --> 00:54:18,653
一个集合，使每次我得到或设置图像，

1018
00:54:18,722 --> 00:54:22,524
我可以做其他的事情好的，这真是一种

1019
00:54:22,593 --> 00:54:26,228
简单干净的方式来保持，你知道做辅助事情

1020
00:54:26,297 --> 00:54:30,466
当您进行设置并获取某些数据时。

1021
00:54:30,534 --> 00:54:33,869
所以，例如，当我在这里设置这个图像时，

1022
00:54:33,937 --> 00:54:38,840
我要将imageView的图像设置为相等

1023
00:54:38,909 --> 00:54:42,444
当然这个新值。这是我的主要事情

1024
00:54:42,513 --> 00:54:45,780
想要设置我的图像，我需要设置在我的imageView。

1025
00:54:45,849 --> 00:54:49,817
所以这个var在这里只是这个imageView的图像

1026
00:54:49,886 --> 00:54:51,920
正在显示。但是也就像我说的，

1027
00:54:51,988 --> 00:54:56,959
我想设置我的imageView的大小以适应这个新的图像。

1028
00:54:57,027 --> 00:54:59,695
事实上，恰好有一个名为sizeToFit的方法

1029
00:54:59,763 --> 00:55:02,531
imageView将使其将其框架调整大小

1030
00:55:02,599 --> 00:55:04,032
适合它内部的任何图像。

1031
00:55:04,100 --> 00:55:07,669
所以很好，它有这个很好的方法

1032
00:55:07,738 --> 00:55:10,405
我在这里如果我控制点击它，你可以阅读它。

1033
00:55:10,474 --> 00:55:12,040
看到这是它说的。

1034
00:55:12,109 --> 00:55:14,576
那么得到它呢？嗯，我要回来了

1035
00:55:14,645 --> 00:55:19,347
在这种情况下，imageView的图像。好的，这样

1036
00:55:19,416 --> 00:55:22,918
是一个var，它是计算，所以没有存储。和

1037
00:55:22,987 --> 00:55:26,555
实际上我在imageView中进行存储。现在，

1038
00:55:26,623 --> 00:55:29,491
这是给我一个错误在这里。而且它的错误

1039
00:55:29,560 --> 00:55:32,527
给我的是我需要解开这个。好，

1040
00:55:32,596 --> 00:55:35,897
这是因为这里的图像是可选的。

1041
00:55:35,966 --> 00:55:38,066
Cuz imageViews不必具有图像，

1042
00:55:38,135 --> 00:55:40,468
他们当时可能是空的。

1043
00:55:40,537 --> 00:55:43,471
现在我可以在这里解开，但我在想，

1044
00:55:43,540 --> 00:55:47,709
你知道吗？我希望我的UI能够显示没有图像

1045
00:55:47,778 --> 00:55:50,345
在某一点。这是完全合理的。所以

1046
00:55:50,414 --> 00:55:55,283
相反，我会更改这是可选的。所以这

1047
00:55:55,352 --> 00:55:58,987
image var是可选的，它可以是零。当我这样做的时候

1048
00:55:59,056 --> 00:56:02,090
想确保我可以说imageView.image = newValue，

1049
00:56:02,158 --> 00:56:05,727
如果newValue为零，那会不会工作？是的，是因为

1050
00:56:05,796 --> 00:56:09,898
我们知道这个imageView的图像本身是一个可选的。

1051
00:56:09,967 --> 00:56:12,434
此时imageView可能没有图像。

1052
00:56:12,503 --> 00:56:17,238
这是非常好的好的，大家好，明白

1053
00:56:17,307 --> 00:56:20,608
我在那里做了什么这只是一个代码组织的事情，

1054
00:56:20,677 --> 00:56:23,478
它只是让我不必，你知道，

1055
00:56:23,547 --> 00:56:26,414
调整这个适合其他地方的大小。还是要放

1056
00:56:26,483 --> 00:56:28,950
在我的代码的其他部分，没有任何意义。在这里

1057
00:56:29,019 --> 00:56:31,086
这是有道理的，因为我正在设置我的形象。

1058
00:56:31,154 --> 00:56:36,191
好的，我们现在把这个imageView放进去

1059
00:56:36,259 --> 00:56:40,662
我们在代码中的层次结构。我告诉过你我们要去做

1060
00:56:40,731 --> 00:56:43,832
我们的UI与代码。我们开始做吧。我们要说viewDidLoad是

1061
00:56:43,901 --> 00:56:46,501
这是一个好地方，因为我们知道

1062
00:56:46,570 --> 00:56:49,237
时间viewDidLoad发生，我们完全初始化。

1063
00:56:49,306 --> 00:56:51,005
我们所有的出口都设置好

1064
00:56:51,074 --> 00:56:53,709
我们已经准备好了，如果有人走向我们。

1065
00:56:53,777 --> 00:56:56,878
现在我们处于一个很好的状态，可以增加更多的东西

1066
00:56:56,947 --> 00:56:59,814
到我们的UI我会这样做，只是说看法，

1067
00:56:59,883 --> 00:57:02,951
记住View Controller中的特殊吧

1068
00:57:03,019 --> 00:57:08,022
顶级视图。 AddSubview我的imageView，

1069
00:57:08,091 --> 00:57:11,292
好的？所以我只是把它放在那里

1070
00:57:11,361 --> 00:57:16,498
它将为零零大小，或者如果有人设置了我的imageURL，

1071
00:57:16,567 --> 00:57:20,569
那么它可能的大小适合或任何。

1072
00:57:20,638 --> 00:57:23,772
好的，现在如果有人设置我的imageURL会怎么样？

1073
00:57:23,841 --> 00:57:27,042
我最好设置这个图像，好吗？我们知道一个好办法

1074
00:57:27,110 --> 00:57:30,445
那对吧？所以我们的财产观察员在这里对我们的模型

1075
00:57:30,514 --> 00:57:33,715
任何时候有人设置我们的模型。首先我要去

1076
00:57:33,784 --> 00:57:36,751
实际上清除了我所拥有的任何形象。然后我是

1077
00:57:36,820 --> 00:57:40,455
将图像放在另一种方法中。

1078
00:57:40,523 --> 00:57:44,392
请记住，这个imageURL可能是一个Internet URL

1079
00:57:44,461 --> 00:57:47,595
这可能是一个缓慢的互联网，这可能需要很长时间。

1080
00:57:47,664 --> 00:57:51,065
所以我要把它全部放在这个其他功能上，

1081
00:57:51,134 --> 00:57:53,368
私有函数，fetchImage。

1082
00:57:53,437 --> 00:57:56,338
而且它会拍摄图像。所以

1083
00:57:56,407 --> 00:57:59,040
我们如何从网址中获取图片，好吗？

1084
00:57:59,109 --> 00:58:01,442
这实际上很容易。

1085
00:58:01,511 --> 00:58:03,378
首先，我要确保我有一个提取的URL。

1086
00:58:03,447 --> 00:58:09,717
我会说，如果我可以让一个url等于我们的imageURL，

1087
00:58:09,786 --> 00:58:15,223
那是我们的模型，好吗？如果我可以让我的imageURL在那里，

1088
00:58:15,292 --> 00:58:18,627
那么我要让那个URL的内容，所以我是

1089
00:58:18,695 --> 00:58:22,063
要在互联网上出来，得到它的内容。

1090
00:58:22,132 --> 00:58:28,637
我会让这个数据相等（contentsOf：url）。

1091
00:58:28,705 --> 00:58:31,673
所以数据就是这个袋子，我告诉过你的事情

1092
00:58:31,741 --> 00:58:35,110
几个讲座之前。它有一个非常酷的初始化程序

1093
00:58:35,178 --> 00:58:38,513
这是加载你的袋子的任何东西在这个

1094
00:58:38,582 --> 00:58:43,484
互联网上的URL现在，这里有一个错误。和

1095
00:58:43,553 --> 00:58:46,688
错误是这个抛出，

1096
00:58:48,125 --> 00:58:51,059
因为该URL可能不指向某个东西，或者

1097
00:58:51,128 --> 00:58:55,530
它可能是一个格式不正确的URL，或者它可能是一些URL，

1098
00:58:55,599 --> 00:58:57,733
你知道，糟糕的数据或类似的东西。

1099
00:58:57,801 --> 00:59:02,070
所以，如果我在这里看这个错误，那就是抱怨

1100
00:59:02,138 --> 00:59:06,407
不变的但也是这个调用可以抛出，

1101
00:59:06,476 --> 00:59:08,276
但没有标记尝试(try)和

1102
00:59:08,345 --> 00:59:12,614
该错误不处理。现在这里有人问我

1103
00:59:12,683 --> 00:59:16,818
显示这个imageURL。我想我可以抓住那个错误

1104
00:59:16,887 --> 00:59:18,953
就像一个警戒说的，

1105
00:59:19,022 --> 00:59:23,524
这里是我无法显示您的图像的原因。

1106
00:59:23,593 --> 00:59:28,730
但是我只是试着用一个问号，

1107
00:59:28,799 --> 00:59:33,468
如果我不能得到它，那我就不会显示出来。哪个是

1108
00:59:33,536 --> 00:59:38,740
可能不是很好，但它对于演示来说足够好。

1109
00:59:38,809 --> 00:59:42,043
所以现在，一旦我在这里尝试问号，这是不

1110
00:59:42,111 --> 00:59:46,615
更长的类型数据。它会是什么类型的？

1111
00:59:48,852 --> 00:59:52,386
是的，这是可选的。看，这是一个可选的数据，因为如果它

1112
00:59:52,455 --> 00:59:55,990
扔，它可以回来零。好的，因为这样

1113
00:59:56,059 --> 01:00:00,762
可选的，我会说如果我可以让imageData等于

1114
01:00:00,831 --> 01:00:05,166
该URL的内容。然后，现在我可以创建

1115
01:00:05,235 --> 01:00:09,937
这个UIImage和肯定够我的形象是这样的

1116
01:00:10,006 --> 01:00:13,541
var在这里将等于UIImage。和形象，

1117
01:00:13,610 --> 01:00:16,811
我们都知道Image命名，但也有Image，

1118
01:00:16,880 --> 01:00:21,617
与imageData。所以如果你有实际的JPEG数据或

1119
01:00:21,685 --> 01:00:26,321
无论如何，你可以做出一个形象。

1120
01:00:26,390 --> 01:00:28,322
当然，当我在这里做图像= UIImage时，

1121
01:00:28,391 --> 01:00:30,358
它会下降到这个设定者。

1122
01:00:30,427 --> 01:00:33,728
它将在UIImageView中设置该图像。

1123
01:00:33,796 --> 01:00:36,597
我们作为一个子视图添加，然后它将大小

1124
01:00:36,666 --> 01:00:41,903
适合imageView并显示给我们，好吗？

1125
01:00:41,972 --> 01:00:44,005
好的，现在只有一个问题，

1126
01:00:44,074 --> 01:00:47,843
有一件事我不喜欢这个。好的，我们来做

1127
01:00:47,911 --> 01:00:50,245
另一件事也是。我要去这里查看DidLoad

1128
01:00:50,314 --> 01:00:53,748
让它做一个演示URL，所以我们可以看到。

1129
01:00:53,817 --> 01:00:57,085
我将自己的imageURL设置为等于和

1130
01:00:57,153 --> 01:01:00,655
我有这些演示URL。好的，这是一件小事

1131
01:01:00,724 --> 01:01:06,094
在这里复制在。这些演示URL有一个

1132
01:01:06,163 --> 01:01:09,063
例如，这里有一点斯坦福网址

1133
01:01:09,132 --> 01:01:12,467
还有一些我们下一次做的NASA。

1134
01:01:12,535 --> 01:01:16,571
但是我刚刚在这里使用这个斯坦福大学的网址。所以

1135
01:01:16,639 --> 01:01:22,844
我们的imageURL是DemoURL.stanford。

1136
01:01:22,912 --> 01:01:26,014
我不喜欢我们写这个代码的方式

1137
01:01:26,082 --> 01:01:29,817
虽然在viewDidLoad中，我设置我的imageURL

1138
01:01:29,886 --> 01:01:32,120
斯坦福大学。那会在这里上去

1139
01:01:32,188 --> 01:01:34,689
导致这个fetchImage立即发生。

1140
01:01:34,758 --> 01:01:38,993
哪个会在互联网上出来，抓住这个形象。

1141
01:01:39,062 --> 01:01:40,762
所以一旦viewDidLoad发生，

1142
01:01:40,831 --> 01:01:43,698
男人，我不在互联网上得到这个东西。和

1143
01:01:43,766 --> 01:01:47,568
这可能不是你想做的，为什么不会这样做

1144
01:01:47,637 --> 01:01:51,139
您。想象这个应该是可重用的MVC

1145
01:01:51,208 --> 01:01:57,645
一个标签栏，好的。标签栏中的所有MVC，

1146
01:01:57,714 --> 01:02:02,350
它们都是在viewDidLoaded之前创建的

1147
01:02:02,419 --> 01:02:06,721
他们中的任何一个被显示。所以，如果我有一个标签栏有五个

1148
01:02:06,790 --> 01:02:10,191
图像视图控制器在这里，他们都会关闭

1149
01:02:10,259 --> 01:02:13,361
互联网加载的东西。我可能不会点击任何一个

1150
01:02:13,430 --> 01:02:15,430
他们。而且我浪费了蜂窝数据

1151
01:02:15,499 --> 01:02:18,066
我的用户的计划，好的。

1152
01:02:18,134 --> 01:02:22,670
所以我真的只想在这个时候去抓取这个URL

1153
01:02:22,739 --> 01:02:26,775
视图控制器肯定会出现在屏幕上。所以

1154
01:02:26,843 --> 01:02:29,377
任何人都可以想到我会放在哪里，而不是在

1155
01:02:29,446 --> 01:02:34,649
viewDidLoad那里？不同的视图控制器生命周期

1156
01:02:34,717 --> 01:02:40,254
方法。 viewWillAppear怎么样？

1157
01:02:40,323 --> 01:02:45,092
Super.viewWillAppear。所以

1158
01:02:45,161 --> 01:02:48,096
我将在viewWillAppear中进行实际的抓取。

1159
01:02:48,164 --> 01:02:52,434
现在，我想做这个，不是吗？好的，还有一个问题

1160
01:02:52,503 --> 01:02:54,368
虽然。如果我已经在屏幕上和

1161
01:02:54,437 --> 01:02:58,173
有人设定我的形象？然后我不能在viewWillAppear这样做。

1162
01:02:58,241 --> 01:03:00,808
我必须马上做。所以我可以这样

1163
01:03:00,877 --> 01:03:03,745
真的只是想拖延来观看WillAppear

1164
01:03:03,814 --> 01:03:07,181
如果我不在屏幕上那么我会在这里做什么

1165
01:03:07,250 --> 01:03:11,486
我的imageURL在这里是我只是要检查和

1166
01:03:11,555 --> 01:03:16,792
看看我现在在屏幕上，如果我是，那么

1167
01:03:16,860 --> 01:03:22,730
我会说如果我的view.window不是零，

1168
01:03:22,799 --> 01:03:26,100
那么我马上就去抓取这个图像，好的。所以

1169
01:03:26,169 --> 01:03:29,004
查看，记住，这是最顶级的事情。

1170
01:03:29,072 --> 01:03:33,441
窗口是所有UI视图中的一个var

1171
01:03:33,509 --> 01:03:36,644
你是窗户，如果没有窗户，

1172
01:03:36,713 --> 01:03:39,614
这意味着你不在屏幕上。如果你有一个窗口，

1173
01:03:39,683 --> 01:03:43,151
你在屏幕上所以如果我的view.window不是零，

1174
01:03:43,219 --> 01:03:45,152
然后我在屏幕上我要去提取

1175
01:03:45,221 --> 01:03:48,056
否则我不会取。而不是在这里

1176
01:03:48,125 --> 01:03:53,595
viewWillAppear，我会说我的图像是否为零。所以

1177
01:03:53,663 --> 01:03:59,434
如果我还没有到目前为止的图像，那么去抓取它。所以

1178
01:03:59,503 --> 01:04:02,870
你会看到这两件事的结合如何

1179
01:04:02,939 --> 01:04:06,007
等待抓取它，直到出现视图。除非我是

1180
01:04:06,076 --> 01:04:09,911
已经在屏幕上，那么它将立即获取它。所以

1181
01:04:09,980 --> 01:04:11,246
这至少拖延了。

1182
01:04:11,314 --> 01:04:14,182
所以现在如果我在标签栏，当我点击标签，

1183
01:04:14,251 --> 01:04:17,351
viewWillAppear会发生，我会加载。和

1184
01:04:17,420 --> 01:04:19,954
如果我做了一些导致图像改变的事情，那就会

1185
01:04:20,023 --> 01:04:23,425
立即改变，我可以看到。如果我离开屏幕，

1186
01:04:23,493 --> 01:04:25,994
然后点击另一个标签，我的图像被更改，

1187
01:04:26,063 --> 01:04:27,762
它不会改变。当我点击它，

1188
01:04:27,831 --> 01:04:29,030
那么它会从互联网上得到它。

1189
01:04:29,099 --> 01:04:32,600
所以，我最大限度地减少数据计划的使用量

1190
01:04:32,669 --> 01:04:35,837
如果这个人去，做细胞。

1191
01:04:35,905 --> 01:04:38,206
好的，我想我们有一切我们需要的东西

1192
01:04:38,274 --> 01:04:42,209
做这个工作。我们来试试看，让我们去一个iPhone

1193
01:04:42,278 --> 01:04:48,883
希望我们的网络在这台笔记本电脑上工作。可以，然后呢，

1194
01:04:48,952 --> 01:04:53,321
它出现在这里，它没有显示。我们的图像在哪里？

1195
01:04:53,389 --> 01:04:56,524
我们没有任何图像。嗯，我想我看到了一些东西

1196
01:04:56,592 --> 01:05:01,763
控制台在这里。我们来看看这个说法。它说，

1197
01:05:01,832 --> 01:05:07,168
App Transport Security已经阻止了一个明文HTTP，

1198
01:05:07,236 --> 01:05:11,605
HM。这是不安全的，当然我们知道HTTP是不安全的，

1199
01:05:11,674 --> 01:05:14,942
HTTPS是安全的它说，临时例外可以

1200
01:05:15,011 --> 01:05:17,979
通过您的应用程序的Info.plist文件进行配置。幸运的是，

1201
01:05:18,047 --> 01:05:21,282
我没有将我的Info.plist移动​​到支持文件中，

1202
01:05:21,351 --> 01:05:23,885
我知道这会发生，显然。所以

1203
01:05:23,953 --> 01:05:25,052
这里发生了什么？

1204
01:05:25,121 --> 01:05:28,756
那么，如果您查看我们正在尝试加载的网址，

1205
01:05:28,825 --> 01:05:32,227
这个斯坦福大学的网址，这是一个不安全的HTTP网址。

1206
01:05:32,295 --> 01:05:35,163
默认情况下，iOS不允许您加载。

1207
01:05:35,232 --> 01:05:39,400
你必须说你愿意加载这些

1208
01:05:39,469 --> 01:05:42,670
不信任的网址，您可以使用此Info.plist进行。

1209
01:05:42,738 --> 01:05:47,008
那么什么是Info.plist？这只是一些列表

1210
01:05:47,077 --> 01:05:51,679
设置，一些配置。例如，它显示，将会

1211
01:05:51,747 --> 01:05:54,248
你以纵向模式运行吗？你会运行在左边的横向模式吗？

1212
01:05:54,317 --> 01:05:56,651
在风景右边？那些东西。

1213
01:05:56,719 --> 01:05:59,954
这是一个真正的运行时配置，你的应用程序

1214
01:06:00,023 --> 01:06:04,458
会运行。所以我们可以添加这个App Transport Security

1215
01:06:04,527 --> 01:06:07,494
我们需要在这里右键点击，好的，

1216
01:06:07,563 --> 01:06:10,398
我们右键点击。在这里要注意，你会需要

1217
01:06:10,466 --> 01:06:13,801
这可能在一个，也许在未来的功课。但

1218
01:06:13,870 --> 01:06:16,404
我们要右键单击并选择添加行。

1219
01:06:16,472 --> 01:06:19,273
所以这会增加一行。糟糕，我们不想添加

1220
01:06:19,342 --> 01:06:22,710
一排在那里，对不起。这给我们的支持界面添加了一行

1221
01:06:22,779 --> 01:06:23,811
组态。 >>所以

1222
01:06:23,880 --> 01:06:27,715
我们不会选择，而是添加行。和

1223
01:06:27,784 --> 01:06:30,684
如果你去添加行，就在App的顶部附近

1224
01:06:30,753 --> 01:06:33,488
运输安全设置。你看到它在那里？所以

1225
01:06:33,556 --> 01:06:37,492
我会点击那个，然后我打开安全

1226
01:06:37,560 --> 01:06:40,595
设置。不要忘了打开这些设置

1227
01:06:40,663 --> 01:06:43,398
然后点击加上将添加一个安全设置和

1228
01:06:43,466 --> 01:06:45,433
在这里你可以看到选项。和

1229
01:06:45,502 --> 01:06:48,302
我们想要允许任意加载的那个。

1230
01:06:48,371 --> 01:06:52,073
我们会允许加载任何HTTP网址，我们将会继续

1231
01:06:52,141 --> 01:06:56,478
这里说的是的。所以允许任意加载，

1232
01:06:56,546 --> 01:06:59,680
是的，好吗？所以我们只是把它添加到我们的Info.plist中，

1233
01:06:59,749 --> 01:07:03,250
现在当我们运行我们的应用程序时，我们已经授权了，

1234
01:07:03,319 --> 01:07:09,023
以使应用程序加载这些http非S URL。

1235
01:07:09,092 --> 01:07:10,658
好吧，我们去，看看，哇哦！

1236
01:07:10,727 --> 01:07:13,661
我们得到斯坦福大学，我们甚至可以旋转。

1237
01:07:13,729 --> 01:07:17,531
好，现在当然我们看不到这里的整体形象

1238
01:07:17,600 --> 01:07:20,468
我们无法放大，可以放大很高兴。

1239
01:07:20,536 --> 01:07:24,038
为此，我们显然需要一个滚动视图。所以

1240
01:07:24,107 --> 01:07:27,141
我们怎么把滚动视图放在这里？好，

1241
01:07:27,210 --> 01:07:30,745
这是一个很好的机会，为您显示混合代码

1242
01:07:30,814 --> 01:07:35,382
在代码中执行您的观点，并在故事板中进行。

1243
01:07:35,451 --> 01:07:38,753
所以我要把我的滚动视图放在故事板里，

1244
01:07:38,822 --> 01:07:41,722
我们将以代码离开图像视图。好的，所以你看到他们

1245
01:07:41,791 --> 01:07:44,825
都在一起工作所以把滚动视图放在这里

1246
01:07:44,894 --> 01:07:47,194
我的故事板，我要搜索

1247
01:07:47,263 --> 01:07:50,365
在实用程序窗口中滚动查看此处。

1248
01:07:50,433 --> 01:07:53,234
我会拖出一个滚动视图，在这里。

1249
01:07:53,303 --> 01:07:57,171
我会用蓝线把它放在整体上，

1250
01:07:57,240 --> 01:08:01,943
填补我的整体，MVC在这里，没有任何边界。

1251
01:08:02,011 --> 01:08:04,579
然后我会用这个小的重设来建议

1252
01:08:04,648 --> 01:08:06,480
约束，你还记得吗？

1253
01:08:06,549 --> 01:08:09,517
让它为我做自动布局。

1254
01:08:09,586 --> 01:08:12,620
然后我实际上要去大小检查员，

1255
01:08:12,688 --> 01:08:16,057
在这里，点击它来仔细检查它做了什么，

1256
01:08:16,126 --> 01:08:18,526
在限制方面。当然，

1257
01:08:18,595 --> 01:08:21,429
这完全是我想要的限制，好吗？

1258
01:08:21,497 --> 01:08:24,265
所以我们有这个。我们想谈谈滚动视图，

1259
01:08:24,334 --> 01:08:27,768
当然，我们需要一个插座。所以，让我们得到我们的

1260
01:08:27,837 --> 01:08:32,940
控制器在屏幕上同时在这里，让我们

1261
01:08:33,009 --> 01:08:36,978
控制拖动我会把它放在这里滚动视图

1262
01:08:37,047 --> 01:08:40,147
图像视图。所以我们来控制我们的拖动

1263
01:08:40,216 --> 01:08:43,317
代码就在那里这是一个outlet，滚动视图，

1264
01:08:43,386 --> 01:08:45,920
注意它很弱。我们谈论了为什么我们的

1265
01:08:45,988 --> 01:08:49,790
outlet 是weak的我会调用给这个outlet scrollView。

1266
01:08:49,859 --> 01:08:53,261
Cuz这是什么Var scrollView就在那里。现在，

1267
01:08:53,329 --> 01:08:58,399
我想将图像视图整合到滚动视图中，

1268
01:08:58,468 --> 01:09:03,304
所以我只是去，当滚动视图设置，

1269
01:09:03,372 --> 01:09:07,942
我只是将该图像视图添加为子视图。

1270
01:09:09,946 --> 01:09:12,546
好的，现在我不需要在viewDidLoad中这样做。

1271
01:09:12,615 --> 01:09:15,183
viewDidLoad在哪里？好的，不需要添加

1272
01:09:15,252 --> 01:09:17,084
图像视图作为我们顶部的子视图

1273
01:09:17,153 --> 01:09:19,821
因为现在我把它添加为子视图

1274
01:09:19,889 --> 01:09:22,523
滚动视图，好吗？合理？所以，

1275
01:09:22,592 --> 01:09:24,592
让我们来看看是否有效。这应该是正常的。

1276
01:09:24,660 --> 01:09:29,964
是的，这很好。你们都应该考虑，

1277
01:09:30,033 --> 01:09:32,767
嗯，为什么不会这样工作？我会问你为什么不这样

1278
01:09:32,836 --> 01:09:35,570
在一秒钟内工作好的，这里是！它看起来

1279
01:09:35,638 --> 01:09:39,507
喜欢它的工作。我们滚动，我们不能滚动。为什么？

1280
01:09:39,575 --> 01:09:42,143
我知道我在那里放了一个卷轴视图。卷轴怎么样

1281
01:09:42,212 --> 01:09:46,814
视图不滚动？任何人都有想法？好的，

1282
01:09:46,882 --> 01:09:48,816
他在说这两个变量，

1283
01:09:48,885 --> 01:09:50,517
放大的东西。那是真的

1284
01:09:50,586 --> 01:09:53,754
这就是为什么它不会放大，但它甚至不会泛。

1285
01:09:53,823 --> 01:09:56,791
为甚么不能平息，更不用说缩放？

1286
01:09:56,859 --> 01:09:57,357
>>内容大小

1287
01:09:57,426 --> 01:09:58,625
>>内容大小，确切。

1288
01:09:58,694 --> 01:10:00,260
我们没有设置内容大小。

1289
01:10:00,329 --> 01:10:03,497
所以，这个滚动视图实际上是围绕内容进行平移

1290
01:10:03,566 --> 01:10:08,503
大小，只是内容大小是零。所以，

1291
01:10:08,571 --> 01:10:10,004
当你正在盘旋时，

1292
01:10:10,072 --> 01:10:12,573
这就像你甚至没有超过零，零点和

1293
01:10:12,642 --> 01:10:15,410
这是不可能的。所以，我们想要的内容大小

1294
01:10:15,478 --> 01:10:18,246
在这里整理这个整体的图像

1295
01:10:18,314 --> 01:10:21,115
我们可以一起玩，所以让我们这样做。

1296
01:10:21,184 --> 01:10:24,418
现在，我们要在哪里设置我们的内容大小？

1297
01:10:24,487 --> 01:10:27,621
实际上我们想做两次。

1298
01:10:27,690 --> 01:10:30,191
当我们的滚动视图首先在这里挂钩时，

1299
01:10:30,260 --> 01:10:32,526
我们将要设置我们的内容大小。

1300
01:10:32,595 --> 01:10:35,997
所以我要说contentSize这里等于和

1301
01:10:36,065 --> 01:10:39,600
我们的内容是什么也是平等的？好，

1302
01:10:39,669 --> 01:10:43,471
这是我们的图像视图的框架大小，好吗？

1303
01:10:43,540 --> 01:10:46,340
我们想把我们整个图像视图包围起来。

1304
01:10:46,409 --> 01:10:48,643
所以，无论我们的imageView的大小如何，

1305
01:10:48,711 --> 01:10:51,645
这就是我们的scrollView的内容大小。

1306
01:10:51,714 --> 01:10:54,882
但是还有一次我们要发送内容

1307
01:10:54,950 --> 01:10:57,351
大小，如果我们的图像发生变化，对吧？

1308
01:10:57,420 --> 01:10:59,520
如果你把新的形象放在那里，那我们就有了

1309
01:10:59,588 --> 01:11:01,288
调整我们的内容大小进行更改。

1310
01:11:01,357 --> 01:11:04,291
幸运的是，我们在这里有这么漂亮的变形，

1311
01:11:04,360 --> 01:11:07,161
所以每当我们设定我们的形象，我们都可以做的事情。

1312
01:11:07,230 --> 01:11:10,364
当然，在这里，我只是说，

1313
01:11:10,432 --> 01:11:14,469
scrollView.contentsize等于imageView.frame.size。

1314
01:11:14,537 --> 01:11:18,239
现在，这可能看起来不错。但实际上这是非常糟糕的。

1315
01:11:18,307 --> 01:11:22,210
原因是这样的。如果我们在形象

1316
01:11:22,278 --> 01:11:25,746
查看控制器，我们正在准备好。

1317
01:11:25,815 --> 01:11:28,483
有人会设置我们的图像网址。

1318
01:11:28,551 --> 01:11:31,819
这就是他们将如何准备我们的权利？所以

1319
01:11:31,888 --> 01:11:35,622
让我们来看看会做什么所以imageURL要去

1320
01:11:35,691 --> 01:11:41,996
将图像设置为零，在此处。设置此图像，

1321
01:11:42,064 --> 01:11:45,165
为零，它将尝试执行这一行代码，

1322
01:11:45,234 --> 01:11:50,771
那就是崩溃了。因为当我们准备的时候，

1323
01:11:50,839 --> 01:11:55,943
我们的网点没有设置，所以这是零。这样的方式

1324
01:11:56,012 --> 01:11:59,113
那？问号。这个可选链。如果没有，

1325
01:11:59,182 --> 01:12:01,082
我不会设置scrollView的contentSize，

1326
01:12:01,151 --> 01:12:03,885
但是以后可以这么说，我会来的

1327
01:12:03,953 --> 01:12:06,787
当插座连接起来时，这样做。所以，

1328
01:12:06,855 --> 01:12:09,690
这只是提醒你，任何时候你访问

1329
01:12:09,759 --> 01:12:13,561
准备过程中可能会调用的插座和方法，你

1330
01:12:13,629 --> 01:12:18,599
需要选择链接他们，好吗？所以它不会崩溃

1331
01:12:18,667 --> 01:12:22,169
你的应用在准备期间。好的，让我们继续吧

1332
01:12:22,237 --> 01:12:24,939
看看是否修复了一切，在这里设置我们的内容大小。

1333
01:12:26,809 --> 01:12:32,379
应该很好去好吧，

1334
01:12:32,448 --> 01:12:37,318
这是我们的形象，看看，滚动很好，旋转，

1335
01:12:37,386 --> 01:12:42,190
好的，滚动好的，注意它有点儿这个

1336
01:12:42,258 --> 01:12:45,092
你滚动的东西太多，它反弹。

1337
01:12:45,160 --> 01:12:48,529
你可以控制，顺便说一下，和scrollView的其中之一

1338
01:12:48,598 --> 01:12:51,765
它的设置好吗？糟糕，旋转错误，好的，

1339
01:12:51,834 --> 01:12:55,670
我们得到了它？现在，现在我们想放大，我们想

1340
01:12:55,738 --> 01:12:58,238
看看我们能不能在这里找到自己。

1341
01:12:58,307 --> 01:13:00,541
也许这是我们中的一个。我们要放大

1342
01:13:00,610 --> 01:13:04,545
看到。但是对于缩放，正如他在上面说的，

1343
01:13:04,614 --> 01:13:07,881
我们需要确保我们设置最小和最大值

1344
01:13:07,950 --> 01:13:10,551
缩放比例。 Cuz实际上是最小和最大

1345
01:13:10,620 --> 01:13:13,955
缩放倍数现在设置为1.0。所以

1346
01:13:14,023 --> 01:13:18,526
这是最小和最大，这意味着没有滚动。好吧，

1347
01:13:18,594 --> 01:13:21,128
所以我们来设定一下。可能是一个很好的地方

1348
01:13:21,197 --> 01:13:24,197
当我们的滚动视图首先连接起来作为outlet。

1349
01:13:24,266 --> 01:13:26,734
所以我们在这里做这个，我们会说，

1350
01:13:26,802 --> 01:13:30,872
scrollView.minimumZoomScale。我们走得很小，

1351
01:13:30,940 --> 01:13:34,942
怎么回合0.03，还好，3％的大小会去，

1352
01:13:35,011 --> 01:13:38,111
让我们的形象真的很小。

1353
01:13:38,180 --> 01:13:41,415
最大限度地，只是为了显示你的差异，我们会做出

1354
01:13:41,483 --> 01:13:44,819
只有这样，我们只能是两倍大。或者，我们甚至可以

1355
01:13:44,887 --> 01:13:47,487
使它不能更大，对吧？ 1.0会是，

1356
01:13:47,556 --> 01:13:49,090
它永远不会比它更大。

1357
01:13:49,158 --> 01:13:51,258
它可以更小，但不是更大。我们可能会想，

1358
01:13:51,327 --> 01:13:54,261
因为如果允许比自然尺寸更大，

1359
01:13:54,330 --> 01:13:55,763
它会开始获得pixellated和

1360
01:13:55,831 --> 01:13:59,232
我们不想要。但只是这样你可以看到它发生。

1361
01:13:59,301 --> 01:14:04,438
另外我们需要做些缩放工作呢？没有

1362
01:14:04,507 --> 01:14:09,677
有人记得吗我们需要代表团是，

1363
01:14:09,745 --> 01:14:12,746
滚动视图需要知道哪个子视图

1364
01:14:12,815 --> 01:14:15,582
你想要改变变化。和

1365
01:14:15,651 --> 01:14:18,118
它是通过要求你委派的。所以现在我们要去

1366
01:14:18,187 --> 01:14:20,788
在这里看到行动的代表。

1367
01:14:20,857 --> 01:14:25,526
所以要做一个委托工作，你需要设置代表

1368
01:14:25,594 --> 01:14:27,795
成为你自己所以我需要说，

1369
01:14:27,864 --> 01:14:32,966
scrollView.delegate = self。现在这是不合法的，

1370
01:14:33,035 --> 01:14:37,171
这将导致错误。希望你

1371
01:14:37,239 --> 01:14:39,807
可以看看为什么，我们会看看错误，它说，

1372
01:14:39,875 --> 01:14:43,110
您不能分配ImageViewController类型的值，

1373
01:14:43,178 --> 01:14:47,614
这是什么是自己的，类型为UIScrollViewDelegate

1374
01:14:47,683 --> 01:14:50,284
可选的。所以我告诉你，ScrollViewDelegate是

1375
01:14:50,353 --> 01:14:53,454
一个可选的UIScrollViewDelegate协议，

1376
01:14:53,523 --> 01:14:55,155
这就是它是什么。而且当然，

1377
01:14:55,224 --> 01:14:57,992
自己不是，即使它不采用任何方法和

1378
01:14:58,061 --> 01:15:00,060
该协议只有可选的方法。

1379
01:15:00,129 --> 01:15:03,130
因为需要上这边说是的，

1380
01:15:03,198 --> 01:15:08,836
我是UIScrollViewDelegate。好的，所以这是这个类，

1381
01:15:08,904 --> 01:15:12,406
UIViewController，说我符合这个协议，和

1382
01:15:12,474 --> 01:15:13,607
一旦我这样做，

1383
01:15:13,676 --> 01:15:16,544
错误消失，没有错误。甚至

1384
01:15:16,612 --> 01:15:19,146
虽然我没有做任何事情，但我并没有实际执行

1385
01:15:19,215 --> 01:15:21,682
UIScrollView委托协议，这是因为所有

1386
01:15:21,751 --> 01:15:24,952
UIScrollView委托中的方法是可选的。所以

1387
01:15:25,021 --> 01:15:26,987
我没有实现任何，但它们都是可选的。

1388
01:15:27,056 --> 01:15:30,224
所以我已经遵守了协议。但是当然，

1389
01:15:30,292 --> 01:15:31,992
这不是我们帮助我们缩放，因为我们在

1390
01:15:32,061 --> 01:15:35,996
事实上确实需要实现一个方法。现在我要出现

1391
01:15:36,065 --> 01:15:39,166
你是一个很酷的方法来做这个扩展。我要补充

1392
01:15:39,234 --> 01:15:42,903
协议符合我的ImageViewController与

1393
01:15:42,972 --> 01:15:46,139
一个扩展。我会这样做的。

1394
01:15:46,208 --> 01:15:49,209
所以我要做它，使它不符合，好的，

1395
01:15:49,278 --> 01:15:51,511
ImageViewController不一致。

1396
01:15:51,580 --> 01:15:55,883
但我会在这里添加一个扩展名，在我的底部

1397
01:15:55,951 --> 01:16:00,153
文件，它是ImageViewController的扩展，

1398
01:16:00,222 --> 01:16:04,858
这将导致ImageViewController符合

1399
01:16:04,927 --> 01:16:09,096
到UIScrollViewDelegate协议。好的，所以只是

1400
01:16:09,165 --> 01:16:13,434
把这个放在这里，这个错误在这里会消失。

1401
01:16:13,503 --> 01:16:16,404
因为我添加了一个扩展名，这导致了这个，

1402
01:16:16,472 --> 01:16:19,172
这个类在这里符合这个协议。

1403
01:16:19,241 --> 01:16:20,974
同样，所有的方法都是可选的

1404
01:16:21,043 --> 01:16:23,577
通常我们必须在这里放一堆方法。

1405
01:16:23,646 --> 01:16:26,346
但我会把我们想要的一种方法放在这里，

1406
01:16:26,415 --> 01:16:31,518
这是scrollView中的viewForZooming。

1407
01:16:31,587 --> 01:16:34,988
现在有趣的是，注意，当我开始输入这个，

1408
01:16:35,057 --> 01:16:38,359
它实际上知道我是一个UIScrollViewDelegate，所以

1409
01:16:38,428 --> 01:16:40,694
它为我提供了这种方法作为选择，所以

1410
01:16:40,763 --> 01:16:43,797
我会双击它。这是我的视图

1411
01:16:43,866 --> 01:16:47,100
滚动视图。我只需要返回我想要的视图

1412
01:16:47,169 --> 01:16:49,269
放大我们当然，这是图像视图。

1413
01:16:49,338 --> 01:16:52,572
所以我只想说返回imageView，但是

1414
01:16:52,641 --> 01:16:58,511
那不行。你为什么觉得不行？

1415
01:16:58,580 --> 01:17:04,751
这个imageView是私有的。

1416
01:17:04,820 --> 01:17:09,323
现在，我可以把它隐藏起来，但是

1417
01:17:09,392 --> 01:17:12,326
现在每个人都可以看到图像视图，和

1418
01:17:12,394 --> 01:17:15,729
那有点太私人了所以还有另一种

1419
01:17:15,798 --> 01:17:20,968
私有名为fileprivate，什么文件私有的意思是，

1420
01:17:21,037 --> 01:17:25,205
这个文件中的所有人都是私人的。所以

1421
01:17:25,274 --> 01:17:29,276
这允许这个扩展看到这个图像视图。和

1422
01:17:29,345 --> 01:17:30,577
其他人仍然是私人的。

1423
01:17:30,646 --> 01:17:33,180
所以大家使用我的MVC谁看到这个，其他文件，

1424
01:17:33,249 --> 01:17:36,750
它仍然是私人的，他们看不到它。但这个家伙可以使用

1425
01:17:36,819 --> 01:17:38,885
好吗？所以这是一种不同的私人，

1426
01:17:38,954 --> 01:17:42,756
fileprivate。好的，所以我们得到了放大的视图。

1427
01:17:42,825 --> 01:17:44,959
事实上，这是我们想要放大的视图。

1428
01:17:45,028 --> 01:17:46,360
所以让我们继续看看这里。

1429
01:17:53,969 --> 01:17:56,569
好的，这里是。我们还可以滚动，和

1430
01:17:56,638 --> 01:17:59,506
如果我们按住选项键并将我们的两个手指放在这里，

1431
01:17:59,575 --> 01:18:03,477
我们也可以放大。好的，和

1432
01:18:03,546 --> 01:18:06,379
我们可以放大很小，我们可以缩小。

1433
01:18:06,448 --> 01:18:09,616
但请注意，它不会让我放大任何比

1434
01:18:09,685 --> 01:18:13,154
因为我设置为我的最大缩放比例。

1435
01:18:14,957 --> 01:18:18,625
好的，所以，我要做的最后一件事，好吧，我会离开

1436
01:18:18,694 --> 01:18:21,661
这是cuz我要发布这样的代码，和

1437
01:18:21,730 --> 01:18:25,332
你可以玩弄它。下一次，我要去什么

1438
01:18:25,400 --> 01:18:28,835
做的是添加另一个MVC，让我们选择一些NASA图像，

1439
01:18:28,904 --> 01:18:32,273
你可以看到任何NASA图像。有一件事我们会发现

1440
01:18:32,341 --> 01:18:35,442
关于这个图像，它们是巨大的，甚至在我们的斯坦福大学

1441
01:18:35,511 --> 01:18:38,745
网络，他们需要很长时间才能下载。那就是

1442
01:18:38,814 --> 01:18:41,614
烦人，所以我们要使用多线程

1443
01:18:41,683 --> 01:18:43,083
为了保持我们的UI响应，

1444
01:18:43,152 --> 01:18:45,819
即使这是非常昂贵的事情，

1445
01:18:45,888 --> 01:18:49,256
这是下载这个巨大的文件，好吗？所以，

1446
01:18:49,325 --> 01:18:51,591
我会再见到你的>>为

1447
01:18:51,660 --> 01:19:01,067
更多，请访问我们在stanford.edu。


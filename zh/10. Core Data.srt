1
00:00:00,401 --> 00:00:04,535
[MUSIC]

2
00:00:04,604 --> 00:00:07,838
斯坦福大学

3
00:00:07,907 --> 00:00:11,109
>> 欢迎来到斯坦福CS193P，

4
00:00:11,177 --> 00:00:16,980
这是开发iOS应用程序，2017年冬天。

5
00:00:17,049 --> 00:00:19,983
而今天唯一的主题就是一个大的核心数据(Core Data)，

6
00:00:20,052 --> 00:00:23,019
它是面向对象的数据库。

7
00:00:23,088 --> 00:00:24,821
但在我深入了解之前，

8
00:00:24,889 --> 00:00:28,324
我实际上要重新考察我们上次做的演示

9
00:00:28,393 --> 00:00:31,260
只是短暂的，因为我们用完了，所以

10
00:00:31,329 --> 00:00:34,262
我无法显示刷新控件。

11
00:00:34,331 --> 00:00:35,797
现在我发布了代码，所以

12
00:00:35,866 --> 00:00:38,066
我不会在这里输入所有代码。

13
00:00:38,134 --> 00:00:40,701
但我只是简要地告诉你

14
00:00:40,770 --> 00:00:43,270
怎么刷新控制工作，好吗？

15
00:00:43,339 --> 00:00:45,171
好的，所以我们错过了。

16
00:00:45,240 --> 00:00:47,907
所以这里是我们上次使用的应用程序。

17
00:00:47,976 --> 00:00:50,977
顺便说一下，我修改了我们的应用程序

18
00:00:51,046 --> 00:00:53,045
这里要改变我们的要求一点。

19
00:00:53,113 --> 00:00:55,347
如果你记得上次这行代码，

20
00:00:55,416 --> 00:00:56,815
它曾经只有查询。

21
00:00:56,884 --> 00:01:00,718
但是我已经改变了它，也过滤掉转发

22
00:01:00,787 --> 00:01:04,188
我也戴上了安全的过滤器，希望能够

23
00:01:04,257 --> 00:01:06,624
做到这一点，当我做这些查找，

24
00:01:06,692 --> 00:01:10,227
这些看起来，我们没有在屏幕上得到东西，

25
00:01:10,296 --> 00:01:12,129
你知道这是一个家庭表演，

26
00:01:12,197 --> 00:01:15,331
所以我们不想看到一些东西。

27
00:01:15,400 --> 00:01:17,666
无论如何，希望这将工作。

28
00:01:17,735 --> 00:01:19,735
所以让我们回到这里

29
00:01:19,804 --> 00:01:22,571
看看这是什么样子。

30
00:01:22,640 --> 00:01:24,272
我的模拟器在这里

31
00:01:24,341 --> 00:01:25,273
所以我们继续搜索。

32
00:01:25,341 --> 00:01:29,710
让我们再试一次Trump，穿过我们的手指，好吧。

33
00:01:29,779 --> 00:01:34,949
所以不是，我看不到什么太可怕了。

34
00:01:35,017 --> 00:01:38,752
好的，所以我们添加的是这个UI，我们可以把它拉下来。

35
00:01:38,821 --> 00:01:40,153
好的，它增加了更多的推文，

36
00:01:40,221 --> 00:01:41,888
你看到它在那里添加了一个推文吗？

37
00:01:41,957 --> 00:01:43,589
我们有第二拉，

38
00:01:43,658 --> 00:01:44,724
这是第一次拉。

39
00:01:44,792 --> 00:01:49,895
我们再次拉下来，这次没有tweets，好吗？

40
00:01:49,964 --> 00:01:52,431
所以每次我们拉下去做另一个推特

41
00:01:52,499 --> 00:01:53,497
抓取和

42
00:01:53,566 --> 00:01:57,268
可能会得到更多的推文，这取决于人们是否有tweeting。

43
00:01:57,337 --> 00:01:59,503
所以让我们来看一下这个代码，再次，

44
00:01:59,572 --> 00:02:01,004
我发贴了这段代码，但是

45
00:02:01,073 --> 00:02:02,539
我们只是看看，我不会把它全部输入，

46
00:02:02,608 --> 00:02:04,207
我们要快速看看它。

47
00:02:04,275 --> 00:02:07,042
首先，让我们来谈一谈如何把这个UI放在哪里

48
00:02:07,111 --> 00:02:11,280
我们拉下来，它叫一个方法，还是什么？

49
00:02:11,349 --> 00:02:14,150
所以我们来看看我们的故事板。

50
00:02:16,854 --> 00:02:19,787
好的，所以这里是我们的故事板，和

51
00:02:19,856 --> 00:02:23,691
我做的是我刚刚选择了我的表视图控制器

52
00:02:23,760 --> 00:02:26,193
我下了这个令人耳目一新的

53
00:02:26,262 --> 00:02:27,360
你看到这个清爽的选择？

54
00:02:27,429 --> 00:02:30,864
而且我将其从禁用更改为启用，当我设置它

55
00:02:30,933 --> 00:02:33,466
在UI中启用了任何更改。

56
00:02:33,535 --> 00:02:36,436
你看不到任何旋转的东西，但是

57
00:02:36,504 --> 00:02:40,072
在这里的文件大纲中，它创建了这个

58
00:02:40,141 --> 00:02:42,340
刷新控制权在这里。

59
00:02:42,409 --> 00:02:45,977
所以我可以像我一样从文档大纲控制拖动

60
00:02:46,046 --> 00:02:47,145
可以通过这里。

61
00:02:47,214 --> 00:02:49,680
所以我做这个工作，是我刚刚提出来的

62
00:02:49,749 --> 00:02:52,082
我的控制器在这里

63
00:02:52,151 --> 00:02:53,784
这里是我在这里做的方法。

64
00:02:53,853 --> 00:02:58,188
我刚从Ctrl拖动到刷新控件到这个方法

65
00:02:58,256 --> 00:03:00,590
叫刷新，好吗？

66
00:03:00,659 --> 00:03:04,360
这就是我所做的，做到这一点。

67
00:03:04,429 --> 00:03:05,627
而在内部刷新，

68
00:03:05,696 --> 00:03:08,363
我刚才打了这个我以前一样的方法，searchForTweets。

69
00:03:08,432 --> 00:03:10,698
这一个在这里，搜索推文。

70
00:03:10,767 --> 00:03:12,533
而且以前看起来像这样，

71
00:03:12,602 --> 00:03:14,368
我只是在这里改变了一件事。

72
00:03:14,437 --> 00:03:17,805
它以前只是得到twitterRequest

73
00:03:17,873 --> 00:03:19,873
在这里查看我们的搜索字词。

74
00:03:19,942 --> 00:03:21,475
记住这个功能吗？

75
00:03:21,543 --> 00:03:25,144
我所做的就是加了这个，说如果

76
00:03:25,213 --> 00:03:29,849
lastTwitterRequest有一个较新的版本，然后使用它。

77
00:03:29,918 --> 00:03:33,319
但是如果没有，那么默认回去做查询

78
00:03:33,388 --> 00:03:35,053
请求我们过去的方式。

79
00:03:35,122 --> 00:03:37,355
我唯一需要做的其他事情就是刷新

80
00:03:37,424 --> 00:03:39,524
控制，你做到这一点，结束刷新。

81
00:03:39,593 --> 00:03:42,159
所以我刚刚做到这一点，当我回到这里的主要队列，

82
00:03:42,228 --> 00:03:44,328
得到我的结果，所以我把它关闭了。

83
00:03:44,397 --> 00:03:45,562
我也把它关了

84
00:03:45,631 --> 00:03:48,265
某些原因我无法得到任何请求或任何。

85
00:03:48,333 --> 00:03:50,634
好的，搜索字词中没有任何内容

86
00:03:50,702 --> 00:03:53,002
我无法获得我最后一个请求的较新版本。

87
00:03:53,071 --> 00:03:55,771
所以我刚才说，我会确定那件事不是

88
00:03:55,840 --> 00:03:57,940
旋转和旋转永远。

89
00:03:58,009 --> 00:03:59,374
他们想离开这里。

90
00:03:59,443 --> 00:04:02,110
而我唯一要做的就是在这里，

91
00:04:02,178 --> 00:04:05,813
当搜索文本发生变化时，有人会输入＃斯坦福或

92
00:04:05,882 --> 00:04:09,250
像这样，我需要使最后一个Twitter无效

93
00:04:09,318 --> 00:04:12,152
请求，所以它不是试图获得新的版本

94
00:04:12,221 --> 00:04:13,920
我以前的一个。

95
00:04:13,989 --> 00:04:16,589
我想要做新的。

96
00:04:16,658 --> 00:04:20,226
和我做的这样我们有这么少的方式

97
00:04:20,295 --> 00:04:24,296
标题在这里，看这些标题二，三，四，五？

98
00:04:24,365 --> 00:04:27,132
我实现了另一个UI表视图数据源方法，

99
00:04:27,201 --> 00:04:28,900
这一个在这里。

100
00:04:28,969 --> 00:04:31,203
称为TitleForHeaderInSection。

101
00:04:31,271 --> 00:04:33,437
我只是把部分标题。

102
00:04:33,506 --> 00:04:36,974
记住，每个部分是Twitter的另一个拉力。

103
00:04:37,043 --> 00:04:38,642
所以我只有每个标题。

104
00:04:38,711 --> 00:04:41,377
它实际上将是我已经减去的事情的数量

105
00:04:41,446 --> 00:04:42,312
部分号。

106
00:04:42,381 --> 00:04:44,146
所以顶部是零。

107
00:04:44,215 --> 00:04:45,814
所以零零点会显示

108
00:04:45,883 --> 00:04:47,115
我做的拉的数量。

109
00:04:47,184 --> 00:04:48,516
tweets.count是我做了多少拉。

110
00:04:48,585 --> 00:04:50,151
而且显然会是这样

111
00:04:50,219 --> 00:04:51,853
部分下降时减少。

112
00:04:54,123 --> 00:04:57,391
好的，这就是给我们这个。

113
00:04:57,460 --> 00:04:58,892
你可以看到我们等待的时间越长，

114
00:04:58,961 --> 00:05:01,661
显然它会提供更多的信息，

115
00:05:01,730 --> 00:05:02,829
作为tweets堆积。

116
00:05:04,331 --> 00:05:08,334
好的，让我们回到我们的幻灯片。

117
00:05:08,402 --> 00:05:10,202
好的，我们开始吧。

118
00:05:10,271 --> 00:05:13,871
所以Core Data是iOS内的这个大框架

119
00:05:13,940 --> 00:05:16,574
做面向对象的数据库。

120
00:05:16,643 --> 00:05:19,409
那么让我们谈谈一下这是什么意思。

121
00:05:19,478 --> 00:05:21,545
那么，什么时候需要数据库？

122
00:05:21,613 --> 00:05:23,814
当你有大量数据时，你需要一个数据库

123
00:05:23,882 --> 00:05:26,916
数据，特别是如果你想做一些查询

124
00:05:26,985 --> 00:05:30,153
进入该数据并查找有关该数据的信息

125
00:05:30,221 --> 00:05:32,654
所有事情之间的关系在那里。

126
00:05:32,723 --> 00:05:34,089
你真的不能这样做，

127
00:05:34,158 --> 00:05:36,558
拿一个大字典或一个大数组

128
00:05:36,627 --> 00:05:39,627
通过搜索，您需要一个数据库。

129
00:05:39,696 --> 00:05:42,797
所以有很多数据库的技术

130
00:05:42,866 --> 00:05:45,766
但是大部分都不是面向对象的。

131
00:05:45,835 --> 00:05:48,769
所以我们有这个框架，苹果提供调用

132
00:05:48,837 --> 00:05:51,705
核心数据，这就是我们所说的面向对象的数据库

133
00:05:51,774 --> 00:05:55,108
但实际上它并不是一个面向对象的数据库

134
00:05:55,177 --> 00:05:56,976
在里面

135
00:05:57,045 --> 00:05:59,411
它只是外部的一个面向对象的数据库。

136
00:05:59,480 --> 00:06:01,247
你看的那边。

137
00:06:01,315 --> 00:06:04,950
在下面，它实际上是一个关系数据库。

138
00:06:05,018 --> 00:06:08,987
现在，Core Data旨在具有任何后端存储。

139
00:06:09,055 --> 00:06:11,589
但是它的主要实现是在其上

140
00:06:11,657 --> 00:06:13,957
SQL是一个关系数据库。

141
00:06:14,026 --> 00:06:18,061
有多少人知道SQL数据库是什么？

142
00:06:18,130 --> 00:06:19,396
好的，几乎所有的人，这很好。

143
00:06:19,464 --> 00:06:25,268
所以，如果我们在使用SQL的iOS应用中做数据库，

144
00:06:25,336 --> 00:06:27,870
我们就像没有，我必须学习这个整个查询

145
00:06:27,939 --> 00:06:29,705
语言，我该怎么办？

146
00:06:29,774 --> 00:06:32,708
不用担心，我们不必知道任何使用核心数据的SQL。

147
00:06:32,776 --> 00:06:35,543
没有任何SQL  - 我们只会这样做

148
00:06:35,612 --> 00:06:38,280
在对象侧。

149
00:06:38,348 --> 00:06:39,380
因此，这是怎么工作的？

150
00:06:39,449 --> 00:06:40,380
核心数据如何工作？

151
00:06:40,449 --> 00:06:43,551
那么首先我们要创建一个可视化映射

152
00:06:43,619 --> 00:06:45,985
在我们的数据库中的东西之间

153
00:06:46,054 --> 00:06:48,688
一些我们将能够编程的对象

154
00:06:48,757 --> 00:06:51,791
在我们面向对象的代码中，我们喜欢。

155
00:06:51,860 --> 00:06:54,793
大概是这样的

156
00:06:54,862 --> 00:06:58,597
数据库中的表将会是对象。

157
00:06:58,666 --> 00:07:01,833
并且表中的列是一种var。

158
00:07:01,902 --> 00:07:04,069
但是我们甚至不在乎它在做什么。

159
00:07:04,137 --> 00:07:06,737
我们将要关注的是这个可视化地图，

160
00:07:06,806 --> 00:07:10,607
这个可视化描述基本上是我们的模式。

161
00:07:10,676 --> 00:07:12,509
好的，有多少人知道这个词是什么意思？

162
00:07:12,578 --> 00:07:15,812
好吧，所以三分之二的你。

163
00:07:15,881 --> 00:07:18,748
所以模式基本上是对什么的描述

164
00:07:18,816 --> 00:07:22,218
在你的数据库中，不是它的内容，而是它的全部

165
00:07:22,287 --> 00:07:24,687
数据类型是和它们如何相互关联等。

166
00:07:24,756 --> 00:07:27,923
所以我们会用图形来做所有的事情。

167
00:07:27,992 --> 00:07:30,325
这就是它的样子。

168
00:07:30,394 --> 00:07:33,428
首先，如果我想在我的应用程序中使用Core Data，

169
00:07:33,497 --> 00:07:37,498
我几乎肯定要点击这个按钮

170
00:07:37,567 --> 00:07:39,366
说使用核心数据。

171
00:07:39,435 --> 00:07:41,869
我们已经看到它每次创建一个应用程序，我们没有

172
00:07:41,938 --> 00:07:43,870
点击它到目前为止，但现在我们要点击它。

173
00:07:43,939 --> 00:07:45,872
并点击使用核心数据，

174
00:07:45,940 --> 00:07:48,875
将为我们创造两件事，这个可视化map，

175
00:07:48,943 --> 00:07:50,943
以及您的应用程序代理中的一些代码。

176
00:07:51,012 --> 00:07:52,878
我会谈谈这两件事情。

177
00:07:52,946 --> 00:07:54,112
现在我去下一张幻灯片之前，

178
00:07:54,181 --> 00:07:56,948
请注意，此应用程序的名称为CoreDataExample。

179
00:07:57,017 --> 00:07:59,317
那就是我在那里输入的应用程序的名称。

180
00:08:00,487 --> 00:08:03,386
所以当我创建这个应用程序，点击它

181
00:08:03,455 --> 00:08:06,790
使用核心数据，你会看到它创建了这个文件，

182
00:08:06,859 --> 00:08:10,260
CoreDataExample.xcdatamodeld。

183
00:08:10,329 --> 00:08:12,395
所以它选择了我的应用程序的名称。

184
00:08:12,463 --> 00:08:16,332
这将是我们的数据模型，好吗？

185
00:08:16,401 --> 00:08:18,433
所以我们来讨论AppDelegate

186
00:08:18,502 --> 00:08:21,570
使用核心数据的代码也稍后生成。

187
00:08:21,639 --> 00:08:25,473
现在我们将专注于这个数据模型文件。

188
00:08:25,542 --> 00:08:28,977
好的，但在我们甚至这样做之前，如果我们会发生什么

189
00:08:29,045 --> 00:08:32,413
有一个现有的应用程序，您没有单击使用核心数据？

190
00:08:32,482 --> 00:08:34,748
现在你决定了，嘿，我想添加核心数据。

191
00:08:34,817 --> 00:08:38,318
也许Smashtag作业5出来了

192
00:08:38,386 --> 00:08:40,953
我告诉你添加一些核心数据到Smashtag。

193
00:08:41,022 --> 00:08:42,789
而你就像，我不能回去

194
00:08:42,857 --> 00:08:44,690
点击使用核心数据，太晚了。

195
00:08:44,759 --> 00:08:47,726
所以你必须创建这个数据模型文件

196
00:08:47,794 --> 00:08:48,827
使用新文件。

197
00:08:48,896 --> 00:08:51,463
所以你只需去文件>新建>文件这样。

198
00:08:51,532 --> 00:08:52,830
你不会选择任何一个

199
00:08:52,899 --> 00:08:54,465
我们选择的东西到目前为止。

200
00:08:54,533 --> 00:08:56,600
你会向下滚动到那个部分

201
00:08:56,668 --> 00:08:57,401
Core Data说。

202
00:08:57,469 --> 00:08:59,669
而在那里，有两件事，

203
00:08:59,738 --> 00:09:01,137
数据模型和映射模型。

204
00:09:01,206 --> 00:09:04,406
并确保您选择数据模型，因为这是你的

205
00:09:04,475 --> 00:09:06,775
想在这里做的是创建你的数据模型，

206
00:09:06,844 --> 00:09:09,511
您的架构本质上是为您的数据库。

207
00:09:09,580 --> 00:09:11,179
它会问你想要的是什么。

208
00:09:11,247 --> 00:09:13,948
现在，您不必将其称为与名称相同的名称

209
00:09:14,017 --> 00:09:16,484
您的应用程序，如使用核心数据按钮。

210
00:09:16,552 --> 00:09:17,584
你可以叫任何你想要的东西。

211
00:09:17,653 --> 00:09:20,220
所以在这里，只是为了不同，我称之为模型，

212
00:09:20,289 --> 00:09:21,955
这是我的模型

213
00:09:22,023 --> 00:09:23,355
顺便说一下，

214
00:09:23,424 --> 00:09:27,994
你的核心数据通常是很多MVC的模型。

215
00:09:28,062 --> 00:09:31,429
好的，很多MVC，他们的工作将要展示

216
00:09:31,498 --> 00:09:35,167
数据库中的数据，所以这个数据模型实际上是这样的

217
00:09:35,236 --> 00:09:37,568
MVC模型以及许多MVC。

218
00:09:37,637 --> 00:09:39,737
所以我会把这个模型称为

219
00:09:39,806 --> 00:09:42,773
你可以看到它创建了model.xedatamodeld。

220
00:09:42,842 --> 00:09:46,477
所以无论你是通过使用核心数据或

221
00:09:46,545 --> 00:09:48,445
无论你通过创建它得到它，

222
00:09:48,514 --> 00:09:51,281
你会有这个映射文件。

223
00:09:51,350 --> 00:09:54,017
现在，让我回到AppDelegate的事情。

224
00:09:54,085 --> 00:09:56,819
我说他们会把你的AppDelegate中的一些代码。

225
00:09:56,888 --> 00:09:58,954
这是非常少量的代码。

226
00:09:59,023 --> 00:10:01,089
但我想在这里向你展示。

227
00:10:01,158 --> 00:10:02,891
这就是它的样子。

228
00:10:02,960 --> 00:10:05,794
它只是在这里创建一个var。

229
00:10:07,296 --> 00:10:10,130
顺便说一下，如果你没有使用核心数据，当然，

230
00:10:10,199 --> 00:10:12,198
你需要这个代码在你的AppDelegate，

231
00:10:12,267 --> 00:10:13,799
你怎么会得到它？

232
00:10:13,868 --> 00:10:16,669
只需去创建一些虚拟应用程序。

233
00:10:16,738 --> 00:10:19,405
称它为Foo，你所说的并不重要。

234
00:10:19,474 --> 00:10:21,707
创建它时单击使用核心数据

235
00:10:21,775 --> 00:10:24,610
然后将该代码从该AppDelegate复制到这里。

236
00:10:24,678 --> 00:10:27,913
好的，代码与每个应用程序是一样的。

237
00:10:27,981 --> 00:10:31,115
这些之间的唯一区别就是这样

238
00:10:31,183 --> 00:10:32,549
一个字符串在这里。

239
00:10:32,618 --> 00:10:33,384
你看到那个字符串？

240
00:10:33,453 --> 00:10:36,253
那就是那个xcmod​​eld文件的名字，所以

241
00:10:36,321 --> 00:10:37,520
datamodeld文件。

242
00:10:37,589 --> 00:10:39,021
所以以我们的核心数据为例，

243
00:10:39,090 --> 00:10:41,190
这个字符串将是CoreDataExample。

244
00:10:41,259 --> 00:10:43,692
当我们回到自己的新文件创建它，

245
00:10:43,761 --> 00:10:45,093
当然，我们称之为模型。

246
00:10:45,162 --> 00:10:49,130
所以只要确保这个字符串匹配文件的名称，

247
00:10:49,198 --> 00:10:53,100
xcmod​​el datamodeld文件，好吗？

248
00:10:53,169 --> 00:10:55,736
所以这就是你不需要做的事情

249
00:10:55,805 --> 00:10:57,805
代码数据原来你要回来了

250
00:10:57,874 --> 00:10:59,038
添加它 - 只需复制和粘贴。

251
00:10:59,107 --> 00:11:03,509
这只是这个var真的，它提供了另一件事

252
00:11:03,578 --> 00:11:06,946
在AppDelegate中，它是一个名为saveContext的函数。

253
00:11:07,014 --> 00:11:08,147
这是一个非常简单的小功能。

254
00:11:08,215 --> 00:11:11,016
我会告诉你如何自己写。

255
00:11:11,085 --> 00:11:12,918
如果你想复制它，你可以。

256
00:11:12,987 --> 00:11:16,321
我也注意到他们有应用程序

257
00:11:16,390 --> 00:11:18,790
是这个应用程序，AppDelegate方法，

258
00:11:18,858 --> 00:11:21,592
在你被终止之前被调用

259
00:11:21,661 --> 00:11:24,594
您以任何方式终止它们，并调用saveContext。

260
00:11:24,663 --> 00:11:26,129
那么这是一个想法，一个好主意。

261
00:11:26,198 --> 00:11:28,198
saveContext()只是保存你的数据库。

262
00:11:28,267 --> 00:11:30,566
这就是saveContext所做的，好吗？

263
00:11:30,635 --> 00:11:33,903
所以这是你如果不这样做的话。

264
00:11:33,971 --> 00:11:37,139
所以无论如何，你可以看到这里唯一的事情

265
00:11:37,208 --> 00:11:39,641
是这个懒惰的var persistentContainer，和

266
00:11:39,709 --> 00:11:41,209
我将会谈论persistentContainer，

267
00:11:41,277 --> 00:11:43,677
因为这是基本上包含的东西

268
00:11:43,746 --> 00:11:46,346
你的数据库好吗？

269
00:11:46,415 --> 00:11:48,215
但是让我们回去谈谈visual map。

270
00:11:48,284 --> 00:11:51,084
在我们可以做任何事情之前，我们必须有一个视觉地图

271
00:11:51,153 --> 00:11:53,853
在我们的数据库，因为我们必须有一些事情

272
00:11:53,922 --> 00:11:56,556
我们的数据库，一些对象和类似的东西。

273
00:11:56,625 --> 00:12:00,292
而Core数据库存储的东西在这种非常

274
00:12:00,361 --> 00:12:02,027
直截了当的方式。

275
00:12:02,095 --> 00:12:05,764
它在我们的代码中看起来非常面向对象，因为

276
00:12:05,833 --> 00:12:08,466
在Core Data术语中，它是存储实体，

277
00:12:08,535 --> 00:12:11,235
看起来像我们的代码的类。

278
00:12:11,304 --> 00:12:14,872
属性，看起来像我们的类的vars。

279
00:12:14,940 --> 00:12:18,242
和关系，只是看起来像vars指向

280
00:12:18,310 --> 00:12:22,279
数据库中的其他对象，其他实体等

281
00:12:22,348 --> 00:12:25,181
所以我们要用这个我所说的故事板。

282
00:12:25,250 --> 00:12:26,081
不是，不要困惑，

283
00:12:26,150 --> 00:12:27,716
这不是故事板，好吗？

284
00:12:27,785 --> 00:12:30,319
你知道一个storyboard是什么，你的Interface Builder的东西。

285
00:12:30,387 --> 00:12:32,087
但它有点像故事板，

286
00:12:32,156 --> 00:12:34,823
这就是为什么它在数据库引用。

287
00:12:34,892 --> 00:12:37,224
它是一个图形化，可视化的编辑器来创建和

288
00:12:37,293 --> 00:12:40,427
描述所有这些实体，属性和关系，

289
00:12:40,496 --> 00:12:42,896
好的，这就是我们要在这里做的。

290
00:12:42,965 --> 00:12:45,098
所以让我们开始添加一个实体。

291
00:12:45,166 --> 00:12:48,034
很简单，我们下到这个底部的这个按钮

292
00:12:48,103 --> 00:12:49,502
称为添加实体。

293
00:12:49,571 --> 00:12:51,103
好的，添加一个实体。

294
00:12:51,172 --> 00:12:53,305
顺便说一下，还有几件其他事情，如果你

295
00:12:53,374 --> 00:12:55,807
按住该按钮，您将看到添加提取请求，

296
00:12:55,875 --> 00:12:56,774
和添加配置。

297
00:12:56,843 --> 00:12:58,642
我没有时间谈论那些不幸的事情，

298
00:12:58,711 --> 00:13:01,345
但特别是添加提取请求是一个很酷的。

299
00:13:01,414 --> 00:13:04,247
所以，如果你能把我在这里教你的东西延伸下去

300
00:13:04,316 --> 00:13:07,350
通过学习，这将是伟大的。

301
00:13:07,419 --> 00:13:08,884
所以你点击添加实体，

302
00:13:08,953 --> 00:13:11,754
它创建一个名为Entity的实体。

303
00:13:11,822 --> 00:13:13,822
Cuz它不知道你想要什么名字。

304
00:13:13,891 --> 00:13:16,491
就像我说的，这类似于一个类。

305
00:13:16,560 --> 00:13:20,295
现在在我们的代码中，我们将看到任何这样的实例

306
00:13:20,364 --> 00:13:24,432
实体作为名为NSManagedObject的类的实例。

307
00:13:24,501 --> 00:13:27,235
所以NSManagedObject在Core Data中非常重要。

308
00:13:27,304 --> 00:13:29,804
它是超级类或所有类的一切

309
00:13:29,872 --> 00:13:32,773
来自所有这些从数据库中出来的实体。

310
00:13:32,842 --> 00:13:36,142
这就像在我们的代码中代表它们的东西，

311
00:13:36,211 --> 00:13:37,710
我们将会看到这一切。

312
00:13:37,779 --> 00:13:40,679
所以对于我这样的幻灯片，

313
00:13:40,748 --> 00:13:43,715
我要做的是创建一个数据库

314
00:13:43,784 --> 00:13:45,384
像Twitter这样的东西。

315
00:13:45,453 --> 00:13:46,952
所以它会有tweet和

316
00:13:47,021 --> 00:13:48,086
我们会有Twitter用户。

317
00:13:48,155 --> 00:13:49,954
所以这些将是我们拥有的两个实体

318
00:13:50,023 --> 00:13:52,223
你最终会看到，我们会有Tweet和

319
00:13:52,292 --> 00:13:53,557
我们的代码中的TwitterUser类

320
00:13:53,625 --> 00:13:55,258
我们要访问vars和所有的东西。

321
00:13:55,327 --> 00:13:57,126
所以我要重命名这个实体，

322
00:13:57,195 --> 00:13:59,828
这个，我补充说，这是默认的实体，

323
00:13:59,897 --> 00:14:02,331
我要重命名，并称之为Tweet。

324
00:14:02,400 --> 00:14:04,934
所以这将是我创建的第一个实体

325
00:14:05,002 --> 00:14:06,568
在数据库中。

326
00:14:06,636 --> 00:14:08,837
现在，一个实体可以有属性。

327
00:14:08,906 --> 00:14:11,005
那些就像变种和关系。

328
00:14:11,074 --> 00:14:14,108
那些就像指向其他实体的变量。

329
00:14:14,177 --> 00:14:16,276
我告诉你，这个属性在底部，

330
00:14:16,345 --> 00:14:17,144
我不会说

331
00:14:17,213 --> 00:14:19,078
很酷，但不会谈论他们。

332
00:14:19,147 --> 00:14:21,047
不仅仅是时间性

333
00:14:21,115 --> 00:14:23,315
所以我们去添加一些属性给这个实体。

334
00:14:23,384 --> 00:14:24,783
真的很简单，你点击这个加号按钮，

335
00:14:24,852 --> 00:14:26,284
还有一个Add Attribute按钮，

336
00:14:26,353 --> 00:14:28,419
在右下角看到它。

337
00:14:28,488 --> 00:14:29,954
但我会点击这个小点

338
00:14:30,023 --> 00:14:33,290
按钮就在“属性”下面。

339
00:14:33,359 --> 00:14:36,059
当我在那里添加一个称为属性的新属性

340
00:14:36,128 --> 00:14:37,927
我会直接编辑它的名字，

341
00:14:37,996 --> 00:14:39,495
就像我做了实体名称一样。

342
00:14:39,564 --> 00:14:40,663
我会把它改为文本。

343
00:14:40,732 --> 00:14:45,268
所以，这将是我们的tweet文字，140个字符

344
00:14:45,336 --> 00:14:49,438
的推文将是这个特殊的属性。

345
00:14:49,506 --> 00:14:53,008
现在，一旦我这样做，通知，我有一个错误。

346
00:14:53,077 --> 00:14:55,476
在角落里，这个红色的错误。

347
00:14:55,545 --> 00:14:56,043
和原因

348
00:14:56,112 --> 00:14:58,846
所有属性都必须有一个类型。

349
00:14:58,914 --> 00:15:01,182
他们不能像这样一个不定义的类型。

350
00:15:01,250 --> 00:15:03,350
你会看到它的类型是未定义的。

351
00:15:03,419 --> 00:15:05,919
所以我们需要把它改成一个类型。

352
00:15:05,988 --> 00:15:08,721
这真的很容易，就在那里它说没有定义。

353
00:15:08,790 --> 00:15:10,122
我们只是去掉鼠标，

354
00:15:10,191 --> 00:15:12,924
它会提出一个菜单，我们可以选择我们的类型。

355
00:15:12,993 --> 00:15:15,393
现在，这些是我们必须选择的类型。

356
00:15:15,462 --> 00:15:18,663
很多不同的数字类型，如16位整数，

357
00:15:18,732 --> 00:15:20,164
32位整数等

358
00:15:20,233 --> 00:15:23,900
双打，漂浮，当然可以一串，

359
00:15:23,969 --> 00:15:28,605
一个布尔值，一个日期看起来像一个日期，

360
00:15:28,674 --> 00:15:32,142
你知道我们代码中的date struct。

361
00:15:32,210 --> 00:15:35,445
而二进制数据将看起来像数据结构

362
00:15:35,513 --> 00:15:36,513
在我们的代码里面

363
00:15:36,581 --> 00:15:39,782
所以，这些将映射到非常熟悉的数据类型

364
00:15:39,851 --> 00:15:40,849
我们看到

365
00:15:40,918 --> 00:15:42,317
那里有一个在底部，

366
00:15:42,386 --> 00:15:44,919
可转换，另一件事我不会谈论。

367
00:15:44,988 --> 00:15:48,322
但是可变形可以让您存储任何东西

368
00:15:48,391 --> 00:15:51,592
通过将其转换为数据，并进入数据库

369
00:15:51,661 --> 00:15:53,326
然后在出口途中将其转换回来。

370
00:15:53,395 --> 00:15:54,728
所以如果你选择可变的那里，

371
00:15:54,797 --> 00:15:56,729
你要做一些额外的工作。

372
00:15:56,798 --> 00:15:59,599
告诉核心数据有关转型，这就是为什么

373
00:15:59,668 --> 00:16:02,001
我真的没有时间告诉你，但只是知道

374
00:16:02,070 --> 00:16:04,003
如果你想存储像CGRect这样的东西。

375
00:16:04,071 --> 00:16:07,539
其实，如果我要存储一个CGRect，我可以使用

376
00:16:07,607 --> 00:16:09,841
该功能有一些函数叫做类似的东西

377
00:16:11,344 --> 00:16:13,143
NSStringFromCGRect。

378
00:16:13,212 --> 00:16:14,278
它给你一个字符串，和

379
00:16:14,346 --> 00:16:16,112
那么有NSCGRectFromString或

380
00:16:16,181 --> 00:16:16,746
这样的东西

381
00:16:16,815 --> 00:16:18,047
所以我可能会把它存储成一个字符串，

382
00:16:18,115 --> 00:16:20,482
但如果我有一些比这更复杂的东西，

383
00:16:20,551 --> 00:16:21,783
那么我可能会用可变形的。

384
00:16:21,852 --> 00:16:27,388
好的，这些属性将被访问，

385
00:16:27,457 --> 00:16:29,390
我们会得到并设定他们的值。

386
00:16:29,459 --> 00:16:32,159
实际上，我们不会这样做，但从根本上来说是这样

387
00:16:32,228 --> 00:16:34,595
你做的方式是你有这两种方法，

388
00:16:34,664 --> 00:16:36,430
value(forKey)和setValue (forKey)

389
00:16:36,498 --> 00:16:38,598
我会谈谈我们将如何使用它，但是

390
00:16:38,667 --> 00:16:43,036
这就是我们将如何设置和获取一个实体的值。

391
00:16:43,105 --> 00:16:44,971
请注意，一旦我们出现错误就会消失

392
00:16:45,040 --> 00:16:47,239
给了这个东西，一种类型。

393
00:16:47,308 --> 00:16:50,709
所以在这里我会添加一些更多的属性，标识符，

394
00:16:50,777 --> 00:16:52,978
这只是一些识别推文的字符串

395
00:16:53,046 --> 00:16:55,714
然后创建，这是当它被推送。

396
00:16:55,782 --> 00:17:00,251
注意我将创建的类型设置为日期，因为

397
00:17:00,320 --> 00:17:03,287
这是一个日期，显然，当事情被创造。

398
00:17:03,356 --> 00:17:06,189
现在这是查看我们的实体和属性的一种方式，

399
00:17:06,258 --> 00:17:07,257
这种表格形式。

400
00:17:07,326 --> 00:17:09,859
但是我们也可以以图形的形式看待它。

401
00:17:09,928 --> 00:17:12,094
如果你在角落里看到编辑风格。

402
00:17:12,163 --> 00:17:13,829
如果我点击另一个按钮，

403
00:17:13,898 --> 00:17:15,965
看起来更像一个图形的那个，

404
00:17:16,033 --> 00:17:17,832
那么它告诉我一样的东西，但是

405
00:17:17,901 --> 00:17:18,867
以这种图形形式。

406
00:17:18,936 --> 00:17:21,335
甚至在图纸上，好吗？

407
00:17:21,404 --> 00:17:24,105
在这里我们可以做到这一点

408
00:17:24,173 --> 00:17:25,806
所有我们在另一个人做的事情。

409
00:17:25,875 --> 00:17:27,941
例如，我还可以在这里添加实体。

410
00:17:28,010 --> 00:17:30,543
所以我会为我的Twitter用户添加另一个实体，

411
00:17:30,612 --> 00:17:32,244
这是推特的人。

412
00:17:32,313 --> 00:17:34,112
那就是它再次称它为实体，

413
00:17:34,181 --> 00:17:35,280
这是默认值。

414
00:17:35,349 --> 00:17:38,583
我们将其名称设置为TwitterUser。

415
00:17:38,652 --> 00:17:40,986
好的，所以我们现在有两个实体，你看到那里。

416
00:17:41,054 --> 00:17:44,289
当你拖动这些实体时，有什么好的，

417
00:17:44,358 --> 00:17:47,191
这个，这种编辑器，这个图形

418
00:17:47,259 --> 00:17:49,727
编辑，会自动保持间隔开

419
00:17:49,795 --> 00:17:50,594
从彼此。

420
00:17:50,663 --> 00:17:52,595
哪一种是有趣的，特别是因为他们要去

421
00:17:52,664 --> 00:17:54,497
开始连接线，因为

422
00:17:54,566 --> 00:17:56,332
他们将开始有关系

423
00:17:56,400 --> 00:17:59,668
在一段时间内你会看到对方。

424
00:17:59,737 --> 00:18:02,871
我们可以添加这种图形风格的属性

425
00:18:02,939 --> 00:18:05,874
可以通过双击来编辑那些

426
00:18:05,943 --> 00:18:07,809
他们，改变你想要的任何东西。

427
00:18:07,877 --> 00:18:11,078
所以，这里我有一个screenName，现在当然我有一个错误

428
00:18:11,147 --> 00:18:14,014
再次因为我没有设置该screenName的类型。

429
00:18:14,083 --> 00:18:17,350
所以，在这个视图中，你可以通过提升来设置类型

430
00:18:17,419 --> 00:18:18,017
观察者(Inspector)

431
00:18:18,086 --> 00:18:20,286
所以你刚刚提起你的普通检查员，

432
00:18:20,355 --> 00:18:21,553
属性检查器。

433
00:18:21,622 --> 00:18:23,755
而且，在这里你可以看到它检查screenName，

434
00:18:23,824 --> 00:18:25,357
这里有名字。

435
00:18:25,425 --> 00:18:27,625
还有一些其他的东西在这里像短暂的，

436
00:18:27,694 --> 00:18:28,626
索引，可选。

437
00:18:28,694 --> 00:18:31,395
顺便说一下，该选项并不意味着这是可选的

438
00:18:31,464 --> 00:18:33,664
喜欢Swift的东西可选。

439
00:18:33,732 --> 00:18:37,233
这是可选的，就像SQL数据库术语一样。

440
00:18:37,302 --> 00:18:39,469
在关系数据库中可选。

441
00:18:39,538 --> 00:18:42,004
所以我不会谈论任何数据库

442
00:18:42,073 --> 00:18:43,539
您很少需要在这里设置任何这些属性。

443
00:18:43,540 --> 00:18:45,006
它的东西。

444
00:18:46,743 --> 00:18:47,942
但您需要设置类型。

445
00:18:48,011 --> 00:18:49,143
所以我们不会谈论，但是

446
00:18:49,211 --> 00:18:51,279
我们必须在这里设置类型。

447
00:18:51,347 --> 00:18:53,280
而screenName当然是一个字符串。

448
00:18:53,349 --> 00:18:56,116
所以我只是把它改成一个字符串。

449
00:18:56,185 --> 00:18:59,652
我在TwitterUser中添加另一个属性，

450
00:18:59,721 --> 00:19:03,056
这一个是名字，人的实名，

451
00:19:03,125 --> 00:19:06,458
不是他们的@号手柄，而是他们的实名。

452
00:19:06,527 --> 00:19:09,327
现在我们已经搭建了几个实体

453
00:19:09,396 --> 00:19:12,030
对他们的属性，好的，这样会看起来像

454
00:19:12,099 --> 00:19:15,767
最终在我们的代码中使用var的类。

455
00:19:15,836 --> 00:19:19,003
但是关系如何，显然是一个Tweet和

456
00:19:19,072 --> 00:19:22,774
一个TwitterUser有彼此的关系。

457
00:19:22,842 --> 00:19:25,209
并建立我们之间的关系

458
00:19:25,278 --> 00:19:28,145
Ctrl +拖动，这是我们最喜欢的手势在Xcode和

459
00:19:28,213 --> 00:19:28,945
我们再次使用它。

460
00:19:29,013 --> 00:19:31,780
Ctrl +拖动创建关系

461
00:19:31,849 --> 00:19:32,648
两件事之间。

462
00:19:32,717 --> 00:19:36,151
而且Ctrl +拖动方向其实并不重要，

463
00:19:36,220 --> 00:19:38,820
因为你正在创造一种双向的

464
00:19:38,889 --> 00:19:40,388
关系。

465
00:19:40,457 --> 00:19:43,057
所以在这里，我做了Ctrl +拖动，它自动创建了这个

466
00:19:43,126 --> 00:19:47,829
关系，它被称为新的关系双方。

467
00:19:47,897 --> 00:19:52,766
而这种关系基本上就是这样

468
00:19:52,835 --> 00:19:54,768
我们班上的一个var。

469
00:19:54,837 --> 00:19:59,071
但是，var的类型将是类型，如果是

470
00:19:59,140 --> 00:20:01,508
像一个Tweet，你知道，它会是一个单一的，或

471
00:20:01,576 --> 00:20:04,343
它可能是一个NSSet，如果它们很多。

472
00:20:04,412 --> 00:20:06,679
像Twitter用户可能会有很多推文，和

473
00:20:06,747 --> 00:20:08,781
我会在一会儿谈论。

474
00:20:08,849 --> 00:20:12,383
所以，从Tweet的角度来看这个关系

475
00:20:12,452 --> 00:20:14,419
一个TwitterUser是Tweeter。

476
00:20:14,487 --> 00:20:16,821
用推特发推文的人

477
00:20:16,889 --> 00:20:19,557
所以，我要改变这个关系的名字

478
00:20:19,625 --> 00:20:24,027
Tweet侧要高音单而不是newRelationship，

479
00:20:24,095 --> 00:20:25,361
这是默认值。

480
00:20:25,430 --> 00:20:27,763
但是，另一方面，好的，所以这就是为什么我称之为tweeter。

481
00:20:27,832 --> 00:20:29,865
另一方面，TwitterUser从它的

482
00:20:29,934 --> 00:20:33,502
透视，好的，推特的关系是

483
00:20:33,571 --> 00:20:35,737
这个Twitter用户推特的推文。

484
00:20:35,805 --> 00:20:38,840
好吧，这不是高音，Twitter用户是tweeter，

485
00:20:38,909 --> 00:20:41,342
所以他永远不会称这种关系tweeter。

486
00:20:41,411 --> 00:20:44,277
他会把这个关系叫做tweets

487
00:20:44,346 --> 00:20:46,213
因为这是推文。

488
00:20:46,282 --> 00:20:47,748
现在注意这是复数，好的，

489
00:20:47,816 --> 00:20:50,583
我马上会讲到这个

490
00:20:50,652 --> 00:20:54,186
请注意，当我们这样做时，Xcode跟踪我正在检查

491
00:20:54,255 --> 00:20:57,423
在TwitterUser方面tweet的关系，

492
00:20:57,491 --> 00:20:58,858
它知道倒数。

493
00:20:58,926 --> 00:21:00,759
它知道高音扬声器相反的方向，

494
00:21:00,828 --> 00:21:02,828
总有一个反向关系。

495
00:21:04,631 --> 00:21:07,264
那么让我们来谈谈这个推文是复数吗？

496
00:21:07,333 --> 00:21:10,100
所以tweet只能有一个tweeter。

497
00:21:10,169 --> 00:21:12,002
只有一个人可以推特，但是

498
00:21:12,070 --> 00:21:16,873
Twitter用户可以鸣叫数千个推文，好吗？

499
00:21:16,942 --> 00:21:18,474
所以这有点不一样

500
00:21:18,542 --> 00:21:19,374
一种关系。

501
00:21:19,443 --> 00:21:21,410
那么我们如何指定呢？

502
00:21:21,479 --> 00:21:24,679
我们称之为tweet的关系，

503
00:21:24,748 --> 00:21:27,915
一个很多的关系，因为显然是Twitter

504
00:21:27,984 --> 00:21:29,951
用户可以有很多推文。

505
00:21:30,019 --> 00:21:32,953
所以这被称为许多数据库的说法，和

506
00:21:33,022 --> 00:21:34,321
你在检查员中设置了这个权限。

507
00:21:34,390 --> 00:21:36,123
所以你只需点击那个tweets和

508
00:21:36,192 --> 00:21:37,690
你到这里去的地方说Type，

509
00:21:37,759 --> 00:21:40,927
而不是让它成为一个你会改变它

510
00:21:40,995 --> 00:21:43,962
要成为许多人，好的，所以现在这是一个很多的关系。

511
00:21:44,031 --> 00:21:49,568
就在那里，你可以看到它改变了一点，

512
00:21:49,637 --> 00:21:51,336
我们会在一秒钟内显示。

513
00:21:51,404 --> 00:21:54,339
但这种关系的类型现在在推文上

514
00:21:54,407 --> 00:21:57,909
方面仍然是NSManagedObject类型，

515
00:21:57,978 --> 00:22:00,111
因为它指向数据库中的另一个实体。

516
00:22:00,179 --> 00:22:02,279
而且我们知道数据库中的对象

517
00:22:02,348 --> 00:22:04,081
由NSManagedObject表示。

518
00:22:04,150 --> 00:22:06,783
所以这将是那个var的类型。

519
00:22:06,851 --> 00:22:09,118
虽然我们最终会做得更好

520
00:22:09,187 --> 00:22:11,420
但是，另一方面，

521
00:22:11,488 --> 00:22:17,493
那个var的类型是NSSet的NSManagedObject，好吗？

522
00:22:17,562 --> 00:22:23,598
现在NSSet，有一个Swift结构称为set。

523
00:22:23,667 --> 00:22:25,766
它是一种通用类型，它就像一个数组

524
00:22:25,835 --> 00:22:26,667
说什么在一个数组，

525
00:22:26,736 --> 00:22:29,270
一套一样的东西，你必须说出什么。

526
00:22:29,338 --> 00:22:33,240
NSSet是一种较老的Objective-C类。

527
00:22:33,309 --> 00:22:35,375
它不是通用的，它是无类型的。

528
00:22:35,443 --> 00:22:39,212
NSSet中的东西是任何东西，我们需要一点点

529
00:22:39,281 --> 00:22:42,214
有点这里cuz我们真的不知道什么样的东西

530
00:22:42,283 --> 00:22:43,149
在那里

531
00:22:43,217 --> 00:22:47,619
但是，在您的代码中，您可以从此NSSet转换

532
00:22:47,688 --> 00:22:51,656
的NSManagedObject的一组你知道在那里

533
00:22:51,725 --> 00:22:53,158
用作问号，和

534
00:22:53,226 --> 00:22:55,293
如果事实上是在那里，那将会奏效。

535
00:22:57,296 --> 00:22:58,462
那就是NSSet那里。

536
00:22:59,664 --> 00:23:01,164
最后一件事我会在之前告诉你的

537
00:23:01,233 --> 00:23:04,300
我们回到幻灯片是这个删除规则。

538
00:23:04,369 --> 00:23:06,268
你看到删除规则，

539
00:23:06,337 --> 00:23:10,005
点击这里的推文，所以我们正在检查tweet。

540
00:23:10,074 --> 00:23:13,608
这个删除规则告诉你会发生什么

541
00:23:13,677 --> 00:23:17,979
如果我们删除了这个Twitter用户，请到尖叫的tweets。

542
00:23:18,047 --> 00:23:19,880
如果我删除这个Twitter用户，

543
00:23:19,949 --> 00:23:23,417
这是否意味着我删除所有Twitter用户的推文？

544
00:23:23,486 --> 00:23:26,287
那么这取决于这个删除规则。

545
00:23:26,355 --> 00:23:27,821
这个删除规则正在说无效，这意味着没有。

546
00:23:27,822 --> 00:23:29,288
所以现在，

547
00:23:29,358 --> 00:23:32,091
这些推文将留在数据库中，还有他们的tweeter

548
00:23:32,160 --> 00:23:35,261
将被设置为零，因为他们的tweeter被删除。

549
00:23:35,330 --> 00:23:37,829
但是有一个级联的删除规则，可以说

550
00:23:37,898 --> 00:23:40,332
如果我删除这个东西，然后删除它的一切

551
00:23:40,401 --> 00:23:42,367
指向，直到图形和

552
00:23:42,436 --> 00:23:43,434
删除一切

553
00:23:43,503 --> 00:23:46,170
所以这是什么控制当你删除时会发生什么。

554
00:23:46,238 --> 00:23:48,405
现在我不会要求你甚至删除;

555
00:23:48,474 --> 00:23:51,141
我想我可能会问你额外的信用做删除

556
00:23:51,209 --> 00:23:52,141
作业五。

557
00:23:52,210 --> 00:23:54,744
因为删除，你真的会知道什么

558
00:23:54,812 --> 00:23:56,612
你在做 - 当你可以删除的东西，和

559
00:23:56,681 --> 00:23:58,413
你想要什么样的删除规则？

560
00:23:58,482 --> 00:24:00,215
但我只是想让你知道你指定

561
00:24:00,283 --> 00:24:02,317
检查员在这里的删除规则。

562
00:24:03,986 --> 00:24:07,955
好的，现在你已经定义了所有的实体，属性

563
00:24:08,023 --> 00:24:11,792
在关系中，那么我们可以做些什么呢？

564
00:24:11,861 --> 00:24:15,462
那么做任何事情我们需要抓住他们

565
00:24:15,531 --> 00:24:18,531
在我们的代码中，基本上抓住他们，

566
00:24:18,600 --> 00:24:20,466
要做到这一点我们需要另一个重要的类，

567
00:24:20,535 --> 00:24:23,502
NSManagedObjectContext，所以我告诉过你

568
00:24:23,571 --> 00:24:26,071
数据库中的所有这些东西都是NSManagedObjects，

569
00:24:26,139 --> 00:24:28,206
你需要一个NSManagedObjectContext，

570
00:24:28,275 --> 00:24:32,009
它代表一个数据库来做任何事情，

571
00:24:32,078 --> 00:24:34,578
获得任何一个，创建任何一个等等，

572
00:24:34,647 --> 00:24:37,381
这是Core Data活动转向的枢纽，

573
00:24:37,449 --> 00:24:38,615
就像我说的那样。

574
00:24:38,684 --> 00:24:41,185
那么如何获得这些NSManagedObjectContext之一？

575
00:24:41,253 --> 00:24:43,920
答案是，你需要一个persistentContainer。

576
00:24:43,989 --> 00:24:46,623
噢，你知道在哪里得到其中的一个。

577
00:24:46,691 --> 00:24:48,190
您只需点击“Use Core Data”即可

578
00:24:48,259 --> 00:24:49,858
它会出现在你的AppDelegate中。

579
00:24:49,927 --> 00:24:51,693
你会得到那个lazy的var，

580
00:24:51,761 --> 00:24:53,461
这就是所谓的persistentContainer。

581
00:24:53,530 --> 00:24:55,262
那将成为一个持久性容器。

582
00:24:55,331 --> 00:24:57,431
从那里你可以得到上下文。

583
00:24:57,499 --> 00:25:00,568
现在，如果你的AppDelegate中有lazy的var，

584
00:25:00,636 --> 00:25:02,636
你怎么叫这个var？

585
00:25:02,705 --> 00:25:04,003
你怎么得到那个var？

586
00:25:04,072 --> 00:25:05,571
这是你怎么做的，好吗？

587
00:25:05,640 --> 00:25:10,009
你得到一个共享的UIApplication的副本，现在，

588
00:25:10,077 --> 00:25:12,678
我们没有谈论这个，但你的应用程序有这个和

589
00:25:12,747 --> 00:25:16,415
仅代表您的应用程序的UIApplication对象

590
00:25:16,484 --> 00:25:19,784
你可以通过做UIApplication.shared来获得它，

591
00:25:19,853 --> 00:25:20,919
这是一个var。

592
00:25:20,987 --> 00:25:23,887
UIApplication类中的静态var。

593
00:25:23,956 --> 00:25:24,955
给你分享一个。

594
00:25:25,024 --> 00:25:28,191
那么你将在UIApplication中访问这个var

595
00:25:28,260 --> 00:25:29,159
其代表。

596
00:25:30,528 --> 00:25:32,762
现在，它的委托是自动设置的

597
00:25:32,830 --> 00:25:35,597
你是你看到的这个Swift类AppDelegate

598
00:25:35,666 --> 00:25:37,999
总是;我们总是把它放在支持文件中

599
00:25:38,068 --> 00:25:40,134
让我们的方式，但它为您创造，

600
00:25:40,203 --> 00:25:41,035
这是一个很好的小类。

601
00:25:41,104 --> 00:25:43,604
我们将讨论应用程序的生命周期

602
00:25:43,672 --> 00:25:46,707
在哪里，一点点，但现在所有

603
00:25:46,776 --> 00:25:49,542
你需要知道的是，你可以得到AppDelegate，你想要的

604
00:25:49,611 --> 00:25:52,845
发送persistentContainer来获取该var，但是

605
00:25:52,914 --> 00:25:57,450
当然，你必须首先作为AppDelegate类。

606
00:25:57,519 --> 00:25:58,885
所以这是你要使用的代码。

607
00:25:58,953 --> 00:26:01,120
(UIApplication.shared.delegate as！

608
00:26:01,189 --> 00:26:03,956
AppDelegate)所有在一个表达式中

609
00:26:04,024 --> 00:26:06,758
dot persistentContainer现在你会得到这个

610
00:26:06,826 --> 00:26:09,794
persistentContainer，并注意我正在做

611
00:26:09,862 --> 00:26:12,863
感叹号如果我的App Delegate是这样，这会崩溃

612
00:26:12,932 --> 00:26:15,866
不是事实上应用程序代表，但它已经被接线

613
00:26:15,934 --> 00:26:18,669
当你创建一个新项目时，

614
00:26:18,737 --> 00:26:20,103
所以这不应该是一个问题。

615
00:26:21,306 --> 00:26:21,770
好的？所以

616
00:26:21,839 --> 00:26:24,640
现在我有这个persistentContainer，

617
00:26:24,709 --> 00:26:27,275
我需要得到它的上下文。

618
00:26:27,344 --> 00:26:28,643
所以，

619
00:26:28,712 --> 00:26:33,281
容器有一个叫做viewContext的awesome var。

620
00:26:33,349 --> 00:26:36,684
而viewContext是一个NSManagedObjectContext

621
00:26:36,753 --> 00:26:39,620
只适用于主队列。

622
00:26:39,688 --> 00:26:40,520
这是红色的，

623
00:26:40,588 --> 00:26:42,956
你知道每当幻灯片上看到红色的东西，

624
00:26:43,024 --> 00:26:45,191
这意味着要注意，这将是重要的

625
00:26:45,260 --> 00:26:47,960
你的家庭作业，在生活中，但是

626
00:26:48,029 --> 00:26:51,029
您只能在主队列中使用此viewContext，

627
00:26:51,098 --> 00:26:54,333
它调用viewContext，因为你使用它与你的意见，

628
00:26:54,401 --> 00:26:57,869
好的，你的UI视图，这就是为什么我们称之为viewContext。

629
00:26:59,706 --> 00:27:02,773
那么为什么要说一下这个主队列呢？

630
00:27:02,842 --> 00:27:05,809
那么，我这样做的原因是因为NSManagedObjectContext

631
00:27:05,878 --> 00:27:07,744
不是线程安全的。

632
00:27:07,813 --> 00:27:10,747
但我会和你谈谈，告诉你我们该怎么做

633
00:27:10,816 --> 00:27:13,883
多线程数据库的东西，在这个谈话结束。

634
00:27:13,951 --> 00:27:16,552
好的，所以现在你有这个viewContext，那么你可以

635
00:27:16,621 --> 00:27:18,020
用它来做事情

636
00:27:18,089 --> 00:27:21,690
现在是这样

637
00:27:21,759 --> 00:27:23,892
{UIApplication.shared.delegate as！

638
00:27:23,960 --> 00:27:26,027
Appdelegate).persistentContainer,

639
00:27:26,096 --> 00:27:27,394
这是一堆混乱的代码。

640
00:27:27,463 --> 00:27:30,330
有很多，在那里有这些事情。

641
00:27:30,399 --> 00:27:34,100
所以有时我们只是创建一个静态版本

642
00:27:34,169 --> 00:27:37,537
persistentContainer在我们的AppDelegate。

643
00:27:37,606 --> 00:27:39,138
好的，我们就把它称之为同样的事情。

644
00:27:39,207 --> 00:27:41,307
persistentContainer，但它是静态的

645
00:27:41,376 --> 00:27:43,776
它只会返回那个凌乱的代码行。

646
00:27:43,845 --> 00:27:46,011
所以现在我们可以得到那个persistentContainer

647
00:27:46,079 --> 00:27:48,747
AppDelegate.persistentContai。

648
00:27:48,815 --> 00:27:50,248
看看我在那里做了什么

649
00:27:50,317 --> 00:27:52,683
我只是让它更容易起床，使它成为一个静态，

650
00:27:52,752 --> 00:27:56,153
一个类var，我们可以用viewContext做同样的事情，

651
00:27:56,222 --> 00:27:59,455
你可能会创建一个名为viewContext的静态

652
00:27:59,524 --> 00:28:02,092
其余的幻灯片可以假设我已经做到了。

653
00:28:02,160 --> 00:28:04,793
这是好的，因为打字那么长的凌乱的事情会

654
00:28:04,862 --> 00:28:07,563
使我所有的幻灯片溢出边缘。

655
00:28:07,632 --> 00:28:09,831
所以我也要使用这个较短的版本。

656
00:28:09,900 --> 00:28:11,300
欢迎您创建静态

657
00:28:11,369 --> 00:28:13,201
如果你愿意，你的AppDelegate版本

658
00:28:13,270 --> 00:28:14,568
使你的代码更清洁一些。

659
00:28:14,637 --> 00:28:17,104
现在这个viewContext在persistentContainer中

660
00:28:17,173 --> 00:28:18,456
有一个代表你的整个

661
00:28:18,457 --> 00:28:19,740
被分享。

662
00:28:19,808 --> 00:28:20,573
数据库。

663
00:28:20,642 --> 00:28:22,709
所以创建一个静态是非常好的

664
00:28:22,777 --> 00:28:23,643
这样做

665
00:28:23,711 --> 00:28:26,178
顺便说一句，如果你想要多个数据库呢？

666
00:28:26,246 --> 00:28:27,679
甚至可以有多个数据库

667
00:28:27,748 --> 00:28:29,180
不同的模式。

668
00:28:29,249 --> 00:28:31,316
很简单，如果你去看代码

669
00:28:31,384 --> 00:28:34,819
persistentContainer在AppDelegate中，

670
00:28:34,887 --> 00:28:37,087
你会看到它只有四行代码。

671
00:28:37,156 --> 00:28:39,289
你可以复制它创建一个不同的

672
00:28:39,358 --> 00:28:42,759
persistentContainer使用不同的xcmod​​eld文件。

673
00:28:42,828 --> 00:28:45,295
不是根据示例使用模型，

674
00:28:45,363 --> 00:28:46,828
创建另一个与另一个不同的

675
00:28:46,897 --> 00:28:50,399
你可以去文件，新文件，创建另一个数据模型。

676
00:28:50,468 --> 00:28:54,403
你甚至可以创建两个持久性容器

677
00:28:54,471 --> 00:28:55,904
相同的型号。

678
00:28:55,973 --> 00:28:58,006
所以他们将是单独的数据库，但是

679
00:28:58,074 --> 00:28:59,640
有相同的模型，相同的实体到那个和

680
00:28:59,709 --> 00:29:00,674
与此相同的关系。

681
00:29:00,743 --> 00:29:02,309
这也是完全允许的。

682
00:29:02,377 --> 00:29:04,243
但是对于你要在这个班上做的一切，

683
00:29:04,312 --> 00:29:05,444
对于大多数应用程序，

684
00:29:05,513 --> 00:29:08,046
你将有一个大数据库。

685
00:29:08,115 --> 00:29:10,582
而你将要拥有一个永久容器

686
00:29:10,651 --> 00:29:12,384
是它的容器。

687
00:29:12,452 --> 00:29:14,452
好吧。

688
00:29:14,521 --> 00:29:18,055
所以现在我有一个上下文在我手中，这个viewContext。

689
00:29:18,124 --> 00:29:19,023
我该怎么办？

690
00:29:19,091 --> 00:29:21,391
那么当然可以将对象插入到数据库中。

691
00:29:21,460 --> 00:29:23,227
我可以从数据库中删除对象。

692
00:29:23,295 --> 00:29:25,361
我可以查询数据库中的对象。

693
00:29:25,430 --> 00:29:26,662
所以，让我们来谈谈所有这些事情。

694
00:29:26,731 --> 00:29:29,765
我们从insert开始，因为直到我们插入一些

695
00:29:29,834 --> 00:29:32,267
数据库中的数据我们不能做任何其他的事情。

696
00:29:32,336 --> 00:29:35,136
以及在数据库中插入对象的方式，或

697
00:29:35,205 --> 00:29:36,538
一种方式来做，实际上是为了

698
00:29:36,607 --> 00:29:39,107
接下来的几张幻灯片我将要展示你，

699
00:29:39,175 --> 00:29:40,741
必需品

700
00:29:40,810 --> 00:29:43,843
但是，我们最终会走上高层

701
00:29:43,912 --> 00:29:46,479
以更好的方式访问这些东西。

702
00:29:46,548 --> 00:29:48,414
但我会先告诉你它的基础知识。

703
00:29:48,483 --> 00:29:51,117
所以在数据库中放一些东西的基本方法是

704
00:29:51,186 --> 00:29:53,252
用这个非常有趣的方法。

705
00:29:53,321 --> 00:29:57,923
NSEntityDescription.insertNew- Object（forEntityName：into：

706
00:29:57,991 --> 00:29:59,624
context.

707
00:29:59,693 --> 00:30:02,260
好的，这是一口气，以前更加口渴

708
00:30:02,329 --> 00:30:04,128
之前他们重命名它。

709
00:30:04,197 --> 00:30:08,366
而且你只是指定实体的名称，所以

710
00:30:08,434 --> 00:30:09,933
Tweet或TwitterUser。

711
00:30:10,002 --> 00:30:12,435
你给它一个将被视为viewContext的上下文

712
00:30:12,504 --> 00:30:13,570
你从AppDelegate得到。

713
00:30:13,639 --> 00:30:15,871
和繁荣，它将在数据库中创建其中之一。

714
00:30:15,940 --> 00:30:19,708
现在它的所有属性将为零。

715
00:30:19,777 --> 00:30:21,810
好的，虽然你可以检查属性

716
00:30:21,879 --> 00:30:24,313
数据模型编辑器并指定默认值。

717
00:30:24,381 --> 00:30:26,848
所以它可能从默认值开始。

718
00:30:26,917 --> 00:30:30,785
但是如果没有，那么他们将从零开始。

719
00:30:30,853 --> 00:30:34,055
好的，那太好了

720
00:30:34,123 --> 00:30:36,323
我现在可以创建一个。

721
00:30:36,392 --> 00:30:40,460
现在我需要设置这些var有一些价值。

722
00:30:40,529 --> 00:30:43,496
我需要设置tweet的文本和类似的东西

723
00:30:43,565 --> 00:30:46,465
我告诉过你，我会用这个关键的价值来做到这一点

724
00:30:46,534 --> 00:30:48,867
设置键值。

725
00:30:48,936 --> 00:30:53,872
所以例如我想设置让我们说文本，

726
00:30:53,941 --> 00:30:56,074
我只能说tweet。

727
00:30:56,143 --> 00:31:00,212
关键报价文字的设定值为字符串。

728
00:31:03,817 --> 00:31:06,117
你可以在这里做点符号，具有关键路径的价值。

729
00:31:06,186 --> 00:31:08,318
这就是我在绿色中显示的。

730
00:31:08,387 --> 00:31:10,754
你可以有，如果你有一个推文，你可以设置

731
00:31:10,823 --> 00:31:15,325
推特的高音名称，使用该点符号设置

732
00:31:15,394 --> 00:31:17,761
关键路径高音单元名称的值，它会通过

733
00:31:17,829 --> 00:31:20,696
tweeter关系有趣。

734
00:31:20,765 --> 00:31:23,198
我真的很快过，因为这是真的

735
00:31:23,267 --> 00:31:25,333
可怕的API

736
00:31:25,402 --> 00:31:27,502
首先在那里有任何东西

737
00:31:27,571 --> 00:31:30,070
这里没有类型检查，好吗？

738
00:31:30,139 --> 00:31:37,311
你可以说，设置关键报价文字的价值日期，好吗？

739
00:31:37,380 --> 00:31:39,480
而这将被Swift完全接受。

740
00:31:39,549 --> 00:31:43,617
日期是一个任何和引用的文本是一个字符串，但是

741
00:31:43,685 --> 00:31:46,452
当然，在运行时候会失败，好的，

742
00:31:46,521 --> 00:31:48,087
因为文本是Atring。

743
00:31:48,155 --> 00:31:50,822
所以我们不会真的使用这个API，但这是

744
00:31:50,891 --> 00:31:55,561
核心数据正在做的基本的基本方法。

745
00:31:55,629 --> 00:31:57,695
是的，键只是属性的名称，和

746
00:31:57,764 --> 00:32:00,732
值就是我们以前讨论过的一切。

747
00:32:02,769 --> 00:32:04,769
我有蓝色的使用标量类型在那里

748
00:32:04,837 --> 00:32:05,536
有趣的

749
00:32:05,604 --> 00:32:09,839
如果你放在数据库中的东西是流或者

750
00:32:09,908 --> 00:32:12,575
Int32或其中之一。

751
00:32:12,644 --> 00:32:15,678
它实际上将作为NSNumber存储在数据库中，

752
00:32:15,747 --> 00:32:16,879
这是一个类，

753
00:32:16,947 --> 00:32:20,515
这是一个对象，数字的通用持有人。

754
00:32:20,584 --> 00:32:25,320
但是如果您翻转数据中的检查器中的开关

755
00:32:25,389 --> 00:32:28,689
该属性的modeller使用标量类型，

756
00:32:28,758 --> 00:32:32,360
那么它将使类型为double或int或任何，

757
00:32:32,429 --> 00:32:33,394
而不是NSNumber，所以。

758
00:32:33,463 --> 00:32:35,596
我知道你有问题吗？

759
00:32:35,664 --> 00:32:38,298
>>是的，所以问题是，设定值拒绝

760
00:32:38,367 --> 00:32:39,799
那些类型不匹配的东西

761
00:32:39,868 --> 00:32:41,434
答案是，它不能。

762
00:32:41,502 --> 00:32:43,702
它不知道类型，类型是什么，

763
00:32:43,771 --> 00:32:46,138
只要它匹配任何 - 和所有匹配任何。

764
00:32:46,207 --> 00:32:47,939
所以，不行。

765
00:32:48,008 --> 00:32:52,577
没有办法有足够的信息拒绝。

766
00:32:52,645 --> 00:32:55,079
只要它匹配任何，它会接受它作为类型。

767
00:32:55,147 --> 00:32:56,447
然后在运行时，它会崩溃。

768
00:32:56,515 --> 00:32:59,216
如果您尝试将日期设置为字符串字段。

769
00:32:59,285 --> 00:33:03,553
所以当它像[不可数]

770
00:33:03,622 --> 00:33:06,856
保存上下文，

771
00:33:06,925 --> 00:33:09,125
你必须喜欢让它通过。

772
00:33:09,193 --> 00:33:10,293
还是吧>>去和删除。

773
00:33:10,361 --> 00:33:11,660
>> [CROSSTALK] >>你好吗

774
00:33:11,728 --> 00:33:12,794
意思是去除它吗？

775
00:33:12,863 --> 00:33:13,428
删除什么？

776
00:33:21,971 --> 00:33:23,604
是的，我们会谈谈保存这个。

777
00:33:23,673 --> 00:33:24,638
所以问题是，

778
00:33:24,707 --> 00:33:26,773
当应用程序终止它确实保存上下文和

779
00:33:26,842 --> 00:33:29,609
他们试图保存这个，我们将谈论所有关于保存

780
00:33:29,677 --> 00:33:31,944
这是一个很重要的一件事。

781
00:33:32,013 --> 00:33:35,247
这是钥匙和价值观，在那里很简单;

782
00:33:35,316 --> 00:33:38,150
其实我们现在谈谈保存。

783
00:33:38,218 --> 00:33:39,885
我们做得很好。

784
00:33:39,953 --> 00:33:43,020
所有这些变更，即使使用该设定值

785
00:33:43,089 --> 00:33:45,123
插入实体描述

786
00:33:45,191 --> 00:33:48,125
实体名称上下文，无论什么东西被调用。

787
00:33:48,194 --> 00:33:50,728
所有这些东西只发生在记忆中，

788
00:33:50,796 --> 00:33:53,796
如果你想要这样做永久地发生

789
00:33:53,865 --> 00:33:55,998
您需要保存的数据库。

790
00:33:56,067 --> 00:33:58,233
而你这样做是通过告诉上下文，

791
00:33:58,302 --> 00:34:01,370
像那个view context的东西，用save方法保存。

792
00:34:01,438 --> 00:34:04,240
它不能简单，除了它可以抛出。

793
00:34:05,910 --> 00:34:07,842
保存是一种可以抛出的方法

794
00:34:07,911 --> 00:34:10,144
也许写入数据库有一个问题。

795
00:34:10,213 --> 00:34:12,880
并且有许多可能发生写作的问题

796
00:34:12,949 --> 00:34:14,448
到数据库。

797
00:34:14,517 --> 00:34:15,882
你需要看文档和

798
00:34:15,951 --> 00:34:17,783
他们都知道他们是什么。

799
00:34:17,852 --> 00:34:20,687
但是这里的回家信息是你确实需要保存。

800
00:34:20,755 --> 00:34:23,189
如果你不保存，这种物质就会丢失

801
00:34:23,257 --> 00:34:25,324
当你的应用程序存在或什么。

802
00:34:25,393 --> 00:34:26,558
所以你绝对只是保存。

803
00:34:26,627 --> 00:34:29,627
特别是在谈论多线程核心数据时。

804
00:34:29,696 --> 00:34:30,928
一个线程正在工作。

805
00:34:30,997 --> 00:34:33,531
那个线程需要保存，如果它需要任何其他的

806
00:34:33,600 --> 00:34:36,066
线程来看它的工作。

807
00:34:36,135 --> 00:34:40,370
好的，所以你可以在这里使用try标记，记住，

808
00:34:40,439 --> 00:34:41,604
这意味着尝试和

809
00:34:41,673 --> 00:34:44,807
如果它失败，只需返回nil并忽略它。

810
00:34:44,875 --> 00:34:48,310
你可以这样做，如果你不介意它没有保存。

811
00:34:48,379 --> 00:34:50,946
而且有可能发生的事情，可以节省错误。

812
00:34:51,015 --> 00:34:53,248
你显然有文件系统问题，

813
00:34:53,317 --> 00:34:55,617
你的磁盘是满的或类似的东西。

814
00:34:55,686 --> 00:34:57,919
但你也可能有不一致之处

815
00:34:57,988 --> 00:35:01,121
数据库，也许你有冲突

816
00:35:01,190 --> 00:35:04,291
两个线程的数据尝试保存到同一个数据库，以及

817
00:35:04,359 --> 00:35:06,126
他们试图写在彼此的顶端，

818
00:35:06,194 --> 00:35:08,261
那些事情。

819
00:35:08,330 --> 00:35:10,496
再次，很多你不会有的问题，

820
00:35:10,565 --> 00:35:12,365
除非你建立一个相当复杂的，

821
00:35:12,433 --> 00:35:14,733
多线程应用程序，或类似的东西，

822
00:35:14,802 --> 00:35:17,335
但是，再次，你必须检查文档，我不能，

823
00:35:17,404 --> 00:35:19,971
我需要太长时间才能完成所有这一切。

824
00:35:21,441 --> 00:35:25,776
好的现在，正如我所说的值为Key和setValue forKey。

825
00:35:25,845 --> 00:35:29,713
真的很丑，

826
00:35:29,782 --> 00:35:32,483
我们真正想要做的是能够设置这些vars

827
00:35:32,551 --> 00:35:35,685
作为vars，我们只想要一个var被称为文本

828
00:35:35,754 --> 00:35:37,487
我们可以设置的地方

829
00:35:37,556 --> 00:35:39,521
当然，我们正在这样做。

830
00:35:39,590 --> 00:35:42,791
而我们要做的就是创建一个子类

831
00:35:42,860 --> 00:35:45,561
NSManagedObject，而不是NSManagedObject

832
00:35:45,629 --> 00:35:47,295
我们做数据库的设置值，get-value就可以了。

833
00:35:47,364 --> 00:35:51,465
相反，我们将创建一个NSManageObjects的子类

834
00:35:51,534 --> 00:35:54,635
它将在那里有vars的所有属性，

835
00:35:54,704 --> 00:35:57,971
像文字，屏幕名称和所有这些东西。

836
00:35:58,040 --> 00:36:00,307
Xcode将生成所有代码

837
00:36:00,375 --> 00:36:01,208
你幕后，

838
00:36:01,276 --> 00:36:03,676
你不必做任何工作来做到这一点。

839
00:36:03,744 --> 00:36:05,811
很简单，所以让我们来看看我们怎么做。

840
00:36:05,880 --> 00:36:09,280
您通过检查实体来做到这一点。

841
00:36:09,349 --> 00:36:11,083
所以在这里我选择了推文。

842
00:36:11,151 --> 00:36:12,316
好的，不是它的任何属性，但是

843
00:36:12,385 --> 00:36:15,786
tweet本身，我想这样做

844
00:36:15,855 --> 00:36:17,988
它产生这个魔术代码，我该怎么做？

845
00:36:18,057 --> 00:36:20,857
那么，如果你去检查员

846
00:36:20,926 --> 00:36:23,260
有一点你看到它说Codegen。

847
00:36:23,329 --> 00:36:24,760
看到Codegen，那是为了

848
00:36:24,829 --> 00:36:26,729
生成这个代码，这个魔术代码。

849
00:36:26,797 --> 00:36:29,198
现在，你其实有几个选择

850
00:36:29,267 --> 00:36:30,299
Codegen。

851
00:36:30,367 --> 00:36:33,769
默认我认为这是一个类定义。

852
00:36:33,837 --> 00:36:36,837
如果你选择这个，它将生成该子类

853
00:36:36,906 --> 00:36:38,873
你和它只会工作。

854
00:36:38,942 --> 00:36:41,809
好的，您将能够作为课堂访问您的推文

855
00:36:41,878 --> 00:36:42,543
叫做tweet

856
00:36:42,612 --> 00:36:44,744
与所有的vars。

857
00:36:44,813 --> 00:36:46,312
现在听起来不错，

858
00:36:46,381 --> 00:36:49,215
这是好的顺便说一句，如果你做这个类的定义

859
00:36:49,284 --> 00:36:52,251
codegen它不会显示在您的导航器。

860
00:36:52,320 --> 00:36:54,686
这一切都在幕后 - 你永远不会看到这个文件

861
00:36:54,755 --> 00:36:58,290
就是这个生成的codegen文件。

862
00:36:58,359 --> 00:36:59,024
所以不要找

863
00:36:59,092 --> 00:37:00,792
它在那里，如果你把这个在类定义。

864
00:37:00,861 --> 00:37:02,393
这甚至可能是默认的。

865
00:37:02,461 --> 00:37:04,028
要成为类定义可能在。

866
00:37:05,063 --> 00:37:07,030
但这里还有其他选择。

867
00:37:07,099 --> 00:37:11,200
而我们最常选择的是Category / Extension。

868
00:37:11,269 --> 00:37:15,271
顺便说一句，类别只是Objective-C字

869
00:37:15,339 --> 00:37:16,805
扩展

870
00:37:16,874 --> 00:37:20,008
Objective-C有类似于扩展名的类别。

871
00:37:20,077 --> 00:37:21,809
所以这就是为什么它说类别/扩展。

872
00:37:21,878 --> 00:37:24,845
但你可以想一想，这只是说扩展。

873
00:37:24,914 --> 00:37:28,215
这将要做的只是生成一个扩展

874
00:37:28,284 --> 00:37:30,017
的Tweet类。

875
00:37:30,085 --> 00:37:32,852
你必须真正写Tweet类本身。

876
00:37:32,921 --> 00:37:35,121
但是它只会有你的代码，或者

877
00:37:35,190 --> 00:37:36,989
如果你想要的话可​​能是空的。

878
00:37:37,058 --> 00:37:40,325
扩展将要照顾所有制作变量。

879
00:37:40,394 --> 00:37:42,061
好吧，那里的魔法魔法吧

880
00:37:43,497 --> 00:37:47,165
所以让我们来看看它是如何工作的。

881
00:37:47,234 --> 00:37:48,933
即使我切换到类别/扩展。

882
00:37:49,002 --> 00:37:51,268
再次，我没有显示该扩展

883
00:37:51,337 --> 00:37:52,035
我的导航仪

884
00:37:52,104 --> 00:37:54,838
这是你隐藏的。

885
00:37:54,907 --> 00:37:57,674
在这里我将添加扩展方式

886
00:37:57,742 --> 00:37:58,507
TwitterUser也是。

887
00:37:58,576 --> 00:38:01,176
所以他们都是Tweet和TwitterUser，我会

888
00:38:01,245 --> 00:38:07,182
有一个扩展生成，为什么我们喜欢这个？

889
00:38:07,251 --> 00:38:08,917
因为，很多次

890
00:38:08,986 --> 00:38:11,520
我们的Tweet或TwitterUser我们要添加我们自己的代码。

891
00:38:13,222 --> 00:38:14,021
喜欢在一个tweet。

892
00:38:14,089 --> 00:38:18,859
想象一下，你想添加一个采用数据的静态方法

893
00:38:18,927 --> 00:38:22,595
来自Twitter，并将其转换成数据库中的推文。

894
00:38:22,664 --> 00:38:23,930
你会把那个代码放在哪里？

895
00:38:23,998 --> 00:38:26,498
那么一个很好的地方就是在一个tweet类，

896
00:38:26,567 --> 00:38:27,699
如果有这样的事情。

897
00:38:27,768 --> 00:38:30,502
所以，你其实是要创造一个这样的事情。

898
00:38:30,571 --> 00:38:33,772
而扩展将处理所有的var业务

899
00:38:33,841 --> 00:38:34,705
为你。

900
00:38:34,774 --> 00:38:37,708
如果您选择“手动/无”，则在此处为Codegen，

901
00:38:37,777 --> 00:38:40,544
意思是不要做任何Codegen，那么你正在做值

902
00:38:40,613 --> 00:38:41,445
设置键值。

903
00:38:43,081 --> 00:38:45,682
祝你好运，代码将会是一团糟，好吗？

904
00:38:45,750 --> 00:38:48,284
所以，我们几乎总是这样做这个扩展。

905
00:38:49,654 --> 00:38:52,721
另外，如果我们使用多个模块构建我们的应用程序

906
00:38:52,789 --> 00:38:55,523
像我们在Smash Tag中一样，我们有一个框架模块

907
00:38:55,592 --> 00:38:57,158
那么我们有主模块。

908
00:38:57,227 --> 00:38:58,926
那么你可能会选择

909
00:38:58,995 --> 00:39:01,228
从这个下拉列表中可以看出模块，

910
00:39:01,297 --> 00:39:03,230
当前产品模块

911
00:39:03,299 --> 00:39:06,467
我想如果你有一个单一的应用程序没有模块化

912
00:39:06,535 --> 00:39:10,470
像这样你可能不需要设置，但是

913
00:39:10,539 --> 00:39:14,707
在您可能想要的多模式应用程序中。

914
00:39:14,776 --> 00:39:18,577
所以，因为我们选择这里只创建扩展，

915
00:39:18,646 --> 00:39:22,080
我们显然需要编写类的代码Tweet And

916
00:39:22,149 --> 00:39:25,017
TwitterUser，我们必须自己创建这些类。

917
00:39:25,085 --> 00:39:26,551
那我们怎么做呢？

918
00:39:26,619 --> 00:39:28,419
好吧，就像我们创造任何东西一样，

919
00:39:28,487 --> 00:39:30,220
我们使用文件，新文件。

920
00:39:30,289 --> 00:39:32,256
然后我们做文件，新文件，这一次我们回来了

921
00:39:32,325 --> 00:39:35,559
说这是可可触摸课，因为NSManageObject。

922
00:39:35,628 --> 00:39:37,660
为什么它的代码叫cocoa touch类，

923
00:39:37,729 --> 00:39:40,229
我们想确保我们将父类放在其中

924
00:39:40,297 --> 00:39:42,030
管理对象，对吧？

925
00:39:42,099 --> 00:39:43,665
所以，我正在创建一个叫做Tweet的类，

926
00:39:43,734 --> 00:39:46,701
你看，这是NSManagedObject的一个子类。

927
00:39:46,770 --> 00:39:48,436
并为我们创造这个。

928
00:39:48,504 --> 00:39:51,539
看到？ Class Tweet：NSManagedObject。

929
00:39:51,608 --> 00:39:52,706
那里没有代码

930
00:39:52,775 --> 00:39:56,043
那个空间是给我们的，我们会写任何我们想要的东西。

931
00:39:56,112 --> 00:39:58,778
执行vars的代码是在我们的扩展

932
00:39:58,847 --> 00:39:59,746
甚至不看，但是

933
00:39:59,815 --> 00:40:02,082
我会在这里第一次显示哟。

934
00:40:04,785 --> 00:40:07,452
请注意，我选择了这个类的名称Tweet

935
00:40:07,521 --> 00:40:09,888
与数据库中实体的名称相同，

936
00:40:09,956 --> 00:40:12,290
你想做什么

937
00:40:12,359 --> 00:40:16,027
检查实体是不可能的

938
00:40:16,096 --> 00:40:18,229
在数据模型中，但是不要这样做。

939
00:40:18,298 --> 00:40:20,231
只有具有相同名称的实体。

940
00:40:20,299 --> 00:40:22,699
阅读你的代码的人会期待这个类，

941
00:40:22,768 --> 00:40:24,400
NSManageObject的这个子类

942
00:40:24,469 --> 00:40:25,602
代表一个tweet。

943
00:40:25,670 --> 00:40:28,371
实体被称为tweet，所以称之为。

944
00:40:30,441 --> 00:40:33,708
现在我们在这里有一个错误，我刚刚创建了这个类，

945
00:40:33,777 --> 00:40:34,976
我怎么会有错误，

946
00:40:35,045 --> 00:40:36,944
我做了什么我怎么做错了什么？

947
00:40:37,013 --> 00:40:38,379
那么问题在这里呢，

948
00:40:38,448 --> 00:40:41,081
真的，Xcode做错了。

949
00:40:41,150 --> 00:40:45,685
当Xcode创建时，似乎没有意识到这一点

950
00:40:45,754 --> 00:40:47,687
NSManageObject不在UIKit中。

951
00:40:47,756 --> 00:40:50,790
你看看它如何将import UIKit放在顶部？

952
00:40:50,859 --> 00:40:54,593
真的，我们需要的是导入CoreData，好的。

953
00:40:54,662 --> 00:40:55,761
你写的所有代码，

954
00:40:55,829 --> 00:40:57,129
任何时候在CoreData中做某事，

955
00:40:57,198 --> 00:40:58,997
你必须导入CoreData。

956
00:40:59,065 --> 00:41:01,032
UIKit是一个不同的框架

957
00:41:01,101 --> 00:41:02,934
您必须将其导入到您要使用它的任何地方。

958
00:41:03,002 --> 00:41:05,235
就像我们不得不将Twitter推送到我们想要的地方

959
00:41:05,304 --> 00:41:06,937
使用我给你的Twitter框架。

960
00:41:08,507 --> 00:41:09,906
所以，我不知道为什么Xcode，我认为这只是一个监督

961
00:41:09,907 --> 00:41:11,306
好的？

962
00:41:11,376 --> 00:41:13,842
当你选择NSManagedObject时Xcode

963
00:41:13,911 --> 00:41:15,944
作为你应该知道的超级类，那就是核心数据

964
00:41:16,013 --> 00:41:17,546
它应该是导入Core Data的。

965
00:41:17,614 --> 00:41:19,714
不知道为什么不这样做。

966
00:41:19,782 --> 00:41:22,784
所以在这里我为TwitterUser类创建了一个。

967
00:41:22,852 --> 00:41:25,352
再次，你可以把任何你想要的东西放在那里。

968
00:41:25,421 --> 00:41:26,219
这是你的类。

969
00:41:26,288 --> 00:41:27,086
你可以做任何你想要的

970
00:41:27,155 --> 00:41:29,588
所有关于vars的东西都在关闭

971
00:41:29,657 --> 00:41:31,390
在某处扩展

972
00:41:31,459 --> 00:41:34,092
其实我们来看看这个扩展，

973
00:41:34,161 --> 00:41:34,910
即使它不会出现在您的下一个导航仪中

974
00:41:34,911 --> 00:41:35,660
看起来像什么

975
00:41:35,729 --> 00:41:37,127
你可能永远不会去看它。

976
00:41:37,196 --> 00:41:38,363
我以为我会显示给你的

977
00:41:38,431 --> 00:41:40,164
你明白了一些事情。

978
00:41:40,232 --> 00:41:43,300
所以，这是扩展，这是为了生成的

979
00:41:43,369 --> 00:41:43,933
TwitterUser。

980
00:41:44,002 --> 00:41:45,568
你看到这是一个扩展

981
00:41:45,637 --> 00:41:47,236
的TwitterUser类，对吧？

982
00:41:47,305 --> 00:41:52,074
记住扩展名，它有vars。

983
00:41:52,143 --> 00:41:54,643
它们不仅被定义为名称和screenName，

984
00:41:54,712 --> 00:41:57,279
它也有关系var tweets以及。

985
00:41:58,281 --> 00:41:59,012
好吧？

986
00:41:59,081 --> 00:42:01,048
看看Twitter的类型。

987
00:42:01,116 --> 00:42:03,917
如所承诺的，它是一个NSSet，它是一个可选因素

988
00:42:03,986 --> 00:42:07,153
从数据库中输出未设置。

989
00:42:07,222 --> 00:42:08,221
它会得到设置。

990
00:42:09,823 --> 00:42:11,022
所以这些是vars。

991
00:42:11,091 --> 00:42:12,224
我会谈谈一点

992
00:42:12,292 --> 00:42:17,095
这些var如何在一分钟内实际实现

993
00:42:17,164 --> 00:42:18,463
所有的var都在那里

994
00:42:18,532 --> 00:42:19,663
还有一些功能，

995
00:42:19,732 --> 00:42:20,964
现在在底部你看到这些功能，

996
00:42:21,033 --> 00:42:23,967
那些是有趣的，那些是方便的功能

997
00:42:24,036 --> 00:42:28,438
从推文集添加和删除推文

998
00:42:28,506 --> 00:42:33,876
因为NSSet是不可变的，好吗？

999
00:42:33,945 --> 00:42:36,913
这不是简单的事情，

1000
00:42:36,981 --> 00:42:40,349
NS集是一种老Objective-C方式，而NSSet，

1001
00:42:40,418 --> 00:42:44,552
像NSAttributedString一样，是不可变的，不能改变，

1002
00:42:44,621 --> 00:42:47,588
那么如何在这里添加任何推文到我的数据库？

1003
00:42:47,657 --> 00:42:50,158
那么你用这些功能代替，添加到tweets，

1004
00:42:50,226 --> 00:42:51,825
从Twitter上删除，添加到tweets，

1005
00:42:51,894 --> 00:42:55,896
从推文中删除，有一对做一个tweet，

1006
00:42:55,965 --> 00:42:58,531
还有一大堆tweets，或者

1007
00:42:58,600 --> 00:43:00,833
删除一大堆tweets，好吗？

1008
00:43:00,902 --> 00:43:03,603
所以你肯定会想要这些功能

1009
00:43:03,671 --> 00:43:04,337
你的任务五。

1010
00:43:05,840 --> 00:43:08,540
你会在你身边有一些关系

1011
00:43:08,608 --> 00:43:11,609
要使用这些功能添加它们。

1012
00:43:11,678 --> 00:43:12,643
现在它添加了这些功能

1013
00:43:12,712 --> 00:43:16,346
任何太多的关系，任何时候你有一个太多的var

1014
00:43:16,415 --> 00:43:19,549
像推文，它会自动添加这些功能

1015
00:43:19,618 --> 00:43:21,151
它实际上把它放在自己的小扩展，这个文件

1016
00:43:21,152 --> 00:43:22,685
在扩展中。

1017
00:43:22,754 --> 00:43:26,622
有两个扩展，通过TwitterUser。

1018
00:43:26,691 --> 00:43:29,825
有关任何有关扩展的问题或任何问题？

1019
00:43:29,894 --> 00:43:34,429
好的，我们来看看tweets扩展真的很快。

1020
00:43:34,498 --> 00:43:36,565
结合其他的东西来看这里，我没看

1021
00:43:36,634 --> 00:43:37,599
在另一个。

1022
00:43:37,667 --> 00:43:41,035
注意这个静态func叫做fetchRequest？

1023
00:43:41,103 --> 00:43:41,735
把你放在心里

1024
00:43:41,804 --> 00:43:43,904
我会在几张幻灯片中谈论这个。

1025
00:43:43,973 --> 00:43:46,640
fetchRequest是一个非常酷的小静态func，将会

1026
00:43:46,709 --> 00:43:50,577
给你一些可以用来获取推文的东西。

1027
00:43:50,646 --> 00:43:52,245
如果您在twitter用户上调用fetchrRquest，

1028
00:43:52,313 --> 00:43:54,213
你会得到一些东西来获取Twitter的用户。

1029
00:43:54,282 --> 00:43:57,282
我们会在这里谈谈关于抓取的一切。

1030
00:43:57,351 --> 00:44:01,886
注意高音扬声器的类型，看高音变音。

1031
00:44:01,955 --> 00:44:04,589
它的类型是TwitterUser。

1032
00:44:04,657 --> 00:44:06,324
由于当然这是高音扬声器，

1033
00:44:06,393 --> 00:44:09,494
我们控制了tweet和tweeter用户之间的拖动

1034
00:44:09,562 --> 00:44:11,929
那个高音变音器当然是一个高音用户，

1035
00:44:11,997 --> 00:44:15,432
不是NSSet，因为它是一个两个关系，好的，

1036
00:44:15,501 --> 00:44:18,301
只有一个TwitterUser，谁是我的高音。

1037
00:44:20,105 --> 00:44:23,138
这个@NSManaged呢？

1038
00:44:23,207 --> 00:44:27,009
好吧，@NSManaged我只是说这是魔术。

1039
00:44:27,077 --> 00:44:28,210
这不是真的魔术

1040
00:44:28,278 --> 00:44:33,181
这实际上是对运行时说的，嘿。

1041
00:44:33,250 --> 00:44:35,083
当有人访问这个var时

1042
00:44:35,152 --> 00:44:37,485
核心数据将为您量身定做。

1043
00:44:37,554 --> 00:44:40,053
核心数据是什么，当你试图说

1044
00:44:40,122 --> 00:44:45,058
Tweet.created等于某个日期，它被困住

1045
00:44:45,127 --> 00:44:48,228
在运行时的低级别和核心数据在和

1046
00:44:48,297 --> 00:44:51,731
确定为您设定价值，好的。

1047
00:44:51,799 --> 00:44:55,268
同样的事情，如果你得到创建的var，它在和

1048
00:44:55,337 --> 00:44:57,603
对键值有价值，并得到它。

1049
00:44:57,671 --> 00:45:01,339
但是，这一切都是在幕后的低水平上发生的。

1050
00:45:01,408 --> 00:45:05,309
所以这个扩展确实满足了扩展限制

1051
00:45:05,378 --> 00:45:06,544
它不能有任何存储。

1052
00:45:06,612 --> 00:45:09,580
这些var的所有存储都不在数据库中。

1053
00:45:10,616 --> 00:45:12,416
当你要求它

1054
00:45:12,484 --> 00:45:14,985
或者当你设置它，它使用它的值

1055
00:45:15,053 --> 00:45:17,019
键而不是键的值，将其设置在数据库中。

1056
00:45:17,088 --> 00:45:18,087
现在再次，它在记忆中。

1057
00:45:18,156 --> 00:45:19,021
你必须保存它

1058
00:45:19,090 --> 00:45:20,955
它实际上出来进入数据库。

1059
00:45:21,024 --> 00:45:25,159
但是发生了什么。

1060
00:45:25,228 --> 00:45:29,130
好的，所以

1061
00:45:29,199 --> 00:45:34,334
现在我们有这些课，所以这里有一些

1062
00:45:34,403 --> 00:45:39,206
代码创建一个推文并设置它的属性，好的

1063
00:45:39,274 --> 00:45:41,875
我们来看看这一块，看看它做了什么。

1064
00:45:41,943 --> 00:45:45,078
首先是创建一个鸣叫，我们不必这样做

1065
00:45:45,146 --> 00:45:49,449
NSEntityDescription，Entity，插入实体名称

1066
00:45:49,517 --> 00:45:52,318
联系人，或任何巨大的，可怕的事情是 -

1067
00:45:52,386 --> 00:45:55,421
我们可以说，推文，括号上下文。

1068
00:45:55,489 --> 00:45:58,223
你只是说什么上下文，这意味着什么数据库你

1069
00:45:58,292 --> 00:46:00,859
想要推送推文，并创建一个新的推文。

1070
00:46:00,928 --> 00:46:03,994
好的，只需使用一个普通的初始化器即可

1071
00:46:04,063 --> 00:46:05,496
新的东西，这样超酷。

1072
00:46:05,565 --> 00:46:07,364
那是那里最酷的功能之一。

1073
00:46:07,432 --> 00:46:09,666
不用使用NSEntityDescription的东西，所以

1074
00:46:09,735 --> 00:46:13,002
没有更多的NSEntityDescription，我们不必这样做。

1075
00:46:13,071 --> 00:46:13,769
然后在这里，

1076
00:46:13,838 --> 00:46:18,107
我设置的文字是140个字符的纯粹的喜悦。

1077
00:46:18,175 --> 00:46:21,176
而且我不用说设定值为140个字符

1078
00:46:21,244 --> 00:46:24,646
喜欢关键文字，并拥有所有这些文字字符串

1079
00:46:24,715 --> 00:46:28,016
在这个无类型的东西里面的文字。

1080
00:46:28,084 --> 00:46:29,918
我只是说tweet.text等于。

1081
00:46:29,986 --> 00:46:33,620
同样的事情在这里创造，再次，所以我们不

1082
00:46:33,689 --> 00:46:36,857
甚至要担心的事情，如果我们试图说

1083
00:46:36,926 --> 00:46:41,228
tweet.created等于引用你好，这个Swift会说，

1084
00:46:41,297 --> 00:46:44,330
不，创建的是Date类型，所以你不能这样做

1085
00:46:44,399 --> 00:46:46,899
它发现我们所有的，它类型检查一切，

1086
00:46:46,968 --> 00:46:49,801
找到我们所有可能的错误。

1087
00:46:49,870 --> 00:46:52,170
关系，好吧，设置关系怎么样？

1088
00:46:52,239 --> 00:46:56,675
所以在这里我创建了另一个对象，一个TwitterUser和

1089
00:46:56,743 --> 00:46:59,144
再次我只是设置了一个上下文的TwitterUser，

1090
00:46:59,212 --> 00:47:01,111
我会马上谈论这个参数

1091
00:47:01,180 --> 00:47:06,050
我告诉我要在TwitterUser中创建什么数据库

1092
00:47:06,118 --> 00:47:10,588
我把tweet的tweeter设置成等于那个TwitterUser。

1093
00:47:10,656 --> 00:47:12,522
所以，这正是你的意思，想像吧？

1094
00:47:12,591 --> 00:47:14,290
只要设置等于Joe。

1095
00:47:14,359 --> 00:47:18,794
有趣的是，当你设置一个

1096
00:47:18,863 --> 00:47:22,865
一方的关系，另一方得到更新

1097
00:47:22,934 --> 00:47:26,001
自动，100％的时间。

1098
00:47:26,070 --> 00:47:27,369
这是调用维护

1099
00:47:27,438 --> 00:47:30,038
数据库的完整性好吗？

1100
00:47:30,106 --> 00:47:33,341
核心数据始终保持数据库的完整性。

1101
00:47:33,410 --> 00:47:35,543
所以，当你改变一方关系时

1102
00:47:35,611 --> 00:47:36,710
它改变了另一个。

1103
00:47:36,779 --> 00:47:39,546
所以，这意味着例如如果我说tweet.tweeter

1104
00:47:39,614 --> 00:47:42,282
等于乔，那么如果我去乔边

1105
00:47:42,350 --> 00:47:46,152
说嘿，给我乔的推文，我甚至会转过来

1106
00:47:46,220 --> 00:47:49,855
成为从NSSet到一组的Swift类

1107
00:47:49,924 --> 00:47:52,291
推特是因为我们知道这是什么推特，对吧？

1108
00:47:52,360 --> 00:47:56,461
推文是一组推文，所以我会这样做。

1109
00:47:56,530 --> 00:48:00,365
然后我可以说，如果乔的推文包含那个推文打印是的

1110
00:48:00,434 --> 00:48:02,533
当然打印是的。

1111
00:48:02,602 --> 00:48:05,002
因为当我说tweet.tweeter = joe时，

1112
00:48:05,071 --> 00:48:07,538
它自动添加到joe的推文。

1113
00:48:08,573 --> 00:48:09,238
懂了吗?

1114
00:48:09,307 --> 00:48:10,640
同样的事情，另一种方式。

1115
00:48:10,709 --> 00:48:13,375
如果我在乔的推文中添加了一个推文，

1116
00:48:13,444 --> 00:48:16,112
那个tweet高音扬声器会自动设置为joe。

1117
00:48:17,614 --> 00:48:18,546
好的？双方将永远

1118
00:48:18,615 --> 00:48:19,614
指向对方。

1119
00:48:19,682 --> 00:48:21,482
你不必做任何事情来做到这一点。

1120
00:48:23,086 --> 00:48:27,688
tweet.tweeter = joe是正确的

1121
00:48:27,756 --> 00:48:30,623
同样的说，joe dot addToTweets tweet。

1122
00:48:30,692 --> 00:48:32,959
记住addToTweets是其中一个方便的功能

1123
00:48:33,027 --> 00:48:34,427
它为我们在那里创造了。

1124
00:48:35,763 --> 00:48:37,529
现在，请注意我用的参数

1125
00:48:37,598 --> 00:48:40,398
在那里创建Twitter用户的上下文。

1126
00:48:40,467 --> 00:48:43,434
我没有说AppDelegate.viewContext。

1127
00:48:43,503 --> 00:48:45,502
我没有使用与我相同的上下文吧。

1128
00:48:45,571 --> 00:48:47,537
我说tweet.manageObjectContext。

1129
00:48:47,606 --> 00:48:51,107
换句话说，我得到了，我发现tweet是什么数据库

1130
00:48:51,176 --> 00:48:53,977
我把Twitter用户放在同一个数据库中。

1131
00:48:54,046 --> 00:48:57,212
这是Core Data中常见的编程方式

1132
00:48:57,281 --> 00:48:59,148
当你想要得到一个上下文的时候

1133
00:48:59,217 --> 00:49:01,717
你已经在数据库中有一个对象了

1134
00:49:01,786 --> 00:49:04,786
问对象你已经有了什么上下文使用。

1135
00:49:04,855 --> 00:49:08,256
你可以看到，如果我改变我的代码不放这个

1136
00:49:08,325 --> 00:49:12,059
至少在这种情况下，把它放在另一个上下文中

1137
00:49:12,128 --> 00:49:14,695
Twitter用户和tweet将始终在一起

1138
00:49:14,764 --> 00:49:16,330
无论这种情况如何。

1139
00:49:16,399 --> 00:49:18,865
所以你可以看到为什么我用的tweets不能

1140
00:49:18,934 --> 00:49:22,702
管理对象上下文，以创建而不是使用

1141
00:49:22,771 --> 00:49:24,170
再一次上下文。

1142
00:49:24,239 --> 00:49:26,905
所以，它会工作说上下文，当然，

1143
00:49:26,974 --> 00:49:30,575
但我只是说有一个发展的范式

1144
00:49:30,644 --> 00:49:33,612
我们将尝试使用相关对象的上下文。

1145
00:49:33,680 --> 00:49:35,480
所以他们肯定会在同一个数据库中。

1146
00:49:37,150 --> 00:49:37,715
好的？

1147
00:49:39,385 --> 00:49:41,351
好的，所以

1148
00:49:41,420 --> 00:49:44,821
我们也可以使用点符号，因为这些只是vars。

1149
00:49:44,889 --> 00:49:47,723
所以当我说tweet.tweeter，我得到一个TwitterUser对象。

1150
00:49:47,792 --> 00:49:50,059
所以，当然可以说点名称

1151
00:49:50,128 --> 00:49:52,228
设置等于Joe Schmo，无论如何？

1152
00:49:52,296 --> 00:49:57,266
tweet.tweeter.name =“Joe Schmo”，好吗？

1153
00:49:57,334 --> 00:49:59,134
没有限制那些vars。

1154
00:50:00,703 --> 00:50:03,337
好的，记得我告诉过你有关标量吗？

1155
00:50:03,406 --> 00:50:06,240
这是我之前告诉你的那个转换。

1156
00:50:06,309 --> 00:50:09,777
如果你不这样做，那么当你说，

1157
00:50:09,845 --> 00:50:13,313
如果你有一个int，我们假设你已经转发了

1158
00:50:13,382 --> 00:50:17,950
这是int int的一个int这里让我们说Int32。

1159
00:50:18,019 --> 00:50:19,185
如果不切换此按钮，

1160
00:50:19,253 --> 00:50:22,188
那么这将是一个NSNumber不是Int32。

1161
00:50:22,256 --> 00:50:24,489
但是当您单击此开关时，

1162
00:50:24,558 --> 00:50:26,958
现在var将是Int32类型。

1163
00:50:27,027 --> 00:50:28,893
所以你几乎总是想要这个数字。

1164
00:50:28,962 --> 00:50:32,296
99.9％的时间，你想打开这个开关。

1165
00:50:32,365 --> 00:50:33,964
幸运的是，默认情况下是这样

1166
00:50:34,033 --> 00:50:36,065
你甚至不必考虑很多，但是

1167
00:50:36,134 --> 00:50:37,300
我只想让你知道。

1168
00:50:38,736 --> 00:50:40,970
好的，现在让我们谈谈删除。

1169
00:50:41,038 --> 00:50:44,773
好的，现在我想从数据库中删除一些东西。

1170
00:50:44,842 --> 00:50:46,641
这很容易，

1171
00:50:46,710 --> 00:50:50,378
几乎太容易，因为你的数据宝贵你不想要

1172
00:50:50,447 --> 00:50:53,547
要删除它很容易，但你这样做的问

1173
00:50:53,616 --> 00:50:56,851
上下文删除NSManagedObject，所以可以

1174
00:50:56,919 --> 00:50:59,920
将任何NSManagedObject传递给此方法delete和

1175
00:50:59,989 --> 00:51:02,189
它将从数据库中删除它。

1176
00:51:02,258 --> 00:51:05,325
它也可以级联和删除其他的东西

1177
00:51:05,393 --> 00:51:08,161
取决于删除规则是什么，好吗？

1178
00:51:08,230 --> 00:51:11,530
大多数时候默认情况下，当我删除某些东西时，

1179
00:51:11,599 --> 00:51:15,067
其他指向它的东西会使该指针设置为nil。

1180
00:51:15,136 --> 00:51:18,036
这是无效的删除规则。

1181
00:51:18,105 --> 00:51:20,038
现在，当它们从数据库中删除时

1182
00:51:20,107 --> 00:51:23,541
先发送此消息，准备删除。

1183
00:51:23,610 --> 00:51:26,177
好的，这是一个很好的方法。

1184
00:51:26,245 --> 00:51:28,812
再次，在这里你不必做任何事情

1185
00:51:28,881 --> 00:51:31,748
担心其他指针指向你

1186
00:51:31,817 --> 00:51:33,583
这一切都由删除规则修复。

1187
00:51:33,652 --> 00:51:36,919
但是如果您的数据库中有另一个字段怎么办？

1188
00:51:36,988 --> 00:51:39,421
再次返回转发计数示例。

1189
00:51:39,490 --> 00:51:43,592
假设我在TwitterUser中有一个int，

1190
00:51:43,661 --> 00:51:46,227
其中计算了转发数量

1191
00:51:46,296 --> 00:51:48,296
这个Twitter用户已经做了。

1192
00:51:48,365 --> 00:51:51,065
所以如果我删除一个tweet，它恰好是

1193
00:51:51,133 --> 00:51:54,902
然后我需要设置为负相等。

1194
00:51:54,971 --> 00:51:56,636
这里是完美的地方。

1195
00:51:56,705 --> 00:51:58,372
所以鸣叫，它的准备

1196
00:51:58,441 --> 00:52:00,507
删除说哎，我即将被删除。

1197
00:52:00,575 --> 00:52:03,376
我最好告诉我的Twitter用户，我是转发者，

1198
00:52:03,444 --> 00:52:07,013
他需要减少他的转发计数。

1199
00:52:07,081 --> 00:52:09,381
所以你明白为什么要使用准备删除？

1200
00:52:09,449 --> 00:52:11,416
这是一种在数据库中更新其他内容的方式

1201
00:52:11,485 --> 00:52:14,252
当你离开数据库时。

1202
00:52:15,855 --> 00:52:17,955
好的，所以这是删除。

1203
00:52:18,023 --> 00:52:19,789
下一主题，查询，

1204
00:52:19,858 --> 00:52:22,158
这是整个数据库中最重要的一件事情。

1205
00:52:22,227 --> 00:52:24,294
如果你这样做，这真的是浪费时间

1206
00:52:24,362 --> 00:52:24,961
不会查询，好吗？

1207
00:52:25,029 --> 00:52:28,831
如果你不会提出复杂的请求

1208
00:52:28,900 --> 00:52:32,767
基于关系的信息等

1209
00:52:32,836 --> 00:52:36,238
所以，做一个查询最重要的事情你需要

1210
00:52:36,306 --> 00:52:40,475
知道是NSFetchRequest，这个类NSFetchRequest。

1211
00:52:40,544 --> 00:52:43,077
NSFetchRequest封装

1212
00:52:43,146 --> 00:52:45,946
你想要的数据库。

1213
00:52:46,015 --> 00:52:47,915
所以我们来讨论一个NSFetchRequest和

1214
00:52:47,984 --> 00:52:51,351
我们如何建立一个。

1215
00:52:51,420 --> 00:52:52,552
所以当我们建立一个，

1216
00:52:52,621 --> 00:52:54,487
我们需要知道三件重要的事情。

1217
00:52:54,556 --> 00:52:57,323
一，我们拿什么实体？

1218
00:52:57,391 --> 00:53:01,626
因为FetchRequest只能获取一种实体。

1219
00:53:01,695 --> 00:53:03,962
你可以，没有这样的东西，FetchRequest将给予

1220
00:53:04,031 --> 00:53:06,565
你有一些推特和一些Twitter用户。

1221
00:53:06,633 --> 00:53:07,464
不，好吗

1222
00:53:07,533 --> 00:53:09,700
提取总是给你所有的tweets或

1223
00:53:09,769 --> 00:53:12,136
所有Twitter用户都有意义吗？

1224
00:53:12,205 --> 00:53:13,070
这是第一件事，

1225
00:53:13,139 --> 00:53:14,905
我们将要创建提取请求。

1226
00:53:14,973 --> 00:53:17,606
它将是一个提取请求或一个非常具体的实体。

1227
00:53:17,675 --> 00:53:20,576
而且只能获取这些实体。

1228
00:53:20,645 --> 00:53:24,446
第二件事是一系列排序描述符。

1229
00:53:24,515 --> 00:53:25,647
为什么要这样呢？

1230
00:53:25,716 --> 00:53:29,017
因为当我们执行这个抓取它会回来

1231
00:53:29,086 --> 00:53:31,151
作为一个数组，好吗？

1232
00:53:31,220 --> 00:53:32,753
所有匹配的tweets或

1233
00:53:32,822 --> 00:53:34,888
Twitter用户将回到阵列中。

1234
00:53:34,957 --> 00:53:35,922
而且由于它是一个数组，

1235
00:53:35,991 --> 00:53:39,693
数组不是集合，数组是有序的等等

1236
00:53:39,761 --> 00:53:42,361
我们已经在数组中指定了什么顺序。

1237
00:53:42,430 --> 00:53:44,830
所以我们用这些排序描述符来做。

1238
00:53:44,898 --> 00:53:47,833
最后，我们只是指定或想要什么，

1239
00:53:47,902 --> 00:53:51,236
我们想要哪些推文，我们想要的Twitter用户

1240
00:53:51,305 --> 00:53:53,971
我们用称为谓词的东西来做。

1241
00:53:54,040 --> 00:53:55,039
好吧，让我们来吧

1242
00:53:55,107 --> 00:53:57,174
看看这三件事情。

1243
00:53:57,243 --> 00:53:58,575
这就是它的样子

1244
00:53:58,644 --> 00:54:00,777
有点顶级创建一个提取请求。

1245
00:54:00,846 --> 00:54:02,479
好的，你得到一个提取请求。

1246
00:54:02,547 --> 00:54:04,447
您设置源描述符并设置其谓词。

1247
00:54:04,516 --> 00:54:07,016
所以你得到这三个部分。

1248
00:54:07,085 --> 00:54:08,650
所以获取提取请求很容易。

1249
00:54:08,719 --> 00:54:10,852
我们要使用这么小的静态功能

1250
00:54:10,921 --> 00:54:14,455
我所说的延伸是为了

1251
00:54:14,524 --> 00:54:16,223
我们称为fetchRequest。

1252
00:54:16,292 --> 00:54:19,127
现在，这是Swift的极少数之一

1253
00:54:19,195 --> 00:54:22,830
不能推断此返回值的类型。

1254
00:54:24,132 --> 00:54:26,500
应该把它放在红色，好吗？

1255
00:54:26,568 --> 00:54:27,133
因为是这样

1256
00:54:27,202 --> 00:54:29,568
很少，斯威夫特几乎可以推断事情。

1257
00:54:29,637 --> 00:54:31,169
但是反过来呢NSManagedObject

1258
00:54:31,238 --> 00:54:34,506
有一个fetchRequest方法，它返回更通用

1259
00:54:34,574 --> 00:54:37,108
一种fetchRequest，所以当你得到它，

1260
00:54:37,177 --> 00:54:39,610
它不太了解你想要哪一个。

1261
00:54:39,679 --> 00:54:41,579
所以当你问一个Tweet

1262
00:54:41,648 --> 00:54:44,582
它的提取请求在这里，你必须告诉它是你

1263
00:54:44,650 --> 00:54:48,318
想要一个在Tweet不是一个父类？

1264
00:54:48,387 --> 00:54:48,884
好吧？所以

1265
00:54:48,953 --> 00:54:51,186
说let request等于NSFetchRequest。

1266
00:54:51,255 --> 00:54:53,756
这是一个类似数组的泛型类似的东西，对吧？

1267
00:54:53,825 --> 00:54:55,958
这是仅针对推文的提取请求。

1268
00:54:56,026 --> 00:54:58,594
所以你说NSFetchRequest <tweet> =

1269
00:54:58,662 --> 00:55:00,595
Tweet.fetchRequest()。

1270
00:55:00,664 --> 00:55:02,396
当然，它知道，

1271
00:55:02,465 --> 00:55:05,900
那只能返回NSFetchRequest的那个

1272
00:55:05,968 --> 00:55:09,003
推文是fetchRequest，这是Tweet的扩展。

1273
00:55:11,106 --> 00:55:12,439
所以现在，你有一个fetchRequest，

1274
00:55:12,507 --> 00:55:14,741
这是您如何获取提取请求 - 不容易。

1275
00:55:14,809 --> 00:55:17,442
你只需要记住做静态

1276
00:55:17,511 --> 00:55:19,378
在那里打字

1277
00:55:19,446 --> 00:55:21,446
好的，现在我们需要sortDescriptor吧？

1278
00:55:21,515 --> 00:55:22,947
这个数组回来了

1279
00:55:23,016 --> 00:55:25,516
他们会做什么顺序？

1280
00:55:25,585 --> 00:55:27,851
SortDescriptor看起来像这样。

1281
00:55:27,920 --> 00:55:29,352
你用钥匙创建它。

1282
00:55:29,421 --> 00:55:32,188
那是关键，属性在

1283
00:55:32,257 --> 00:55:35,258
您要排序的数据库，因此屏幕名称或

1284
00:55:35,327 --> 00:55:38,828
甚至在短信中的文本或实际名称

1285
00:55:38,897 --> 00:55:40,896
高音扬声器，无论它会是什么。

1286
00:55:40,965 --> 00:55:42,230
在这里，sortDescriptor，

1287
00:55:42,299 --> 00:55:45,867
将是一个仅适用于抓取Twitter的排序描述符

1288
00:55:45,936 --> 00:55:49,471
用户，因为screenName是Twitter用户的关键，

1289
00:55:49,540 --> 00:55:51,906
不是在tweet，所以我们要使用这个SortDescriptor

1290
00:55:51,975 --> 00:55:53,641
在tweet请求。

1291
00:55:53,709 --> 00:55:55,175
我说，因为在上一张幻灯片中，

1292
00:55:55,244 --> 00:55:57,611
我刚刚向您展示了如何提出推文请求。

1293
00:55:57,680 --> 00:55:59,312
无论如何，我应该是，应该是Twitter用户。

1294
00:55:59,381 --> 00:56:01,648
但无论如何，所以这是一个Twitter用户。

1295
00:56:01,716 --> 00:56:02,781
SortDescriptor。

1296
00:56:02,850 --> 00:56:05,951
并注意它像我们A到Z或者升序或降序

1297
00:56:06,020 --> 00:56:10,588
Z到A然后它有这个参数选择器和

1298
00:56:10,657 --> 00:56:13,458
这会造成一些混乱。

1299
00:56:13,527 --> 00:56:15,859
但是这个选择器真的说，

1300
00:56:15,928 --> 00:56:20,497
我将使用什么方法来比较项目来做排序。

1301
00:56:20,566 --> 00:56:24,735
现在，您甚至不需要指定选择器

1302
00:56:24,804 --> 00:56:26,837
如果你不想和

1303
00:56:26,906 --> 00:56:29,906
几乎所有的数据类型，数字，

1304
00:56:29,975 --> 00:56:34,410
日期，它将使用一种称为比较的方法，好的。

1305
00:56:34,479 --> 00:56:38,747
比较返回一个叫做比较结果的东西

1306
00:56:38,816 --> 00:56:41,450
这是，它是一样的，它比或更大

1307
00:56:41,518 --> 00:56:42,084
它不到

1308
00:56:42,153 --> 00:56:43,618
所以，这是比较方法。

1309
00:56:43,687 --> 00:56:44,885
它是按日期实现的。

1310
00:56:44,954 --> 00:56:46,187
它由Int32实现。

1311
00:56:46,256 --> 00:56:47,888
它实现了double。

1312
00:56:47,957 --> 00:56:49,823
它甚至通过字符串来实现。

1313
00:56:49,892 --> 00:56:50,724
好的？所以，

1314
00:56:50,793 --> 00:56:52,358
你可以使用比较。

1315
00:56:52,427 --> 00:56:54,594
但是，对于字符串。

1316
00:56:54,662 --> 00:56:56,695
你想想一点点什么样的

1317
00:56:56,764 --> 00:56:57,895
你想要比较吗？

1318
00:56:57,964 --> 00:57:01,233
你想区分大小写比较吗？

1319
00:57:01,301 --> 00:57:03,734
或者甚至可以使用这个特殊的比较，

1320
00:57:03,803 --> 00:57:05,736
称为localStandardCompare。

1321
00:57:05,805 --> 00:57:06,737
这将比较它们

1322
00:57:06,806 --> 00:57:09,573
它的来源就像Mac上的finder一样。

1323
00:57:09,641 --> 00:57:11,575
而Mac上的finder是什么呢？

1324
00:57:11,643 --> 00:57:12,942
比不区分大小写？

1325
00:57:13,010 --> 00:57:15,444
那么，像变音符号这样的事情有很多问题

1326
00:57:15,513 --> 00:57:17,912
标记，你知道，

1327
00:57:17,981 --> 00:57:20,616
在当地语言中的东西有所不同，

1328
00:57:20,684 --> 00:57:23,284
取决于你所使用的语言，它是什么语言环境。

1329
00:57:23,353 --> 00:57:25,419
你有时候会忽略变音符号，

1330
00:57:25,488 --> 00:57:26,320
喜欢口音。

1331
00:57:26,389 --> 00:57:28,154
有时他们意味着什么。

1332
00:57:28,223 --> 00:57:31,992
而且，所以本地化的标准比较是一个特别的比较

1333
00:57:32,061 --> 00:57:35,194
对于字符串，知道如何做到这一点，好吗？

1334
00:57:35,263 --> 00:57:38,197
这通常是我们将用于字符串的。

1335
00:57:38,266 --> 00:57:39,832
当我们在我们的UI中显示某些东西时，

1336
00:57:39,901 --> 00:57:42,334
也许这个数组的东西要取，

1337
00:57:42,403 --> 00:57:43,168
我们将把它放在用户界面中。

1338
00:57:43,237 --> 00:57:44,769
我们希望它顺序，

1339
00:57:44,838 --> 00:57:46,304
这个localStandardCompare。

1340
00:57:46,372 --> 00:57:50,374
你注意到这是一个NSString点法。

1341
00:57:50,443 --> 00:57:53,343
它不是String.localizedStandardComp-

1342
00:57:53,412 --> 00:57:55,679
这是因为这必须是Objective-C可见的方法。

1343
00:57:55,680 --> 00:57:57,947
是。和

1344
00:57:58,950 --> 00:58:01,584
而您需要NSString版本。

1345
00:58:01,652 --> 00:58:03,285
所以基本上你会说NSString点，和

1346
00:58:03,354 --> 00:58:07,522
你可以去看看，搜索在NSString或string中比较，

1347
00:58:07,591 --> 00:58:09,690
因为一个字符串也实现它们，但是

1348
00:58:09,759 --> 00:58:12,393
你需要NSString点，然后是方法的名称。

1349
00:58:12,462 --> 00:58:14,995
你可以搜索，并且有不区分大小写和

1350
00:58:15,064 --> 00:58:18,232
标准比较然后定期比较等

1351
00:58:18,301 --> 00:58:22,335
现在另外一件事是，

1352
00:58:22,404 --> 00:58:27,273
这些方法中有些是特别的，

1353
00:58:27,342 --> 00:58:32,211
它在数据库方面比较好，好的。

1354
00:58:32,280 --> 00:58:36,082
使用SQL来做，看看我在说什么？

1355
00:58:36,150 --> 00:58:39,251
实际上并没有把所有的数据都带回来。

1356
00:58:39,320 --> 00:58:41,786
在每个字符串上调用此方法，

1357
00:58:41,855 --> 00:58:43,989
做某种quicksort或某事。

1358
00:58:44,057 --> 00:58:46,690
它使用超强大的排序机制

1359
00:58:46,759 --> 00:58:48,993
内置到一个SQL数据库，好的。

1360
00:58:49,062 --> 00:58:52,896
所以，事实上，所有的NSString都会这样做。

1361
00:58:52,965 --> 00:58:56,834
好的，所以他们是超级笨蛋的效率。

1362
00:58:56,902 --> 00:59:00,537
现在，如果你想使用自己的比较，

1363
00:59:00,606 --> 00:59:01,971
它不会有效率。

1364
00:59:02,040 --> 00:59:02,838
因为它必须要

1365
00:59:02,906 --> 00:59:05,674
将数据库中的所有数据带入您的内存

1366
00:59:05,743 --> 00:59:07,509
它可以运行你的小方法。

1367
00:59:07,578 --> 00:59:08,776
所以我强烈推荐

1368
00:59:08,845 --> 00:59:11,479
反对在这里使用你自己的选择。

1369
00:59:11,548 --> 00:59:13,413
我会使用标准选择器。

1370
00:59:13,482 --> 00:59:14,548
如果你要使用你自己的选择器

1371
00:59:14,617 --> 00:59:16,449
它必须在一个相当小的数据集。

1372
00:59:16,518 --> 00:59:20,487
Cuz不会很有效率。

1373
00:59:22,123 --> 00:59:24,423
请注意，当我们执行提取请求时，

1374
00:59:24,492 --> 00:59:26,759
我们不只是给它一个排序描述符，

1375
00:59:26,828 --> 00:59:29,427
我们给它一个排序描述符的数组。

1376
00:59:29,496 --> 00:59:33,632
那是旧的名字，然后是名字。

1377
00:59:33,700 --> 00:59:34,432
对？因此，如果

1378
00:59:34,501 --> 00:59:37,167
我们在那里有12个史密斯，我们会对他们进行排序

1379
00:59:37,236 --> 00:59:38,936
史密斯将在正确的地方。

1380
00:59:39,005 --> 00:59:40,870
然后是史密斯的所有名字

1381
00:59:40,939 --> 00:59:41,971
将按顺序。

1382
00:59:42,040 --> 00:59:44,240
所以我们可以有一个这样的分类

1383
00:59:44,308 --> 00:59:45,675
事情，分类下一件事，

1384
00:59:45,744 --> 00:59:47,476
接下来的事情。

1385
00:59:47,544 --> 00:59:50,612
基本上，我们可以打破后续排序的关系

1386
00:59:50,681 --> 00:59:53,749
这就是为什么我们给出一个排序描述符的数组。

1387
00:59:56,619 --> 01:00:00,688
好的，那就是抓取请求

1388
01:00:00,757 --> 01:00:02,790
它的排序描述符和现在的谓词。

1389
01:00:02,858 --> 01:00:06,192
好的，这个谓语是说Twitter的做法

1390
01:00:06,261 --> 01:00:06,993
我们想要。

1391
01:00:07,062 --> 01:00:08,962
我们想要哪些Twitter用户？

1392
01:00:09,030 --> 01:00:12,031
我们用一些有趣的API创建它们。

1393
01:00:12,099 --> 01:00:17,069
它看起来很像printf来自C.

1394
01:00:17,137 --> 01:00:20,672
NSPredicate格式为冒号，然后是一个字符串。

1395
01:00:20,740 --> 01:00:23,008
而字符串是格式字符串。

1396
01:00:23,076 --> 01:00:24,608
再次，看起来很像printf。

1397
01:00:24,677 --> 01:00:28,045
所以解释这个的最好办法可能就是这个例子。

1398
01:00:28,114 --> 01:00:30,114
但是你要学习的方式是你要走了

1399
01:00:30,182 --> 01:00:33,884
阅读NSPredicate的文档，你必须走了

1400
01:00:33,953 --> 01:00:37,053
阅读该文档，在其类文档中，

1401
01:00:37,122 --> 01:00:39,856
会有一个链接说，创造谓词，

1402
01:00:39,924 --> 01:00:42,858
或者类似的东西，点击那个，然后去那里

1403
01:00:42,927 --> 01:00:45,327
学习所有可以放在这个格式字符串中的东西，

1404
01:00:45,396 --> 01:00:48,497
cuz这是非常具体的数据库查询，但是

1405
01:00:48,566 --> 01:00:49,631
我会给你一些例子，所以

1406
01:00:49,700 --> 01:00:51,666
你知道这里发生了什么。

1407
01:00:51,735 --> 01:00:53,067
所以这是第一个，

1408
01:00:53,136 --> 01:00:54,935
我们有一个叫做foo的搜索字符串。

1409
01:00:58,207 --> 01:01:00,039
所有这些搜索，然后我会在这里做

1410
01:01:00,108 --> 01:01:01,307
是tweet搜索。

1411
01:01:01,375 --> 01:01:04,710
这些是用于搜索推文的谓词。

1412
01:01:04,778 --> 01:01:08,113
首先，我会找到所有的文字，

1413
01:01:08,182 --> 01:01:11,617
实际的鸣叫，140个字符的纯粹喜悦或

1414
01:01:11,685 --> 01:01:14,151
任何，包含区分大小写。

1415
01:01:14,220 --> 01:01:15,320
案例不敏感

1416
01:01:15,388 --> 01:01:18,222
这就是[c]的意思。

1417
01:01:18,290 --> 01:01:20,624
％@。 ％@是一个替代变量，

1418
01:01:20,693 --> 01:01:22,659
最后我必须给它的价值。

1419
01:01:22,728 --> 01:01:25,328
所以我替换搜索字符串。

1420
01:01:25,397 --> 01:01:28,298
好的，请注意，我不能说，文字包含foo。

1421
01:01:28,367 --> 01:01:32,902
我不得不说，文本包含％@然后。

1422
01:01:32,971 --> 01:01:35,037
把东西放在那边。

1423
01:01:35,106 --> 01:01:36,237
好的，这是一个很明显的一个，

1424
01:01:36,306 --> 01:01:38,739
我正在搜索包含foo的所有tweets。

1425
01:01:38,808 --> 01:01:41,309
这个怎么样？

1426
01:01:41,378 --> 01:01:46,213
我想要所有的tweets的高音单元等于％@。

1427
01:01:46,282 --> 01:01:48,615
我将Joe放在那里作为替代变量

1428
01:01:48,684 --> 01:01:52,986
并在我创建的某个日期之后创建。

1429
01:01:54,155 --> 01:01:56,489
看到那个我正在使用更大

1430
01:01:56,557 --> 01:01:57,556
而不是这样做。

1431
01:01:57,625 --> 01:01:59,324
我正在做&&为，

1432
01:01:59,393 --> 01:02:01,326
你也可以使用这个词和那里。

1433
01:02:02,295 --> 01:02:03,094
好的？所以这一切都会成为

1434
01:02:03,163 --> 01:02:05,129
自该日起，Joe创建的推文。

1435
01:02:07,199 --> 01:02:09,198
您开始查看构建查询的权限

1436
01:02:09,267 --> 01:02:10,133
进入数据库，对吧？

1437
01:02:10,202 --> 01:02:12,601
如果我有数以千计的推文，那真的很容易找到

1438
01:02:12,670 --> 01:02:14,570
例如从昨天开始。

1439
01:02:14,639 --> 01:02:16,839
我会在这里告诉你一秒钟。

1440
01:02:16,907 --> 01:02:21,910
A然后我也可以，但是通过点符号搜索，

1441
01:02:21,979 --> 01:02:23,844
在其他领域，在其他实体，但

1442
01:02:23,913 --> 01:02:28,616
这个tweeter.screenName等于百分号@符号％@与CS193P，

1443
01:02:28,684 --> 01:02:30,617
这仍然在搜索tweet。

1444
01:02:30,686 --> 01:02:31,185
这正在寻找

1445
01:02:31,253 --> 01:02:34,621
tweet的tweets的屏幕名称是CS193P。

1446
01:02:34,689 --> 01:02:37,056
你看到它在做什么吗？

1447
01:02:37,125 --> 01:02:38,557
这仍然是一个tweet谓词。

1448
01:02:38,626 --> 01:02:41,060
这不是一个twitter用户谓词。

1449
01:02:41,996 --> 01:02:43,094
好的？

1450
01:02:43,163 --> 01:02:45,263
所以这里有一个不同的谓词。

1451
01:02:45,332 --> 01:02:47,932
这是一个Twitter用户。

1452
01:02:48,001 --> 01:02:49,234
所以在这里我正在寻找所有的Twitter用户

1453
01:02:49,235 --> 01:02:50,468
好的？

1454
01:02:52,438 --> 01:02:56,506
谁的一个Tweet的文本包含foo。

1455
01:02:57,743 --> 01:02:58,708
好的？

1456
01:02:58,777 --> 01:03:01,009
所以它甚至知道如何做多元化

1457
01:03:01,078 --> 01:03:03,278
搜索在这里你有Twitter的点文字的意思

1458
01:03:03,346 --> 01:03:08,049
所有的tweets，文本和做包含和

1459
01:03:08,118 --> 01:03:10,919
如果我们想要foo，我们可以做[c]

1460
01:03:10,987 --> 01:03:13,054
所以这是一个twitter用户搜索在那里。

1461
01:03:13,122 --> 01:03:14,555
叽叽t witter的用户已经推送了任何包含的内容

1462
01:03:14,556 --> 01:03:15,989
我们正在寻找

1463
01:03:16,058 --> 01:03:19,493
foo，再次强大的搜索，真的很容易表达。

1464
01:03:22,563 --> 01:03:24,197
题。

1465
01:03:24,265 --> 01:03:27,733
>> [不准确] >>所以问题，

1466
01:03:27,801 --> 01:03:29,801
是否从变量的名称推断出这一点，

1467
01:03:29,869 --> 01:03:31,035
它不是推断它，

1468
01:03:31,104 --> 01:03:34,172
它实际上是使用属性tweets的名称

1469
01:03:34,240 --> 01:03:36,674
在那里和属性文本的名称它是

1470
01:03:36,742 --> 01:03:40,177
构建一个将执行此提取操作的SQL语句。

1471
01:03:40,246 --> 01:03:41,878
好的，现在它正在做所有的封面下面，

1472
01:03:41,947 --> 01:03:44,314
我们不在乎如何，但它在做。

1473
01:03:47,952 --> 01:03:48,718
是的，复合谓词。

1474
01:03:48,787 --> 01:03:51,453
您可以像一个和

1475
01:03:51,522 --> 01:03:52,887
谓词或谓词。

1476
01:03:52,956 --> 01:03:55,957
你可以把字符串中的或，或，或

1477
01:03:56,025 --> 01:03:58,026
你可以创建单独的谓词和

1478
01:03:58,094 --> 01:04:00,794
他们通过创建一个NSCompoundPredicate来组合在一起。

1479
01:04:00,863 --> 01:04:02,195
和谓词与子谓词，和

1480
01:04:02,264 --> 01:04:03,864
只是给出了一系列谓词和

1481
01:04:03,932 --> 01:04:04,664
它把它们放在一起

1482
01:04:04,733 --> 01:04:06,699
你为什么要这样做，而不是放弃和

1483
01:04:06,767 --> 01:04:07,600
还是在那里？

1484
01:04:07,669 --> 01:04:10,970
那么，也许你正在计算谓词是什么，

1485
01:04:11,038 --> 01:04:14,139
基于某些，取决于用户点击或

1486
01:04:14,208 --> 01:04:14,939
有什么，你正在计算它，和

1487
01:04:15,008 --> 01:04:18,009
所以你想添加这些你一起计算的东西。

1488
01:04:19,845 --> 01:04:22,980
好的，还有函数谓词。

1489
01:04:23,049 --> 01:04:25,382
现在这些是超强大的谓词，

1490
01:04:25,451 --> 01:04:27,284
所以你不需要这些功课

1491
01:04:27,352 --> 01:04:30,120
不用担心这些，但很酷。

1492
01:04:30,188 --> 01:04:32,621
你甚至可以说，你有这样的搜索，

1493
01:04:32,690 --> 01:04:35,291
tweets。@ count> 5，

1494
01:04:35,360 --> 01:04:37,926
这是一个Twitter用户搜索，发现

1495
01:04:37,994 --> 01:04:42,363
所有Twitter用户超过5个推文，好吗？

1496
01:04:42,432 --> 01:04:45,266
所以，@count实际上是运行，一个函数的类型

1497
01:04:45,335 --> 01:04:49,003
数据库，去计数的推文数

1498
01:04:49,071 --> 01:04:50,770
Twitter用户有。

1499
01:04:50,839 --> 01:04:52,639
所以，再看看你会看到这一切

1500
01:04:52,707 --> 01:04:55,708
NSPredicate文档，它非常强大，

1501
01:04:55,777 --> 01:04:59,445
你可以看到你几乎不必以格式输入任何东西

1502
01:04:59,514 --> 01:05:02,081
字符串，你得到这些真正强大的搜索。

1503
01:05:04,218 --> 01:05:06,718
好的，所以让我们现在把它放在一起创造

1504
01:05:06,787 --> 01:05:08,019
我们的提取请求，好的。

1505
01:05:08,088 --> 01:05:09,154
我要创建，

1506
01:05:09,222 --> 01:05:11,189
在这种情况下，Twitter用户提取请求。

1507
01:05:11,257 --> 01:05:13,857
所以我在说FetchRequest <TwitterUser> =

1508
01:05:13,926 --> 01:05:16,527
TwitterUser.fetchRequest（），那我就要了

1509
01:05:16,595 --> 01:05:18,161
创造一个昨天的时间，

1510
01:05:18,230 --> 01:05:21,030
实际上不是，这是24小时前。

1511
01:05:21,099 --> 01:05:24,133
时间间隔自现在起，减24倍60次60，

1512
01:05:24,202 --> 01:05:27,068
那是24小时前，我正在创建一个谓词

1513
01:05:27,137 --> 01:05:31,239
那就是说，找到任何有Twitter的Twitter用户

1514
01:05:31,308 --> 01:05:36,378
之前创建的，还是从昨天起我猜，

1515
01:05:36,447 --> 01:05:38,812
是的，创造比昨天更大。

1516
01:05:38,881 --> 01:05:42,917
所以我找到所有Twitter用户谁创建了Tweets

1517
01:05:42,985 --> 01:05:45,419
在过去的二十四小时，这就是这个。

1518
01:05:45,487 --> 01:05:49,556
所以任何一个特殊术语意味着匹配任何一个

1519
01:05:49,625 --> 01:05:51,424
这些东西，和

1520
01:05:51,492 --> 01:05:54,828
这些东西是自昨天以来创建的Tweets。

1521
01:05:56,096 --> 01:05:58,831
我会按照实际的名字对结果进行排序，

1522
01:05:58,899 --> 01:06:01,733
Twitter用户的真实姓名。

1523
01:06:01,802 --> 01:06:04,436
所以我只是在做sortDescriptor，名字的关键，

1524
01:06:04,504 --> 01:06:07,305
上升到真，我没有指定选择器，所以

1525
01:06:07,374 --> 01:06:09,873
我会得到一个默认的比较。

1526
01:06:09,942 --> 01:06:12,743
好的，就是这样，这就是你创建一个提取请求的方式。

1527
01:06:12,811 --> 01:06:16,914
现在，由于我有一个提取请求，我该怎么办？

1528
01:06:16,982 --> 01:06:19,782
给我那些鸣叫，给我那些Twitter用户。

1529
01:06:19,851 --> 01:06:22,618
我们用上下文中非常简单的方法来做到这一点

1530
01:06:22,687 --> 01:06:25,721
我们要求上下文进行抓取，它会出来

1531
01:06:25,790 --> 01:06:28,623
返回所有这些东西的数组，

1532
01:06:28,692 --> 01:06:31,627
按照提取请求说的方式对它们进行排序。

1533
01:06:31,695 --> 01:06:33,228
好的，很简单。

1534
01:06:33,297 --> 01:06:37,832
唯一的事情不是那么简单，它抛出来，好吗？

1535
01:06:37,901 --> 01:06:43,004
就像上下文保存throws一样，上下文也执行throws。

1536
01:06:43,073 --> 01:06:45,539
所以，你可以试试一个问号，

1537
01:06:45,608 --> 01:06:48,942
在这种情况下，如果执行失败，通常它会

1538
01:06:49,011 --> 01:06:51,411
失败，因为你的谓词是错误的，或某事。

1539
01:06:53,114 --> 01:06:56,182
像你的谓词一样没有意义，那么你可能会失败。

1540
01:06:56,251 --> 01:06:57,916
如果它会失败，你会恢复零，

1541
01:06:57,985 --> 01:06:58,984
如果你尝试问号，

1542
01:06:59,052 --> 01:07:00,652
记住这是问号的意思。

1543
01:07:00,720 --> 01:07:03,054
这意味着尝试这样，如果失败，回馈零。

1544
01:07:03,123 --> 01:07:04,188
但如果没有失败，

1545
01:07:04,257 --> 01:07:06,524
那么你会得到一个可选的数组。

1546
01:07:06,592 --> 01:07:08,892
那个阵列将是空的，

1547
01:07:08,961 --> 01:07:11,928
如果找不到符合您要求的内容，或者

1548
01:07:11,997 --> 01:07:14,130
它会充满对象，好吗？

1549
01:07:14,199 --> 01:07:16,832
推特或Twitter用户，一组tweets或

1550
01:07:16,901 --> 01:07:18,200
一系列Twitter用户，

1551
01:07:18,268 --> 01:07:19,501
至少这是它会看起来像你，

1552
01:07:19,570 --> 01:07:22,404
不是那样，看起来好吗？

1553
01:07:22,472 --> 01:07:24,939
这就是你会得到的结果，所以再一次，

1554
01:07:25,007 --> 01:07:26,974
超简单查询。

1555
01:07:27,042 --> 01:07:31,445
现在，你可能有点害怕这样做，

1556
01:07:31,513 --> 01:07:35,415
如果它匹配一百万的东西，好吗？

1557
01:07:35,484 --> 01:07:38,818
你会得到一百万的推文

1558
01:07:38,887 --> 01:07:39,719
这样的请求？

1559
01:07:39,788 --> 01:07:41,621
答案是否定的

1560
01:07:41,689 --> 01:07:45,658
你得到的这个数组是真正的超级智能数组。

1561
01:07:45,726 --> 01:07:48,693
它实际上并没有从数据库中输入数据，

1562
01:07:48,762 --> 01:07:51,496
直到你开始要求它，好吗？

1563
01:07:51,565 --> 01:07:53,964
所以直到我要求Twitter用户，

1564
01:07:54,033 --> 01:07:56,133
某些Twitter用户的信息，

1565
01:07:56,201 --> 01:07:58,401
Twitter用户的名字，Twitter用户的屏幕名称，

1566
01:07:58,470 --> 01:08:00,403
Twitter用户没有从数据库中获取错误。

1567
01:08:00,472 --> 01:08:01,904
这叫做故障，好吗？

1568
01:08:01,973 --> 01:08:03,706
所以，这些对象，你可以想象，

1569
01:08:03,775 --> 01:08:05,941
他们是贝壳，空壳。

1570
01:08:06,010 --> 01:08:07,276
直到你开裂壳和

1571
01:08:07,344 --> 01:08:08,810
开始看里面，

1572
01:08:08,879 --> 01:08:10,811
它实际上并没有为你获取数据。

1573
01:08:10,880 --> 01:08:12,546
这对你来说很重要，

1574
01:08:12,615 --> 01:08:15,482
如果你进入调试器，或者你做一个print语句，

1575
01:08:15,551 --> 01:08:20,220
就像你说的那样，对于近期的用户而言

1576
01:08:20,289 --> 01:08:23,423
获取用户无论什么，当你打印出来，

1577
01:08:23,492 --> 01:08:26,159
它不会打印，一个Tweeter用户对象，

1578
01:08:26,227 --> 01:08:29,261
它会打印某种错误的货架。

1579
01:08:29,330 --> 01:08:30,529
因为你没有真正要求

1580
01:08:30,598 --> 01:08:32,631
那东西里面的任何数据呢，所以

1581
01:08:32,699 --> 01:08:34,065
它还没有错。

1582
01:08:34,134 --> 01:08:34,899
但是如果你说，为

1583
01:08:34,968 --> 01:08:38,169
用户在recentTweeters和说获取用户命名，和

1584
01:08:38,238 --> 01:08:41,438
现在你说user.name，现在你在这个对象错了。

1585
01:08:41,507 --> 01:08:42,205
其实这个

1586
01:08:42,274 --> 01:08:45,809
循环将把所有这些对象故障转移到内存中。

1587
01:08:45,877 --> 01:08:47,410
好的，把它们全部拿出来，你要求的

1588
01:08:47,479 --> 01:08:48,411
每一个人的名字。

1589
01:08:48,480 --> 01:08:50,445
巨大的，故障，错误，错误，他们都进来了。

1590
01:08:50,514 --> 01:08:53,449
现在，它不一一做，它分批错误，

1591
01:08:53,517 --> 01:08:55,717
这是非常高的性能，所以，

1592
01:08:55,785 --> 01:08:57,752
你知道，别担心。

1593
01:08:57,821 --> 01:09:00,455
但只是，我只是不想让你感到惊讶

1594
01:09:00,524 --> 01:09:01,054
当你进入调试器和

1595
01:09:01,123 --> 01:09:02,957
你就像，我打印出这个Twitter，用户和

1596
01:09:03,026 --> 01:09:04,858
没有屏幕名称，发生了什么？

1597
01:09:04,927 --> 01:09:06,492
那没有错。

1598
01:09:06,561 --> 01:09:07,993
其实调试器你可以说，

1599
01:09:08,062 --> 01:09:09,862
打印user.name，

1600
01:09:09,931 --> 01:09:13,332
它会错过它，好吧，给你。

1601
01:09:15,369 --> 01:09:17,568
好吧，我告诉过你，我会谈谈核心数据

1602
01:09:17,637 --> 01:09:19,470
线程安全，所以这里是。

1603
01:09:19,539 --> 01:09:22,873
NSManagedObjectContext，上下文的东西，

1604
01:09:22,942 --> 01:09:24,775
你发送的那个事情执行到，

1605
01:09:24,844 --> 01:09:27,544
你正在保存的东西，你的东西

1606
01:09:27,613 --> 01:09:30,280
用来创建Tweet，Tweet，subcontext，

1607
01:09:30,349 --> 01:09:33,817
冒号，数据库处理不是线程安全的。

1608
01:09:35,052 --> 01:09:38,420
上下文只能在队列中使用

1609
01:09:38,489 --> 01:09:41,156
它是在时期创建的。

1610
01:09:41,225 --> 01:09:44,492
如果你通过上下文到另一个队列，

1611
01:09:44,561 --> 01:09:47,194
像你试图派遣一些

1612
01:09:47,263 --> 01:09:50,030
全局并发队列，并粘贴上下文，或

1613
01:09:50,099 --> 01:09:52,866
即使只是粘贴了一个Tweet，好的，这不会工作，

1614
01:09:52,935 --> 01:09:55,335
这是Tweet在另一个上下文中创建的。

1615
01:09:55,403 --> 01:09:56,870
所以其实不仅仅是上下文，

1616
01:09:56,939 --> 01:09:59,372
但是您在该上下文中创建的所有内容

1617
01:09:59,441 --> 01:10:01,907
必须在同一个队列中完成。

1618
01:10:01,976 --> 01:10:03,175
所以现在你可能在想，

1619
01:10:03,244 --> 01:10:07,145
那么我该怎么做多线程呢？

1620
01:10:07,214 --> 01:10:10,315
尤其是一个数据库，你可以想象一下

1621
01:10:10,384 --> 01:10:13,584
寺庙一个将数据库加载到主队列中，

1622
01:10:13,653 --> 01:10:15,853
你可能会加载很多很多东西。

1623
01:10:15,922 --> 01:10:16,586
现在你的查询，

1624
01:10:16,655 --> 01:10:19,255
你可能会在主队列上做那些，因为

1625
01:10:19,324 --> 01:10:20,890
用户查看该信息。

1626
01:10:20,959 --> 01:10:22,157
你希望它高度响应。

1627
01:10:22,226 --> 01:10:25,794
好的，这可能是值得的，核心数据是超快的，

1628
01:10:25,863 --> 01:10:27,029
特别是查询。

1629
01:10:27,097 --> 01:10:28,797
所以，你可以在主队列中做到这一点。

1630
01:10:28,866 --> 01:10:29,464
但加载它，

1631
01:10:29,532 --> 01:10:31,432
你可能不想这样做

1632
01:10:31,501 --> 01:10:33,734
好的，那么我们如何做多线程呢？

1633
01:10:33,803 --> 01:10:36,570
虽然我们在Core Data中进行多线程，

1634
01:10:36,638 --> 01:10:43,110
是每个数据库可以有多个上下文，好吗？

1635
01:10:43,179 --> 01:10:47,247
所以下面的数据库是多线程的，

1636
01:10:47,315 --> 01:10:50,850
它可以有多个上下文写入它。

1637
01:10:50,918 --> 01:10:52,784
好的，完全不同的语境，

1638
01:10:52,853 --> 01:10:55,820
写入同一个数据库，在不同的队列中，所以

1639
01:10:55,889 --> 01:10:57,622
它完全是多线程的。

1640
01:10:57,691 --> 01:11:00,992
所以这意味着我们必须为每个队列设置上下文。

1641
01:11:01,060 --> 01:11:03,361
无论我们要访问数据库的任何队列，

1642
01:11:03,430 --> 01:11:04,896
我们必须在每个队列中都有上下文。

1643
01:11:04,964 --> 01:11:07,230
现在我将告诉你如何创建一个上下文，或者

1644
01:11:07,299 --> 01:11:07,997
在另一个队列，所以

1645
01:11:08,066 --> 01:11:10,467
你可以在这里做一些排队。

1646
01:11:10,535 --> 01:11:12,101
但首先我想谈谈这个重要的事情

1647
01:11:12,170 --> 01:11:15,471
方法在上下文中称为performBlock。

1648
01:11:15,539 --> 01:11:17,373
performBlock只是一个闭包，

1649
01:11:17,441 --> 01:11:18,807
一个没有参数的闭包，

1650
01:11:18,875 --> 01:11:22,677
没有任何参数，它将确保，这是

1651
01:11:22,746 --> 01:11:27,381
一种保险方法，它将确保内部的一切

1652
01:11:27,450 --> 01:11:32,086
该闭包发生在该上下文的正确队列上。

1653
01:11:32,154 --> 01:11:34,955
好的，所以这个，别混淆了，

1654
01:11:35,024 --> 01:11:38,125
这个方法不派发，你知道，

1655
01:11:38,193 --> 01:11:42,562
引起背景的高涨，这只是确定，

1656
01:11:42,631 --> 01:11:45,998
该关闭在正确的队列上执行。

1657
01:11:46,067 --> 01:11:48,433
所以这是一种你可以安全的方式。

1658
01:11:48,502 --> 01:11:50,735
有些人可能会说你应该把performBlock放在一边

1659
01:11:50,804 --> 01:11:53,238
每一个对每个Core Data事件的调用，

1660
01:11:53,307 --> 01:11:56,307
因为这将确保您永远不会有问题

1661
01:11:56,376 --> 01:11:59,811
你正在访问上下文而不是排队。

1662
01:11:59,879 --> 01:12:01,778
好的，这意味着你有一些不好的代码。

1663
01:12:01,847 --> 01:12:06,483
现在，这可能有点过分，特别是如果

1664
01:12:06,552 --> 01:12:09,352
你主要使用主队列，而且

1665
01:12:09,421 --> 01:12:12,355
你真的，也许你只使用后台队列

1666
01:12:12,424 --> 01:12:15,324
这个微小的一点处理在一边。

1667
01:12:15,393 --> 01:12:17,993
这不像你有吨的背景和

1668
01:12:18,062 --> 01:12:20,695
许多不同的队列都相互对峙。

1669
01:12:20,764 --> 01:12:22,564
所以，这可能是过度的。

1670
01:12:22,632 --> 01:12:24,466
但是，如果你在做任何事情，

1671
01:12:24,534 --> 01:12:27,202
真正有多个上下文在多个队列和

1672
01:12:27,270 --> 01:12:31,572
他们是访问和事情，这是一个很好的方式来安全。

1673
01:12:31,641 --> 01:12:35,175
好的，所以这一切都是让它安全的。

1674
01:12:35,243 --> 01:12:39,346
该块内的代码将被正确执行

1675
01:12:39,415 --> 01:12:40,947
为该上下文排队。

1676
01:12:41,015 --> 01:12:43,516
即使它必须派遣，它会做到，如果它必须。

1677
01:12:43,585 --> 01:12:44,917
如果不需要派遣，

1678
01:12:44,986 --> 01:12:47,786
如果你在正确的队列上，那就行了吧。

1679
01:12:47,855 --> 01:12:49,387
但是如果你现在在错误的队列上

1680
01:12:49,456 --> 01:12:50,055
你执行这个，

1681
01:12:50,124 --> 01:12:52,056
它会将其发送到正确的队列。

1682
01:12:52,125 --> 01:12:53,991
还有performBlockAndWait，

1683
01:12:54,060 --> 01:12:55,659
这将得到它在正确的队列和

1684
01:12:55,728 --> 01:12:58,062
等待完成，然后继续排队。

1685
01:12:59,298 --> 01:13:01,597
好的，但是这并没有真的说出来，

1686
01:13:01,666 --> 01:13:05,100
如何在另一个线程中获得另一个上下文，对吧？

1687
01:13:05,169 --> 01:13:07,969
我想在另一个线程上做一些代码。

1688
01:13:08,038 --> 01:13:09,370
我在哪里得到一个上下文？

1689
01:13:09,439 --> 01:13:12,840
我现在知道如何得到的唯一的上下文是viewContext。

1690
01:13:12,909 --> 01:13:14,909
这是主队列的上下文，

1691
01:13:14,978 --> 01:13:16,143
那是我唯一可以得到的。

1692
01:13:16,212 --> 01:13:18,812
好的，你会用这个很酷的方法

1693
01:13:18,881 --> 01:13:20,013
在persistentContainer。

1694
01:13:20,082 --> 01:13:24,050
这是iOS 10中的新功能，真是很酷的方法，

1695
01:13:24,119 --> 01:13:25,185
超酷。

1696
01:13:25,253 --> 01:13:27,954
这使得后台进程变得非常容易

1697
01:13:28,022 --> 01:13:29,188
核心数据。

1698
01:13:29,256 --> 01:13:31,256
它被称为performBackgroundTask。

1699
01:13:31,324 --> 01:13:34,292
记住，这是persistentContainer上的一个功能

1700
01:13:34,361 --> 01:13:36,327
你从AppDelegate得到。

1701
01:13:36,396 --> 01:13:38,129
这需要闭包。

1702
01:13:38,197 --> 01:13:42,866
这个闭包有一个参数，参数是一个上下文。

1703
01:13:42,935 --> 01:13:45,569
而且这种情况适合使用

1704
01:13:45,638 --> 01:13:49,172
在另一个线程上，这将为您创建。

1705
01:13:49,240 --> 01:13:52,107
所以这个performBackgroundTask会发现另一个队列，

1706
01:13:52,176 --> 01:13:55,044
不是主队列，还有一些队列。

1707
01:13:55,113 --> 01:13:58,346
并在其他队列中创建一个上下文

1708
01:13:58,415 --> 01:14:02,584
在后台的其他队列中执行闭包。

1709
01:14:03,853 --> 01:14:05,153
现在，这是一个方便的方法。

1710
01:14:05,221 --> 01:14:07,855
所以如果你真的需要控制质量

1711
01:14:07,923 --> 01:14:10,724
服务，例如排队等等，好吧，好吧，

1712
01:14:10,793 --> 01:14:11,558
你不能使用这个。

1713
01:14:11,626 --> 01:14:14,694
但99.99％的时间，无论质量如何

1714
01:14:14,762 --> 01:14:17,330
队列正在获得的服务是正确的

1715
01:14:17,398 --> 01:14:19,499
核心数据核心数据知道其业务。

1716
01:14:20,801 --> 01:14:21,633
你会做到。

1717
01:14:21,702 --> 01:14:25,169
现在，这件事情真的在闭包了几件事情

1718
01:14:25,238 --> 01:14:26,037
小心点

1719
01:14:26,105 --> 01:14:28,839
一，永远不要在这里使用viewContext。

1720
01:14:28,908 --> 01:14:32,242
你知道为什么会是非常糟糕的

1721
01:14:32,311 --> 01:14:34,911
在这个闭包中使用viewContext？

1722
01:14:34,980 --> 01:14:37,781
因为这个定义的闭包不执行

1723
01:14:37,849 --> 01:14:39,415
主队列。

1724
01:14:39,484 --> 01:14:41,350
根据定义，这个闭包是单独的

1725
01:14:41,419 --> 01:14:42,718
在后台队列中排队。

1726
01:14:42,787 --> 01:14:44,452
这就是这件事的全部内容，

1727
01:14:44,521 --> 01:14:46,121
是把这件事放在另一个队列上。

1728
01:14:46,189 --> 01:14:48,255
所以从来没有使用viewContext，

1729
01:14:48,324 --> 01:14:50,257
这就是为什么它在红色，好吗？

1730
01:14:50,326 --> 01:14:55,062
第二件事是不要忘记保存这个上下文。

1731
01:14:55,130 --> 01:14:56,629
如果你在这里做了一大堆东西，

1732
01:14:56,698 --> 01:14:58,264
你不保存，你只是为了

1733
01:14:58,333 --> 01:14:59,699
没有你在记忆中做的事

1734
01:14:59,768 --> 01:15:02,601
然后这个块就消失了，你永远都不会这样

1735
01:15:02,670 --> 01:15:05,804
上下文再次，数据丢失。

1736
01:15:05,873 --> 01:15:08,507
这些都会离开堆，然后什么也没有发生。

1737
01:15:08,575 --> 01:15:10,875
它永远不会承诺到数据库。

1738
01:15:10,944 --> 01:15:12,944
所以，在你离开之前别忘了保存。

1739
01:15:14,113 --> 01:15:15,679
现在，当你保存，

1740
01:15:15,748 --> 01:15:18,515
它会将其推送到数据库

1741
01:15:18,584 --> 01:15:23,186
你的其他上下文你的viewContext会看到它，好吗？

1742
01:15:23,255 --> 01:15:26,022
所以这两个上下文，就是发生在这一点上

1743
01:15:26,091 --> 01:15:27,423
背景和viewContext。

1744
01:15:27,492 --> 01:15:29,291
他们正在使用相同的数据库，所以

1745
01:15:29,360 --> 01:15:30,192
当这个节省的时候，

1746
01:15:30,261 --> 01:15:33,027
这个家伙会开始看到这些变化。

1747
01:15:33,096 --> 01:15:36,430
我会说一点点看到那些反应

1748
01:15:36,499 --> 01:15:38,266
在这里改变一分钟。

1749
01:15:39,468 --> 01:15:41,334
好的，大家明白了吗

1750
01:15:41,403 --> 01:15:43,703
你会在作业五中做这个。

1751
01:15:43,772 --> 01:15:47,040
而且我想让你做所有的装载从主队列，

1752
01:15:47,109 --> 01:15:49,709
并且您在主队列中的所有提取。

1753
01:15:50,845 --> 01:15:56,315
好的，核心数据是巨大的。

1754
01:15:56,384 --> 01:15:56,948
巨大。

1755
01:15:58,351 --> 01:15:59,484
我无法掩盖。

1756
01:16:00,686 --> 01:16:02,085
它有乐观的锁定，因为

1757
01:16:02,154 --> 01:16:03,053
那些知道数据库的人。

1758
01:16:03,121 --> 01:16:06,423
它有乐观的锁定和所有的数据库的东西。

1759
01:16:06,491 --> 01:16:10,025
它有完整的撤消，重做，这是令人难以置信的。

1760
01:16:10,094 --> 01:16:13,462
它显然知道如何回滚未保存的更改。

1761
01:16:13,531 --> 01:16:15,330
好的，如果你有内存变化，

1762
01:16:15,398 --> 01:16:16,297
你想把他们中的一些回来，

1763
01:16:16,366 --> 01:16:17,966
你可以在保存前做到这一点。

1764
01:16:18,034 --> 01:16:20,534
它知道陈旧，就像我取得一样，

1765
01:16:20,603 --> 01:16:23,870
我真的想再次取出来多久，因为我没有

1766
01:16:23,939 --> 01:16:26,206
相信数据没有改变，对吧？

1767
01:16:26,274 --> 01:16:28,574
数据过期需要多长时间。

1768
01:16:28,643 --> 01:16:31,710
还有很多其他的核心数据。

1769
01:16:31,779 --> 01:16:33,212
所以，我不能掩盖所有，

1770
01:16:33,280 --> 01:16:35,247
没有足够的时间做到这一点。

1771
01:16:35,316 --> 01:16:37,749
我们正在试图谈谈一个关于另一个话题

1772
01:16:37,818 --> 01:16:39,217
但是，您需要检查文档，您不需要

1773
01:16:39,218 --> 01:16:40,617
核心数据在这里。

1774
01:16:40,687 --> 01:16:43,521
这些东西的其他东西做你的功课，当然，

1775
01:16:43,589 --> 01:16:45,689
我只是想让你开始这个。

1776
01:16:45,757 --> 01:16:48,224
但是你需要知道这些东西在那里，所以

1777
01:16:48,293 --> 01:16:52,562
有一天你出门做一些重要的iOS数据库

1778
01:16:52,631 --> 01:16:54,764
东西，你会知道这些功能在那里。

1779
01:16:56,300 --> 01:17:01,503
好的，下面的主题是Core Data和UITableView。

1780
01:17:01,572 --> 01:17:05,306
你可以想像，这是在天堂做的婚姻，好吗？

1781
01:17:05,375 --> 01:17:06,908
因为你有这个数据库，

1782
01:17:06,977 --> 01:17:09,244
在那里获得所有这些大数据集

1783
01:17:09,312 --> 01:17:13,681
我们用来在iOS中显示大数据集的UI是什么？

1784
01:17:13,750 --> 01:17:14,982
UITableView的。

1785
01:17:15,051 --> 01:17:18,152
好的，UITableView是伟大的显示任意大

1786
01:17:19,487 --> 01:17:22,288
数据集在我们任意的UI中，对吧？

1787
01:17:22,357 --> 01:17:23,655
我们可以自定义表视图单元格，

1788
01:17:23,724 --> 01:17:26,191
我们可以做任何我们想要的UI。

1789
01:17:26,260 --> 01:17:30,429
所以，这是非常普遍的，因为苹果已经发明了这个

1790
01:17:30,497 --> 01:17:33,965
重要的类称为NSFetchedResultsController。

1791
01:17:34,034 --> 01:17:36,333
这不是一个viewController，好吗？

1792
01:17:36,402 --> 01:17:39,403
这是控制核心数据的控制器

1793
01:17:39,472 --> 01:17:40,571
UITableView一起聊天，

1794
01:17:40,639 --> 01:17:44,607
但是它不是在其获取结果视图控制器，好吗？

1795
01:17:44,676 --> 01:17:47,277
和所有这NSFetchedResultsController

1796
01:17:47,346 --> 01:17:50,513
是否挂钩了您创建的NSFetchRequest

1797
01:17:50,582 --> 01:17:52,481
到一个UITableView。

1798
01:17:52,550 --> 01:17:55,651
它把它们以如此强烈的方式挂钩，如果有的话

1799
01:17:55,720 --> 01:17:59,087
数据库中会导致该提取请求的更改

1800
01:17:59,156 --> 01:18:02,090
要返回不同的结果，它会更新表

1801
01:18:02,158 --> 01:18:04,993
自动，你不必做任何事情。

1802
01:18:05,062 --> 01:18:09,096
所以这是一个活跃的现场连接

1803
01:18:09,165 --> 01:18:14,467
NSFetchRequest和TableView，好吗？

1804
01:18:14,536 --> 01:18:17,370
即使其他一些上下文正在更改数据，也没有

1805
01:18:17,439 --> 01:18:20,807
事实上，它始终保持TableView是最新的。

1806
01:18:21,977 --> 01:18:25,011
所以我会谈谈我们如何做到这一点

1807
01:18:25,080 --> 01:18:28,980
我们如何使用NSFetchedResultsController。

1808
01:18:29,049 --> 01:18:31,550
我甚至会为你提供一些免费的代码

1809
01:18:31,619 --> 01:18:32,984
做一些它。

1810
01:18:33,053 --> 01:18:34,586
您必须输入其余部分的一点。

1811
01:18:34,654 --> 01:18:37,455
但是，这很容易做到。

1812
01:18:39,191 --> 01:18:40,657
那么从根本上说呢

1813
01:18:40,726 --> 01:18:42,725
NSFetchedResultsController工作？

1814
01:18:42,794 --> 01:18:46,596
两种方式，一种，它有一个代表和

1815
01:18:46,664 --> 01:18:50,600
该委托您设置为您的UITableViewController。

1816
01:18:50,668 --> 01:18:53,001
每当FetchResultsController看到

1817
01:18:53,070 --> 01:18:53,802
发生什么事

1818
01:18:53,871 --> 01:18:56,638
在影响该fetchRequest的数据库中，

1819
01:18:56,706 --> 01:18:59,707
它告诉表视图控制器，嘿，这样做，

1820
01:18:59,776 --> 01:19:02,843
添加此行，添加一个部分，重新​​加载此行，无论如何，

1821
01:19:02,911 --> 01:19:09,349
它使用UITableView原语更新表，好吗？

1822
01:19:09,418 --> 01:19:10,350
我要告诉你，

1823
01:19:10,419 --> 01:19:12,318
我会给你代码，这样做的一部分，

1824
01:19:12,387 --> 01:19:14,454
它实现了NSFetchedResultsController的

1825
01:19:14,522 --> 01:19:16,422
代理，好吧，这是一种方式。

1826
01:19:16,491 --> 01:19:18,758
另一种方式是NSFetchedResultsController

1827
01:19:18,826 --> 01:19:21,493
工作是为它提供实现

1828
01:19:21,562 --> 01:19:24,763
所有的UITableView数据源方法，对吧？

1829
01:19:24,831 --> 01:19:26,631
因为你的表的内容

1830
01:19:26,700 --> 01:19:28,131
正在从数据库中出来，

1831
01:19:28,200 --> 01:19:30,668
所以NSFetchedResultsController让你知道所有这些，如何

1832
01:19:30,736 --> 01:19:33,436
许多部分，多少行和部分所有的东西。

1833
01:19:33,505 --> 01:19:35,204
其实这就是它的样子，

1834
01:19:35,273 --> 01:19:37,874
这是你将要实施的

1835
01:19:37,942 --> 01:19:41,077
你的控制器当你有fetchedResultsController。

1836
01:19:41,146 --> 01:19:42,077
你要的第一件事

1837
01:19:42,146 --> 01:19:44,212
你会创建一个fetchedResultsController，和

1838
01:19:44,281 --> 01:19:46,448
我会告诉你如何做到这一点。

1839
01:19:46,516 --> 01:19:48,382
所以你总是会有一个var

1840
01:19:48,451 --> 01:19:50,518
fetchedResultsController和

1841
01:19:50,586 --> 01:19:53,386
它将是NSFetchedResultsController类型。

1842
01:19:53,455 --> 01:19:56,056
当你有这个var，现在你可以实现你的

1843
01:19:56,125 --> 01:19:59,659
部分，TableView中的部分数字表示返回

1844
01:19:59,728 --> 01:20:04,731
fetchedResultsController .sections.count，好吗？

1845
01:20:04,800 --> 01:20:06,231
那里有很多可选项，所以

1846
01:20:06,300 --> 01:20:08,934
我们将默认为一个部分。

1847
01:20:09,003 --> 01:20:10,969
然后得到一段中的行数，

1848
01:20:11,038 --> 01:20:12,771
你会说，

1849
01:20:12,839 --> 01:20:14,539
你会先说出这些部分

1850
01:20:14,608 --> 01:20:16,640
fetchedResultsController？.sec。

1851
01:20:16,709 --> 01:20:21,445
只要你有一些section，sections.count

1852
01:20:21,514 --> 01:20:24,748
大于零，那么你将返回这些部分

1853
01:20:24,817 --> 01:20:27,650
那个传递给你的对象数。

1854
01:20:27,719 --> 01:20:31,087
好的，所以代码就是这样，这就是你们两个

1855
01:20:31,155 --> 01:20:34,390
方法，这是整个实现，如果你正在使用

1856
01:20:34,458 --> 01:20:36,491
一个fetchedResultsController，好吗？

1857
01:20:36,560 --> 01:20:39,394
那当然还有cellForRowAt，好的，

1858
01:20:39,463 --> 01:20:41,629
你必须实现这一点，

1859
01:20:41,698 --> 01:20:44,298
你会使用fetchedResultsController。

1860
01:20:44,367 --> 01:20:48,869
关于cellForRowAt最重要的是你需要的

1861
01:20:48,938 --> 01:20:53,274
知道那个行是什么，我的数据库中的哪一个

1862
01:20:53,343 --> 01:20:56,909
在我表中那一节的那一行。

1863
01:20:56,978 --> 01:21:00,480
并通过询问fetchedResultsController来获得

1864
01:21:00,549 --> 01:21:02,481
这个方法objectAtIndexPath。

1865
01:21:02,550 --> 01:21:05,117
所以你只是说fetchedResultsController，

1866
01:21:05,186 --> 01:21:08,520
给我的对象，那个对象将是一个鸣叫，或者

1867
01:21:08,589 --> 01:21:11,189
Twitter用户，或任何一个实体。

1868
01:21:11,258 --> 01:21:13,691
在索引路径上给我一个对象

1869
01:21:13,760 --> 01:21:17,262
那个cellForRowAt indexPath是要求我的。

1870
01:21:17,330 --> 01:21:19,363
所以现在我有Twitter用户或者tweet，

1871
01:21:19,432 --> 01:21:21,232
我可以轻松加载我的UI。

1872
01:21:21,300 --> 01:21:24,667
你知道，把它传递给我的UI，自定义UITableView单元格，

1873
01:21:24,736 --> 01:21:25,902
或者如果我有一个副标题单元格，

1874
01:21:25,971 --> 01:21:27,970
只要把几件事情从那里拿出来

1875
01:21:28,039 --> 01:21:30,105
将其放在文本标签中的详细文本标签中，

1876
01:21:30,174 --> 01:21:31,340
明白我说什么了吗?

1877
01:21:31,408 --> 01:21:34,642
但是你可以看到那个fetchedResultsController，

1878
01:21:34,711 --> 01:21:37,512
那个代码在黄色的正中间

1879
01:21:37,581 --> 01:21:39,180
cellForRowAt indexPath，

1880
01:21:39,249 --> 01:21:42,416
这是做所有的工作，以弄清楚什么tweet或

1881
01:21:42,485 --> 01:21:45,653
什么Twitter用户在这个表的表，好吗？

1882
01:21:45,721 --> 01:21:47,120
所以那些代码在最后一张幻灯片和

1883
01:21:47,189 --> 01:21:49,789
这个幻灯片上的代码，你必须在任何一个键入该代码

1884
01:21:49,858 --> 01:21:53,392
你正在使用NSFetchedResultsController。

1885
01:21:53,461 --> 01:21:56,028
现在，在上一张幻灯片中，其中一件事是var

1886
01:21:56,097 --> 01:21:58,330
fetchedResultsController等于某事。

1887
01:21:58,399 --> 01:22:00,566
那么现在让我们谈谈我们如何创造

1888
01:22:00,634 --> 01:22:03,001
一个fetchedResultsController，好吗？

1889
01:22:03,070 --> 01:22:04,769
所以这是初始化程序

1890
01:22:04,838 --> 01:22:07,304
NSFetchedResultsController看起来像这样。

1891
01:22:07,373 --> 01:22:09,273
它需要一个请求，一个上下文。

1892
01:22:09,342 --> 01:22:11,074
显然，它不知道什么数据库

1893
01:22:11,143 --> 01:22:12,375
我们正在抓住

1894
01:22:12,444 --> 01:22:15,444
然后它有一个sectionNameKeyPath。

1895
01:22:15,513 --> 01:22:19,682
该sectionNameKeyPath是var

1896
01:22:19,751 --> 01:22:24,519
那个实体的值是一个字符串，

1897
01:22:24,588 --> 01:22:28,891
这是它的部分的标题，好吗？

1898
01:22:28,959 --> 01:22:31,425
那就是如何使用fetchedResultsController来执行部分。

1899
01:22:31,494 --> 01:22:33,928
你只需要，你可能必须发明这个或

1900
01:22:33,997 --> 01:22:35,195
甚至计算这个。

1901
01:22:35,264 --> 01:22:38,265
但是，您的所有推文或所有Twitter用户，如果是

1902
01:22:38,333 --> 01:22:40,800
会分段，他们都要有一个var，

1903
01:22:40,869 --> 01:22:43,870
这是一个字符串，这是他们所在的部分，好的，

1904
01:22:43,939 --> 01:22:45,738
他们所在的部分的名称。

1905
01:22:45,807 --> 01:22:49,341
而且只要有这样的话，那么fetchedResults会

1906
01:22:49,410 --> 01:22:50,843
将会使部分和

1907
01:22:50,911 --> 01:22:53,344
把它们全部放在正确的部分。

1908
01:22:53,413 --> 01:22:56,681
在这里我们再谈一下cacheName。

1909
01:22:56,749 --> 01:22:58,950
所以我们必须创建一个fetchRequest来放在这里。

1910
01:22:59,019 --> 01:23:00,818
所以这里创建一个fetchRequest的例子

1911
01:23:00,887 --> 01:23:01,719
推文，对吧？

1912
01:23:01,788 --> 01:23:03,486
所以你认识到那里的第一行，

1913
01:23:03,555 --> 01:23:05,655
为tweet创建一个fetchRequest。

1914
01:23:05,723 --> 01:23:09,625
当tweets被创建的时候我会整理一下，好的，

1915
01:23:09,694 --> 01:23:11,427
当tweet被推送出去时。

1916
01:23:11,496 --> 01:23:15,664
我会去寻找所有的tweets的tweeter的名字

1917
01:23:15,732 --> 01:23:18,734
等于一些名字，名字，好吗？

1918
01:23:18,803 --> 01:23:20,468
所以它会得到所有的这些tweet，和

1919
01:23:20,537 --> 01:23:22,903
我会把这个请求作为第一个参数，

1920
01:23:22,972 --> 01:23:24,471
到NSFetchedResultsController。

1921
01:23:24,540 --> 01:23:27,807
顺便说一句，通知NSFetchedResultsController就是

1922
01:23:27,876 --> 01:23:31,612
也是一个通用类型，而NSFetchedResultsController可以

1923
01:23:31,681 --> 01:23:34,313
只能控制一个特定类型的提取。

1924
01:23:34,382 --> 01:23:36,915
所以你必须说什么类型，好的，什么类型的实体

1925
01:23:36,984 --> 01:23:39,618
你的FetchController正在做，而这些是相同的

1926
01:23:39,687 --> 01:23:41,587
表中的行中的东西。

1927
01:23:42,956 --> 01:23:45,056
现在，最下面的cacheName很有趣。

1928
01:23:45,124 --> 01:23:48,726
这实际上会永久缓存结果。

1929
01:23:48,794 --> 01:23:49,793
它将从数据库中获取结果

1930
01:23:49,794 --> 01:23:50,793
换一种说法，

1931
01:23:50,863 --> 01:23:55,532
在磁盘上存储一些内部格式的结果。

1932
01:23:55,601 --> 01:23:57,667
那很酷，而且这个存储方式，

1933
01:23:57,735 --> 01:23:58,968
如果你退出你的应用程序并回来，

1934
01:23:59,037 --> 01:24:01,904
它仍然会使用该缓存，所以它是非常有效的。

1935
01:24:01,973 --> 01:24:03,605
但你必须要有点小心。

1936
01:24:03,674 --> 01:24:06,708
您无法更改有关您的请求的任何内容。

1937
01:24:06,777 --> 01:24:09,578
一旦你改变任何关于你的请求，像

1938
01:24:09,646 --> 01:24:12,713
您要搜索的名称，tweeter.name，或

1939
01:24:12,782 --> 01:24:15,082
你正在排序什么，还是什么。

1940
01:24:15,151 --> 01:24:17,718
现在，缓存无效，您必须使其无效

1941
01:24:17,786 --> 01:24:21,354
缓存，好的，有一个API在那里做。

1942
01:24:21,423 --> 01:24:24,057
如果你不想做缓存，你可以通过零，

1943
01:24:24,125 --> 01:24:28,027
对于大多数合理大小的数据集完美无缺，

1944
01:24:28,095 --> 01:24:29,662
你真的不需要缓存。

1945
01:24:29,730 --> 01:24:31,363
但我只是想强调，如果你改变你的

1946
01:24:31,432 --> 01:24:34,700
请求，您的缓存现在无效。

1947
01:24:34,768 --> 01:24:38,169
关于那一节关键的事情，要小心点

1948
01:24:38,237 --> 01:24:42,006
关于那里也是，无论你的sortDescriptors

1949
01:24:42,075 --> 01:24:46,410
说你的行会排序，那就是这样

1950
01:24:46,478 --> 01:24:51,515
与您的部分排序完全相同的顺序。

1951
01:24:51,583 --> 01:24:53,484
换句话说，FetchedResultsController

1952
01:24:53,552 --> 01:24:55,918
不知道如何喜欢移动的东西

1953
01:24:55,987 --> 01:24:58,521
因为他们的部分排列顺序。

1954
01:24:58,590 --> 01:25:00,556
这就是为什么很多次我们正在做节，

1955
01:25:00,624 --> 01:25:04,360
第一个sortDescriptor将按区段键排序

1956
01:25:04,428 --> 01:25:05,927
名字var，对吧？

1957
01:25:05,996 --> 01:25:08,163
然后第二个将按照我们的方式排序

1958
01:25:08,231 --> 01:25:10,865
真的想排序，因为我们必须确定

1959
01:25:10,934 --> 01:25:13,935
我们的整个表按部分顺序排序。

1960
01:25:15,338 --> 01:25:16,269
你明白为什么

1961
01:25:16,338 --> 01:25:17,737
Cuz否则它只是奇怪，

1962
01:25:17,806 --> 01:25:19,072
事情都会在错误的地方。

1963
01:25:20,274 --> 01:25:22,208
所以keyThatSaysWhichAttributeIsTh-

1964
01:25:22,276 --> 01:25:24,810
eSectionName必须按照与您相同的顺序进行排序

1965
01:25:24,878 --> 01:25:26,044
sortDescriptors。

1966
01:25:27,847 --> 01:25:32,216
好的，现在我告诉你NSFetchedResultsController

1967
01:25:32,285 --> 01:25:33,817
手表核心数据。

1968
01:25:33,886 --> 01:25:36,953
它看到在那里发生的变化，它更新它。

1969
01:25:37,022 --> 01:25:38,888
和它的代理，是吗？

1970
01:25:38,957 --> 01:25:40,489
它的代表想成为tableView，

1971
01:25:40,558 --> 01:25:42,124
是tableViewController，而是。

1972
01:25:42,193 --> 01:25:44,360
Cuz它会告诉tableViewController，和

1973
01:25:44,429 --> 01:25:45,627
它会发送这样的消息。

1974
01:25:45,696 --> 01:25:48,663
所以这是一个典型的NSFetchedResultsController

1975
01:25:48,731 --> 01:25:50,031
委托方法。

1976
01:25:50,099 --> 01:25:53,200
控制器改变了添加indexPath的更改类型，和

1977
01:25:53,269 --> 01:25:55,202
这里是新的indexPath。

1978
01:25:55,271 --> 01:25:58,105
好的，这些更改类型可能会被删除或

1979
01:25:58,173 --> 01:26:00,973
插入或修改或任何。

1980
01:26:01,042 --> 01:26:04,176
现在，你必须把代码放在那里调用

1981
01:26:04,245 --> 01:26:07,480
在tableView上正确的方法来获取这些部分

1982
01:26:07,549 --> 01:26:10,449
插入或删除或行添加或任何。

1983
01:26:10,518 --> 01:26:13,819
但是我会给你免费的代码，好的

1984
01:26:13,888 --> 01:26:16,120
我星期三要做的演示，

1985
01:26:16,189 --> 01:26:19,757
我会有一个类叫做fetchedResultsTableViewContro-

1986
01:26:19,826 --> 01:26:21,759
ller，这将是一个类。

1987
01:26:21,827 --> 01:26:25,796
你可以让它成为你的父类

1988
01:26:25,864 --> 01:26:28,598
的UITableViewController。

1989
01:26:28,667 --> 01:26:32,001
而且你会继承这个实现

1990
01:26:32,070 --> 01:26:36,039
代理，好吗？

1991
01:26:36,107 --> 01:26:38,107
是的，这是我刚刚说的。

1992
01:26:38,176 --> 01:26:41,276
好的，所以当你在UITableView中使用核心数据时，

1993
01:26:41,345 --> 01:26:44,079
要记住的事情是，你要进行子类化

1994
01:26:44,148 --> 01:26:46,347
fetchedResultsTableViewControler，

1995
01:26:46,416 --> 01:26:48,950
我会给你的东西，让你实现

1996
01:26:49,019 --> 01:26:51,585
NSFetchedResultsController代理。

1997
01:26:51,654 --> 01:26:54,621
你要添加一个var到你的UITableViewController

1998
01:26:54,690 --> 01:26:56,856
称为fetchedResultsController，和

1999
01:26:56,925 --> 01:26:58,557
你会把它的值定为

2000
01:26:58,626 --> 01:27:01,995
一个带有fetchRequest的NSFetchedResultsController

2001
01:27:02,063 --> 01:27:05,464
想要，好的，你想填充你的桌子。

2002
01:27:05,532 --> 01:27:08,700
然后你将实现你的UITableView数据源

2003
01:27:08,769 --> 01:27:11,770
方法使用fetchedResultsController var

2004
01:27:11,839 --> 01:27:14,405
方法，就像我在幻灯片中给你看的那样，

2005
01:27:14,474 --> 01:27:15,907
人物角色，

2006
01:27:15,975 --> 01:27:18,910
您可以使用与幻灯片上完全相同的内容。

2007
01:27:18,978 --> 01:27:21,679
好的，那么所有这些都会神奇地工作，所有你会的

2008
01:27:21,747 --> 01:27:24,014
要做的就是在你的cellForRowAt indexPath里面，

2009
01:27:24,082 --> 01:27:25,748
你会有对象，tweet，

2010
01:27:25,817 --> 01:27:28,284
或Twitter用户，您只需加载您的UI。

2011
01:27:29,454 --> 01:27:30,919
在你完成这一切之后，

2012
01:27:30,988 --> 01:27:34,022
那么你可以继续使用fetchedResultsController

2013
01:27:34,091 --> 01:27:35,890
在你的tableViewController中。

2014
01:27:35,959 --> 01:27:38,826
首先你要做的是执行抓取

2015
01:27:38,895 --> 01:27:40,161
fetchedResultsController。

2016
01:27:40,229 --> 01:27:43,431
这将导致它出去做你的NSFetchRequest，

2017
01:27:43,499 --> 01:27:44,564
基本上。

2018
01:27:44,633 --> 01:27:46,766
不会把所有的数据都拉过来，但是

2019
01:27:46,835 --> 01:27:49,836
它将基本上带来，做同样的事情，如果

2020
01:27:49,905 --> 01:27:52,404
你自己执行了fetchRequest，

2021
01:27:52,473 --> 01:27:55,508
那么你会想做tableView View.reloadData。

2022
01:27:55,576 --> 01:27:59,144
那是因为你想要所有的数据源

2023
01:27:59,213 --> 01:28:03,481
要调用的方法，你知道我们已经实现了

2024
01:28:03,549 --> 01:28:07,118
所有这些都是我们的获取结果控制器

2025
01:28:07,187 --> 01:28:09,720
在之前的幻灯片中显示。

2026
01:28:09,788 --> 01:28:12,556
还有你想记住做的唯一的事情

2027
01:28:12,625 --> 01:28:15,692
将您的获取结果控制器的代理设置为

2028
01:28:15,761 --> 01:28:19,663
自己，再次，我们使用该提取结果表视图

2029
01:28:19,731 --> 01:28:22,732
控制器代码添加了委托方法

2030
01:28:22,801 --> 01:28:26,302
将结果控制器提取到UITableView控制器

2031
01:28:26,370 --> 01:28:29,638
直到我们可以做所有必要的事情

2032
01:28:29,707 --> 01:28:33,074
成为一个fetchedResultsController委托。

2033
01:28:33,143 --> 01:28:36,077
而你所购买的就是数据库中的任何时间

2034
01:28:36,146 --> 01:28:39,046
将影响NSFetchedRequest的更改

2035
01:28:39,115 --> 01:28:42,383
你连接到你的fetchedResultsController。

2036
01:28:42,452 --> 01:28:45,218
然后，它将使用该委托来查询表

2037
01:28:45,287 --> 01:28:47,154
更新行或部分，

2038
01:28:47,223 --> 01:28:49,623
无论发生什么变化。

2039
01:28:49,691 --> 01:28:52,258
所以让我谈谈一下这里发生了什么

2040
01:28:52,327 --> 01:28:55,027
星期三，我会做一个大的演示，向大家展示

2041
01:28:55,095 --> 01:28:56,828
这个东西，像往常一样。

2042
01:28:56,897 --> 01:28:58,530
作业五周三要出去，

2043
01:28:58,599 --> 01:28:59,831
这将是下个星期三。

2044
01:28:59,899 --> 01:29:03,300
将要将Core Data的内容添加到您的Smashtag中。

2045
01:29:03,369 --> 01:29:08,839
星期五非常相关的部分。

2046
01:29:08,908 --> 01:29:12,276
它正在使用CloudKit来做一个数据库。

2047
01:29:12,344 --> 01:29:15,145
好的？现在，Core Data和CloudKit，

2048
01:29:15,214 --> 01:29:17,380
他们是什么，他们有什么关系？

2049
01:29:17,448 --> 01:29:19,515
那么，核心数据是为了

2050
01:29:19,584 --> 01:29:22,285
做一些关系数据库的事情，

2051
01:29:22,353 --> 01:29:25,354
这些强大的查询和搜索以及类似的东西。

2052
01:29:25,423 --> 01:29:28,056
Cloud Kit是什么，如果你想拥有一个数据库

2053
01:29:28,125 --> 01:29:30,692
在网络上，在云端，好吗？

2054
01:29:30,760 --> 01:29:34,028
一个正在多个人共享的网络

2055
01:29:34,097 --> 01:29:35,996
即使是单身人士，

2056
01:29:36,065 --> 01:29:38,198
在他们的设备的多个，或任何。

2057
01:29:38,267 --> 01:29:40,934
所以他们接近事情的方式有很大的不同。

2058
01:29:41,002 --> 01:29:44,971
在Core Data中，我们使用这个可视化映射器来执行模式。

2059
01:29:45,040 --> 01:29:48,607
在CloudKit中，它本质上是模式。

2060
01:29:48,676 --> 01:29:51,310
当你开始保存vars，

2061
01:29:51,378 --> 01:29:54,980
它开始为你设计这个架构，所以

2062
01:29:55,049 --> 01:29:57,816
这是一种非常不同的思维方式。

2063
01:29:57,885 --> 01:30:00,618
你不会想到设计点的方案。

2064
01:30:00,687 --> 01:30:03,788
提前，随着你去，有一些更有机的

2065
01:30:03,857 --> 01:30:04,655
也没有必要，

2066
01:30:04,723 --> 01:30:07,590
你知道，那种创造这个整体方案的前面和

2067
01:30:07,659 --> 01:30:10,560
描述它，你可以描述它，因为你使用它本质上。

2068
01:30:10,629 --> 01:30:14,531
所以这是两者之间很有趣的比较。

2069
01:30:14,599 --> 01:30:16,265
我希望我有时间做CloudKit。

2070
01:30:16,334 --> 01:30:18,067
上个季度，我有额外的讲座。

2071
01:30:18,135 --> 01:30:20,035
作为整个讲座我可以做CloudKit，但是，

2072
01:30:20,104 --> 01:30:23,205
我们必须在星期五这个星期这样做，所以，

2073
01:30:23,273 --> 01:30:24,538
不要错过。

2074
01:30:24,607 --> 01:30:26,640
下周一是假期。

2075
01:30:26,709 --> 01:30:28,542
所以没有讲座，然后下周三，

2076
01:30:28,611 --> 01:30:30,111
我会去了你的要求

2077
01:30:30,179 --> 01:30:31,979
最终的项目，需要做。

2078
01:30:32,047 --> 01:30:35,915
我也会在AutoLayout上做一个讲座。

2079
01:30:35,984 --> 01:30:38,417
我们终于得到了Autolayout和

2080
01:30:38,486 --> 01:30:41,654
如何做这个Autolayout的东西。

2081
01:30:41,723 --> 01:30:43,522
我会说，我只想告诉你那个

2082
01:30:43,591 --> 01:30:46,025
周三我会见到你的。

2083
01:30:46,093 --> 01:30:56,401
>>欲了解更多请访问我们的Stanford.edu。


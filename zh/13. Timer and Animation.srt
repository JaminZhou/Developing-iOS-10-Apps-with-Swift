1
00:00:00,401 --> 00:00:04,468
[MUSIC]

2
00:00:04,537 --> 00:00:07,571
斯坦福大学

3
00:00:07,640 --> 00:00:11,675
好，好，欢迎CS193P：

4
00:00:11,744 --> 00:00:16,346
开发iOS应用程序，2017年冬季，

5
00:00:16,415 --> 00:00:18,915
这是13号讲座。

6
00:00:18,984 --> 00:00:23,253
而本周的主题将是动画，和

7
00:00:23,322 --> 00:00:27,290
今天我会谈谈有关定时器的问题。

8
00:00:27,359 --> 00:00:30,426
定时器只是一种执行代码块的方式，

9
00:00:30,495 --> 00:00:33,028
一些周期性的时间。

10
00:00:33,097 --> 00:00:35,830
我们并不真的使用动画本身的定时器，

11
00:00:35,899 --> 00:00:39,167
但是，当我们做某些动画的时候，

12
00:00:39,236 --> 00:00:41,168
我们会有一些计时器。

13
00:00:41,237 --> 00:00:44,038
你会看到，特别是周三的大演示，

14
00:00:44,107 --> 00:00:47,675
我们将如何使用定时器与我们的动画工具。

15
00:00:47,743 --> 00:00:49,609
之后我们谈了定时器，我，

16
00:00:49,678 --> 00:00:53,146
我在那里做一个演示，我们将会潜入到动画中。

17
00:00:53,214 --> 00:00:56,216
我会谈论所有不同种类的

18
00:00:56,284 --> 00:00:59,619
动画机制有，然后潜入，

19
00:00:59,687 --> 00:01:02,421
他们中的几个与之间的一个演示。

20
00:01:02,490 --> 00:01:05,357
然后在星期三，我会做一个演示的最后一个动画

21
00:01:05,426 --> 00:01:07,359
风格，我要覆盖。

22
00:01:08,828 --> 00:01:12,930
所以定时器，定时器是这样的，很简单的类，

23
00:01:12,999 --> 00:01:13,830
使用起来很简单

24
00:01:13,899 --> 00:01:15,732
你可能只会使用两个或

25
00:01:15,801 --> 00:01:19,035
也许三，方法或vars在它有史以来。

26
00:01:19,104 --> 00:01:21,604
所有它允许你做的是关闭，

27
00:01:21,672 --> 00:01:24,674
一段代码，并在将来执行一段时间，

28
00:01:24,743 --> 00:01:28,476
一次或一次，在将来。

29
00:01:28,545 --> 00:01:33,715
而且，这不是真正的实时编程。

30
00:01:33,783 --> 00:01:36,484
这个定时器不会在你说的时候完全离开，但是

31
00:01:36,553 --> 00:01:39,154
它会相当接近，因为它正在发生

32
00:01:39,222 --> 00:01:39,987
主队列。

33
00:01:40,056 --> 00:01:41,789
而主队列有时候很忙

34
00:01:41,858 --> 00:01:44,024
处理事件或类似的事情。

35
00:01:44,092 --> 00:01:45,024
所以这不是准确的，但是

36
00:01:45,093 --> 00:01:46,859
它很漂亮，离开了。

37
00:01:46,928 --> 00:01:49,862
所以你不能用它进行实时编程，但是你可以，

38
00:01:49,931 --> 00:01:53,465
使用它来进行任何重复的事情。

39
00:01:53,534 --> 00:01:55,900
现在，定时器是基于一种技术，

40
00:01:55,969 --> 00:01:59,103
我不会谈论所谓的运行循环。

41
00:01:59,172 --> 00:02:02,941
并且运行循环是如何，你知道某个线程得到

42
00:02:03,009 --> 00:02:07,111
所有这些信息，如触摸屏上的事件

43
00:02:07,179 --> 00:02:11,148
和，或者你知道来自网络的事件，或者什么。

44
00:02:11,217 --> 00:02:13,851
它可以让所有这些东西进来，而且它的设计

45
00:02:13,919 --> 00:02:16,986
把他们全部交给需要处理他们的人。

46
00:02:17,055 --> 00:02:19,289
而运行循环不是很复杂，但是

47
00:02:19,357 --> 00:02:21,791
我没有真正谈论他们的原因是运行循环

48
00:02:21,860 --> 00:02:23,525
只是有点在主队列上工作，

49
00:02:23,594 --> 00:02:25,427
你真的不需要考虑它。

50
00:02:25,496 --> 00:02:27,061
但如果你发现自己，

51
00:02:27,130 --> 00:02:29,698
我想在主队列中使用一个计时器，那么你会去

52
00:02:29,766 --> 00:02:31,865
必须教自己关于运行循环，好吧，

53
00:02:31,934 --> 00:02:35,202
因为计时器是完全基于的，在运行循环中。

54
00:02:35,271 --> 00:02:37,755
您在本课程中的目的作为起步，iOS开发者，

55
00:02:37,756 --> 00:02:40,240
但对于

56
00:02:40,308 --> 00:02:44,677
你可以假定定时器是主要的排队事情，好吗？

57
00:02:44,746 --> 00:02:46,779
现在，真的有，

58
00:02:46,847 --> 00:02:49,415
您可以通过实例化创建计时器，

59
00:02:49,483 --> 00:02:52,417
但是你必须把它们放在一个运行循环中。

60
00:02:52,486 --> 00:02:54,819
但是，实际上只有一种方法，

61
00:02:54,888 --> 00:02:56,921
你将在定时器中使用类的方法。

62
00:02:56,990 --> 00:03:01,325
这个方法做的是它需要一个代码块，

63
00:03:01,393 --> 00:03:02,910
当你想执行一段时间的时候，它需要怎么样

64
00:03:02,911 --> 00:03:04,428
闭包。

65
00:03:04,496 --> 00:03:07,730
未来以及您是否要继续重复执行

66
00:03:07,799 --> 00:03:09,598
它，它去做，这样做。

67
00:03:09,667 --> 00:03:11,934
它将事情放在运行循环上，以确保它

68
00:03:12,003 --> 00:03:14,736
以该间隔执行该代码块。

69
00:03:14,805 --> 00:03:17,906
真的不能简单，这是非常非常简单的

70
00:03:17,975 --> 00:03:19,307
强大的UI在那里

71
00:03:19,376 --> 00:03:22,810
所以下面就是这个例子，

72
00:03:22,879 --> 00:03:25,279
这种方法称为定时定时器。

73
00:03:25,348 --> 00:03:28,048
它返回计划时创建的计时器

74
00:03:28,117 --> 00:03:30,116
它并将其放在运行循环上。

75
00:03:30,185 --> 00:03:32,218
所以在这里我只是说timer =，

76
00:03:32,287 --> 00:03:33,619
我有一个本地的var定时器。

77
00:03:33,688 --> 00:03:35,955
注意它是类型定时器，这是一个可选的定时器。

78
00:03:36,023 --> 00:03:38,724
所以我做了timer = scheduledTimer（withTimeInter-

79
00:03:38,792 --> 00:03:41,126
val：2.0，repreat，repeats: true)

80
00:03:41,195 --> 00:03:42,794
然后块，我把一些代码。

81
00:03:42,862 --> 00:03:45,663
那么从现在起两秒钟就要执行这个代码了

82
00:03:45,732 --> 00:03:46,797
估计

83
00:03:46,866 --> 00:03:48,098
而且，由于重复，

84
00:03:48,166 --> 00:03:50,066
它会在两秒后再执行一次

85
00:03:50,135 --> 00:03:53,736
然后两秒钟之后，直到我停止这个东西，好吗？

86
00:03:53,805 --> 00:03:57,573
现在有一件事要注意这个小例子，

87
00:03:57,642 --> 00:03:59,575
注意我的计时器很weak。

88
00:04:00,577 --> 00:04:01,943
好的，看到那么weak？

89
00:04:02,012 --> 00:04:03,644
为什么我使这个计时器weak？

90
00:04:03,713 --> 00:04:05,646
那么，当我安排这个计时器，和

91
00:04:05,715 --> 00:04:06,914
它把它放在运行循环中，

92
00:04:06,983 --> 00:04:09,583
运行循环将获得很大的参考。

93
00:04:09,652 --> 00:04:11,585
所以我不需要强烈的参考。

94
00:04:11,654 --> 00:04:14,320
而事实上，如果我使我的参考薄弱，那么什么时候

95
00:04:14,389 --> 00:04:17,223
这个运行循环是用它完成的，当这件事最后

96
00:04:17,292 --> 00:04:20,392
停止运行，我的ti，定时器var将被设置为nil。

97
00:04:20,461 --> 00:04:21,693
完美，正是我想要的，

98
00:04:21,762 --> 00:04:24,029
因为它真的没有用来指示这个指针

99
00:04:24,097 --> 00:04:26,231
计时器，如果它不运行了。

100
00:04:26,300 --> 00:04:28,266
如果我想再次启动一个计时器

101
00:04:28,334 --> 00:04:30,901
我已经停止了，我只会再次调用给scheduleTimer，

102
00:04:30,970 --> 00:04:33,337
这是一个简单的API。

103
00:04:34,640 --> 00:04:35,872
那么你如何停止计时器呢？

104
00:04:35,940 --> 00:04:38,307
所以你有一个计时器，它有重复的真实和

105
00:04:38,376 --> 00:04:39,241
它正在消失

106
00:04:39,310 --> 00:04:42,110
它每两秒钟做一次这个闭包或者什么。

107
00:04:42,179 --> 00:04:45,147
通过发送消息无效来阻止它

108
00:04:45,215 --> 00:04:49,117
定时器，因此无效告诉运行循环停止，

109
00:04:49,186 --> 00:04:52,921
调度这个东西并使定时器无效。

110
00:04:52,989 --> 00:04:55,556
现在，再一次，如果你这样做，这个计时器就不会了

111
00:04:55,625 --> 00:04:58,492
在那里无效，你有一个弱的var，

112
00:04:58,561 --> 00:05:01,862
它会离开堆，这真的很方便。

113
00:05:04,132 --> 00:05:05,564
我将要做的最后一件事是定时器，

114
00:05:05,633 --> 00:05:07,166
这是容忍。

115
00:05:07,234 --> 00:05:10,603
所以这不是一个实时的事情，你可能会相当

116
00:05:10,671 --> 00:05:13,805
容忍它不准确执行。

117
00:05:13,873 --> 00:05:16,440
这对于花费更长时间的计时器来说更有意义

118
00:05:16,509 --> 00:05:18,576
假设你有一个计时器每分钟都会熄灭，

119
00:05:18,644 --> 00:05:19,643
它做某事

120
00:05:19,712 --> 00:05:22,579
那么如果从现在开始50秒，你可能会很高兴

121
00:05:22,648 --> 00:05:23,880
或从现在开始70秒。

122
00:05:23,949 --> 00:05:26,883
所以你可以在定时器上设置10的容差，

123
00:05:26,952 --> 00:05:30,286
这意味着它会在窗口中加或减10。

124
00:05:30,355 --> 00:05:32,721
顺便说一句，这没有任何漂移。

125
00:05:32,790 --> 00:05:35,624
那么，如果这个，如果系统决定要去了

126
00:05:35,693 --> 00:05:40,062
这次50秒，下次，不会，你知道，

127
00:05:40,130 --> 00:05:42,197
每次都会越来越短，越来越短。

128
00:05:42,265 --> 00:05:44,999
所以，它发生的时间是多少时间

129
00:05:45,068 --> 00:05:46,267
你启动计时器的时间

130
00:05:46,336 --> 00:05:47,701
即使是两天后，

131
00:05:47,770 --> 00:05:50,036
它仍然每分钟一次。

132
00:05:50,105 --> 00:05:51,938
自启动计时器以来，每分钟一次。

133
00:05:52,007 --> 00:05:53,506
只是当它熄灭时，它将是加号或

134
00:05:53,575 --> 00:05:55,341
每次减去一点点。

135
00:05:55,410 --> 00:05:58,377
现在为什么要告诉系统这个？

136
00:05:58,446 --> 00:06:01,346
那么当你的定时器关闭的时候，你知道，

137
00:06:01,415 --> 00:06:03,381
可能系统实际上已经睡眠了。

138
00:06:03,450 --> 00:06:06,116
你的手机惊奇地睡了一下，

139
00:06:06,185 --> 00:06:09,854
一点点微小的睡眠，好的，为了节省电力，

140
00:06:09,923 --> 00:06:11,955
特别是节省电池。

141
00:06:12,024 --> 00:06:13,857
每隔一段时间就醒来，

142
00:06:13,925 --> 00:06:16,593
它有点知道什么时候会再次醒来。

143
00:06:16,661 --> 00:06:19,629
所以宽容可以让它微睡

144
00:06:19,698 --> 00:06:22,731
再多一点，它会醒来别的什么，

145
00:06:22,800 --> 00:06:24,399
然后它可能是你的计时器。

146
00:06:24,468 --> 00:06:27,468
你看，所以这是一个微小的表现。

147
00:06:27,537 --> 00:06:28,469
但如果你有事要继续下去

148
00:06:28,538 --> 00:06:30,471
每一分钟，你知道，

149
00:06:30,540 --> 00:06:32,606
很长一段时间，可以加起来。

150
00:06:32,675 --> 00:06:35,375
好的，那就是宽容。

151
00:06:35,444 --> 00:06:37,444
好吧，我们来做一点演示，

152
00:06:37,512 --> 00:06:40,613
看到这个在行动，这很明显，一旦你看到它。

153
00:06:40,682 --> 00:06:43,415
所以我要采取FaceIt，记得我们的FaceIt演示

154
00:06:43,484 --> 00:06:45,151
有，这是一张脸的照片，

155
00:06:45,219 --> 00:06:47,953
我会用定时器眨眼，好吗？

156
00:06:48,022 --> 00:06:49,420
定时器只会打开眼睛

157
00:06:49,489 --> 00:06:51,556
然后闭上眼睛，打开眼睛，然后闭上眼睛，

158
00:06:51,625 --> 00:06:53,291
超级简单

159
00:06:53,359 --> 00:06:57,362
所以让我们回去，得到FaceIt，在这里。

160
00:06:58,898 --> 00:07:02,432
好的，所以这里是我们现在的面孔。

161
00:07:02,501 --> 00:07:03,966
关于眨眼的事情，我会，

162
00:07:04,035 --> 00:07:06,169
我想再次显示你，因为它是如此重要。

163
00:07:06,237 --> 00:07:08,538
我会把这个闪烁的代码放在一个单独的

164
00:07:08,606 --> 00:07:11,273
视图控制器，它是另一个的子类。

165
00:07:11,342 --> 00:07:14,376
所以我们现在有这个现有的FaceViewController

166
00:07:14,445 --> 00:07:19,146
作为控制这个MBC的东西在这里，好吗？

167
00:07:19,215 --> 00:07:21,983
这个脸是什么，就是现在正在加载脸。

168
00:07:22,051 --> 00:07:25,119
所以我可以把这个代码放在FaceViewController中，

169
00:07:25,188 --> 00:07:27,120
但只是为了再次向你展示，

170
00:07:27,189 --> 00:07:30,457
这个东西，分类另一个MBC做一个。

171
00:07:30,526 --> 00:07:32,825
我要创建一个新的FaceViewController调用

172
00:07:32,894 --> 00:07:34,427
一个闪烁的FaceViewController，

173
00:07:34,496 --> 00:07:36,895
我会把所有闪烁的代码放在那里。

174
00:07:36,964 --> 00:07:42,434
所以我们来去文件>新建>文件和Cocoa Touch Class。

175
00:07:42,503 --> 00:07:44,937
我是，它是FaceViewController的一个子类。

176
00:07:45,005 --> 00:07:48,907
我会叫它BlinkingFaceViewController。

177
00:07:48,976 --> 00:07:51,275
那就是创建一个新类。

178
00:07:51,344 --> 00:07:53,344
我会把它放在同一个地方。

179
00:07:55,281 --> 00:07:58,515
好的，在这里，只需删除这里的所有代码，再次，

180
00:07:58,584 --> 00:08:01,451
只是不要，以免分散你的注意力。

181
00:08:01,520 --> 00:08:04,420
你可以看到它是FaceViewController的一个子类

182
00:08:04,489 --> 00:08:07,757
这是正确的，这里有我们所有的东西。

183
00:08:07,825 --> 00:08:09,892
所有我要放在这里的代码是

184
00:08:09,961 --> 00:08:12,060
只会眨眼。

185
00:08:12,128 --> 00:08:13,395
我会改变，

186
00:08:13,463 --> 00:08:16,564
在我的故事板中，我将在这里选择这个MVC

187
00:08:16,633 --> 00:08:19,466
现在，它的身份是FaceViewController。

188
00:08:19,535 --> 00:08:22,169
而且我会把它改成BlinkingFaceViewController。

189
00:08:22,238 --> 00:08:24,437
而这个变化一定是这样做的

190
00:08:24,506 --> 00:08:28,141
这个特殊的脸部视图就会闪烁。

191
00:08:29,310 --> 00:08:31,910
那么我们如何做到这一点，我们如何做到这一点

192
00:08:31,979 --> 00:08:33,279
BlinkingFaceViewController工作？

193
00:08:33,347 --> 00:08:35,013
那么它的模型是什么？

194
00:08:35,082 --> 00:08:37,515
那么它的模型是公开的

195
00:08:37,584 --> 00:08:39,584
我会叫它闪烁，和

196
00:08:39,652 --> 00:08:43,921
我们会不会眨眼，好吗？

197
00:08:43,990 --> 00:08:48,291
如果有人设置这个闪烁控制器的模型

198
00:08:48,360 --> 00:08:53,096
那么我打算打个电话，像blinkIfNeeded，

199
00:08:53,165 --> 00:08:54,998
blinkIfNeeded，私人func blinkIfNeeded，

200
00:08:54,999 --> 00:08:56,832
好的？

201
00:08:56,901 --> 00:08:59,668
如果需要，它只会闪烁。

202
00:08:59,737 --> 00:09:01,503
现在如果眨眼是false，

203
00:09:01,572 --> 00:09:04,807
显然，不需要闪烁，所以不会闪烁

204
00:09:04,875 --> 00:09:08,510
但如果它是闪烁，那么我们需要眨眼。

205
00:09:08,579 --> 00:09:11,212
现在，只是为了演示目的在这里，

206
00:09:11,281 --> 00:09:13,981
或者也许这甚至是我想要的，我要打开

207
00:09:14,049 --> 00:09:17,585
当我出现时，我的闪烁，当我的MVC出现在屏幕上时，

208
00:09:17,653 --> 00:09:19,686
当我消失时，我会把它关掉。

209
00:09:19,755 --> 00:09:21,487
当你使用时，你需要考虑一下

210
00:09:21,556 --> 00:09:22,355
一个计时器

211
00:09:22,423 --> 00:09:25,124
当你的MVC离开屏幕，因为它在

212
00:09:25,193 --> 00:09:27,759
导航控制器和某人导航到某物

213
00:09:27,828 --> 00:09:30,062
否则有人回击，或其中一些。

214
00:09:30,130 --> 00:09:32,697
你想确保你停止你的计时器。

215
00:09:32,766 --> 00:09:34,332
你不想那个计时器，坐在那里跑，

216
00:09:34,401 --> 00:09:37,435
做某事，MVC甚至不在屏幕上

217
00:09:37,503 --> 00:09:40,871
除非它正在做某些事情，我猜这不是基于UI的。

218
00:09:40,940 --> 00:09:45,975
但是我会在这里看到DidAppear，

219
00:09:46,044 --> 00:09:49,079
super.viewDidAppear。

220
00:09:51,582 --> 00:09:54,216
我会在这里说blinking=true。

221
00:09:54,285 --> 00:09:56,485
所以每当我的MVC出现在屏幕上时，

222
00:09:56,553 --> 00:09:59,688
它会开始闪烁，并在视图中显示

223
00:10:03,693 --> 00:10:06,260
我要说眨眼=假。

224
00:10:06,329 --> 00:10:08,528
所以，当它消失时，我会停止眨眼，

225
00:10:08,597 --> 00:10:09,796
是否有意义？

226
00:10:09,865 --> 00:10:12,432
好的，那显然会让我的刺激者，

227
00:10:12,501 --> 00:10:14,934
定时器停止去cuz我的计时器只会去

228
00:10:15,003 --> 00:10:17,303
当我眨眼，好吗？

229
00:10:17,372 --> 00:10:19,372
那么，我将如何实施blinkIfNeeded？

230
00:10:19,441 --> 00:10:20,472
那么只有在需要的时候才可以

231
00:10:20,541 --> 00:10:23,742
我要说，如果我眨眼，我会做某事，

232
00:10:23,811 --> 00:10:27,378
这就是这个眨眼之间的必要部分。

233
00:10:27,447 --> 00:10:28,613
我需要做什么？

234
00:10:28,682 --> 00:10:33,450
那么，首先我会在这里有一些常数。

235
00:10:33,519 --> 00:10:36,653
我想我调用它，我叫什么

236
00:10:36,722 --> 00:10:39,689
我不知道，我在这里称之为常数。

237
00:10:39,758 --> 00:10:41,825
嗯，好吧，我们只需要输入它们。

238
00:10:41,893 --> 00:10:45,628
所以我会有一个这个叫做BlinkRate的结构。

239
00:10:45,697 --> 00:10:49,432
当我在我身边时，我的眼睛会闭上多久

240
00:10:49,500 --> 00:10:52,468
闪烁，当我眨眼时，它保持打开多长时间。

241
00:10:52,537 --> 00:10:57,105
所以，让我们有一个静态让closedDuration是

242
00:10:57,174 --> 00:11:00,708
将成为一个TimeInterval。

243
00:11:00,777 --> 00:11:04,913
TimeInterval只是一个小类或一点类型

244
00:11:04,981 --> 00:11:09,016
代表了过去的时间，它几乎是一倍。

245
00:11:09,085 --> 00:11:11,952
但是每当我们谈论TimeIntervals，我们都会这样

246
00:11:12,021 --> 00:11:14,921
让人们通过使用TimeInterval类型在我们的代码中知道。

247
00:11:14,990 --> 00:11:18,792
然后我会有同样的事情openDuration

248
00:11:18,861 --> 00:11:21,494
将是一个TimeInterval。

249
00:11:21,563 --> 00:11:23,262
而且，你知道，通常当我们眨眼时，

250
00:11:23,331 --> 00:11:25,631
我们的眼睛保持开放的时间比他们关闭的时间长得多。

251
00:11:25,699 --> 00:11:28,733
所以让我们来说一下，我不知道，2.5秒还是

252
00:11:28,802 --> 00:11:29,834
这样的东西

253
00:11:29,903 --> 00:11:32,103
好的，现在如果我这样做是真的，

254
00:11:32,172 --> 00:11:35,639
我可能会保持开放的数量是随机的

255
00:11:35,708 --> 00:11:37,574
在一些容忍之内，对吧？

256
00:11:37,643 --> 00:11:40,677
当我们眨眼时，我们不要眨眼，眨眼，我们，

257
00:11:40,746 --> 00:11:42,712
你知道有时我们眨眼

258
00:11:42,781 --> 00:11:45,248
那么这么短的时间，而是再次

259
00:11:45,317 --> 00:11:47,983
这里的演示目的就是将其修正为2.5。

260
00:11:48,052 --> 00:11:49,751
好的，所以我们有这个。

261
00:11:49,820 --> 00:11:51,486
现在，我们要眨眼，

262
00:11:51,555 --> 00:11:56,124
我们将从设定我们的眼睛关闭开始。

263
00:11:56,192 --> 00:11:58,459
所以我会自言自语。

264
00:11:58,528 --> 00:11:59,393
我甚至不需要这里的自我。

265
00:11:59,462 --> 00:12:03,697
faceView.eyesOpen = false。

266
00:12:03,765 --> 00:12:07,367
记住faceView是我们的超类的vars之一，

267
00:12:07,436 --> 00:12:10,670
我们的超类中的一个public var。

268
00:12:10,738 --> 00:12:13,606
这可能是不幸的，它必须是一个var或public。

269
00:12:13,675 --> 00:12:15,107
这将是很好，如果它受到保护，也许，

270
00:12:15,176 --> 00:12:18,777
我们没有这样的东西，所以它是公开的，在那里。

271
00:12:18,846 --> 00:12:20,412
我们把它设置eyesOpen为false。

272
00:12:20,481 --> 00:12:22,747
所以我们开始眨眼，闭上眼睛。

273
00:12:22,816 --> 00:12:25,016
现在，在封闭的时间之后，

274
00:12:25,085 --> 00:12:26,250
我们想打开他们。

275
00:12:26,319 --> 00:12:29,719
所以，我会说，Timer.scheduledTimer和

276
00:12:29,788 --> 00:12:31,989
注意我甚至没有看到定时器的返回值

277
00:12:32,057 --> 00:12:33,556
我从来没有使它无效。

278
00:12:33,625 --> 00:12:35,391
这将是一个一枪，和

279
00:12:35,460 --> 00:12:37,994
它会自动失效

280
00:12:38,062 --> 00:12:38,661
完成。

281
00:12:38,730 --> 00:12:42,464
所以我们想要的时间间隔是

282
00:12:42,533 --> 00:12:46,434
BlinkRate.closeDuration，对吧？

283
00:12:46,503 --> 00:12:47,769
我们闭上眼睛。

284
00:12:47,838 --> 00:12:50,338
eyesOpen = false，重复false，

285
00:12:50,407 --> 00:12:52,539
它只会做一次。

286
00:12:52,608 --> 00:12:55,008
我打电话给blinkIfNeeded了

287
00:12:55,077 --> 00:12:56,542
在我眨了一下之后

288
00:12:56,611 --> 00:12:59,145
所以我只会继续调用给我，直到

289
00:12:59,214 --> 00:13:01,180
blimking不再是true。

290
00:13:01,249 --> 00:13:05,551
然后这是代码块，它会调用

291
00:13:05,619 --> 00:13:09,621
每一次，所以它需要一个计时器作为参数。

292
00:13:09,690 --> 00:13:10,822
哎呀，是的。

293
00:13:13,125 --> 00:13:18,463
定时器和我们不，我们可以使用关闭，尾随

294
00:13:18,531 --> 00:13:21,265
闭包语法符号在这里，把它放在最后。

295
00:13:21,333 --> 00:13:22,466
所以这里是定时器。

296
00:13:22,534 --> 00:13:24,034
那么这个定时器需要做什么呢？

297
00:13:24,102 --> 00:13:26,836
嗯，我们要把眼睛睁开，

298
00:13:26,905 --> 00:13:28,838
所以faceView.eyesOpen = true。

299
00:13:28,906 --> 00:13:31,974
当然，我们在这里也是闭包的

300
00:13:32,043 --> 00:13:33,808
我们需要自己..

301
00:13:33,877 --> 00:13:36,711
当然，我们不想拥有内存

302
00:13:36,780 --> 00:13:38,612
周期这里虽然这个定时器是这样的

303
00:13:38,681 --> 00:13:41,682
很短的时间，可能不会成为一个问题。

304
00:13:41,751 --> 00:13:45,585
但是我们将在这里继续前进，在这里做weak self

305
00:13:45,654 --> 00:13:49,122
好吗

306
00:13:49,190 --> 00:13:51,924
所以现在，眼睛回开了吧？

307
00:13:51,993 --> 00:13:54,627
现在我们需要做什么？

308
00:13:54,696 --> 00:13:57,963
那么，如果我们还在眨眼，我们需要再次闪烁。

309
00:13:58,032 --> 00:14:00,866
所以，我们需要，基本上需要再次调用blinkIfNeeded，但是

310
00:14:00,935 --> 00:14:02,534
我们必须等待我们的openDuration，

311
00:14:02,602 --> 00:14:04,435
离开我们的眼睛那么久，然后，

312
00:14:04,504 --> 00:14:06,871
如果我们还在闪烁，那么我们会再次闪烁。

313
00:14:06,940 --> 00:14:07,905
所以再次闪烁

314
00:14:07,974 --> 00:14:11,041
所以，我要在这里做另外一个计时器，

315
00:14:11,110 --> 00:14:12,609
这是完美的。

316
00:14:12,677 --> 00:14:15,144
即使我正在执行关闭包

317
00:14:15,213 --> 00:14:18,147
在未来0.4秒，我没有法律说

318
00:14:18,216 --> 00:14:20,616
那闭包我不能安排另一个计时器，

319
00:14:20,684 --> 00:14:22,417
这正是我要做的。

320
00:14:22,486 --> 00:14:25,320
而这一个，BlinkRate.openDuration，

321
00:14:25,388 --> 00:14:28,055
所以我只是等待开放时间，

322
00:14:28,124 --> 00:14:29,790
再次不重复

323
00:14:29,859 --> 00:14:33,861
好吧，然后在这个家伙的闭包，我也会

324
00:14:33,930 --> 00:14:36,963
用拖尾闭包符号，定时器。

325
00:14:37,032 --> 00:14:39,867
而且，我们继续做weak self，

326
00:14:39,935 --> 00:14:42,869
我们不会知道我们会想要那个In

327
00:14:42,937 --> 00:14:46,105
在这里我只会说self.blinkIfNeeded。

328
00:14:46,174 --> 00:14:48,740
当然，如果这样，它会停止闪烁

329
00:14:48,809 --> 00:14:52,544
这里的任何一点，闪烁已经设置为false，好吗？

330
00:14:52,613 --> 00:14:55,346
所以，这总是会一眨眼，然后如果需要的话

331
00:14:55,415 --> 00:14:58,182
二，这样做会回去再做一次眨眼。

332
00:14:58,251 --> 00:15:00,352
那么，是的，在这个weak。

333
00:15:02,088 --> 00:15:02,753
好的，我们得到这个代码。

334
00:15:02,821 --> 00:15:04,587
所以，就是这样，这就是我们需要做的眨眼，

335
00:15:04,656 --> 00:15:05,889
我们要打开

336
00:15:05,958 --> 00:15:07,423
我们只是闭上眼睛，

337
00:15:07,492 --> 00:15:08,091
等一下，

338
00:15:08,159 --> 00:15:10,025
打开他们，再等一下

339
00:15:10,094 --> 00:15:12,528
然后如果仍然闪烁，则再次闪烁。

340
00:15:12,596 --> 00:15:13,762
所以让我们看看看起来像什么。

341
00:15:22,405 --> 00:15:23,203
好的，他在。

342
00:15:23,272 --> 00:15:24,038
他在眨眼

343
00:15:26,041 --> 00:15:27,174
好的，他会工作的。

344
00:15:27,242 --> 00:15:28,841
在这里，我们只需要切换他。

345
00:15:28,910 --> 00:15:30,676
他无论如何工作。

346
00:15:30,745 --> 00:15:32,611
他是快乐还是悲伤，他总是眨眼。

347
00:15:34,281 --> 00:15:36,081
现在，关于这个眨眼的一件事情并不是这样

348
00:15:36,150 --> 00:15:38,382
好的是有点突然。

349
00:15:38,451 --> 00:15:40,251
这就是为什么我说这不是真的动画，对吧？

350
00:15:41,220 --> 00:15:42,286
我们不会这样眨眼。

351
00:15:43,522 --> 00:15:45,121
好的，没有人像这样闪烁。

352
00:15:45,189 --> 00:15:47,122
好的，我们闭上眼睛有点慢。

353
00:15:47,191 --> 00:15:48,691
有一点点动作。

354
00:15:48,759 --> 00:15:50,225
所以我们真的很想这样做。

355
00:15:50,294 --> 00:15:53,461
所以让我们来谈一些更多的动画功能

356
00:15:53,530 --> 00:15:57,565
有和我们如何做真正更真实的动画，

357
00:15:57,634 --> 00:15:58,566
而不仅仅是使用定时器。

358
00:15:58,635 --> 00:16:01,702
所以让我们回到我们的幻灯片。

359
00:16:05,074 --> 00:16:07,773
好的，所以在我这样做之前，让我谈谈和

360
00:16:07,842 --> 00:16:12,345
总结并不是所有的实际，但大部分的动画

361
00:16:12,414 --> 00:16:14,714
使用iOS的功能，

362
00:16:14,783 --> 00:16:17,249
所以当我要详细谈谈的时候

363
00:16:17,318 --> 00:16:20,785
演示今天是动画UIView属性。

364
00:16:20,854 --> 00:16:23,788
只有几个属性Vars，

365
00:16:23,857 --> 00:16:26,858
换句话说，在UIView你可以动画。

366
00:16:26,926 --> 00:16:29,260
但是，他们的功能很强大，你会看到，而且

367
00:16:29,329 --> 00:16:32,196
让我们做的很多动画。

368
00:16:32,264 --> 00:16:34,731
还有，你也可以明显地动画那些

369
00:16:34,800 --> 00:16:37,333
控制器动画，如导航控制器当中

370
00:16:37,402 --> 00:16:40,803
您点击进入堆叠上的下一张卡，

371
00:16:40,872 --> 00:16:43,739
它滑动，对吗，这是动画。

372
00:16:43,808 --> 00:16:46,808
当你旋转分割视图时，它们是动画的

373
00:16:46,877 --> 00:16:48,843
转换，这都是可控的。

374
00:16:48,912 --> 00:16:50,195
即使我不会在这个课上谈论它，

375
00:16:50,196 --> 00:16:51,479
其实，

376
00:16:51,548 --> 00:16:52,546
可能是一个很好的最终项目，

377
00:16:52,615 --> 00:16:54,448
没有为你讲课的事情，顺便说一句。

378
00:16:56,118 --> 00:16:57,584
你有一个完整的基础设施

379
00:16:57,652 --> 00:17:00,787
编写自己的控制器控制器，

380
00:17:00,856 --> 00:17:02,621
像导航控制器，分路控制器，

381
00:17:02,690 --> 00:17:03,855
标签栏控制器。

382
00:17:03,924 --> 00:17:04,956
所以，其中的一部分

383
00:17:05,025 --> 00:17:07,692
机制包括完整的动画支持。

384
00:17:07,761 --> 00:17:10,561
现在，我所说的所有这个动画都在下面

385
00:17:10,630 --> 00:17:12,863
核心动画，它是一个框架，好吗？

386
00:17:12,932 --> 00:17:14,965
像UI一样的框架。

387
00:17:15,033 --> 00:17:17,768
而核心动画有很多机制

388
00:17:17,836 --> 00:17:19,602
做非常复杂的动画。

389
00:17:19,671 --> 00:17:22,939
现在，UI界面不是很多

390
00:17:23,008 --> 00:17:24,907
我们将要谈论的动画，但是

391
00:17:24,976 --> 00:17:27,710
最简单的一种最直接的一次。

392
00:17:27,778 --> 00:17:31,346
再次，这是你最后一个项目的东西，也许你

393
00:17:31,415 --> 00:17:33,848
想做一些更复杂的动画。

394
00:17:33,917 --> 00:17:37,017
你可以放下核心的动画片

395
00:17:37,086 --> 00:17:40,721
有一点关于窗口

396
00:17:40,790 --> 00:17:45,059
来自UI视图的核心动画。

397
00:17:45,128 --> 00:17:51,531
这是在UI视图中的一个吧

398
00:17:51,600 --> 00:17:58,538
我认为这是叫的

399
00:17:58,607 --> 00:18:03,609
很多的工作

400
00:18:03,678 --> 00:18:09,181
做3D动画。

401
00:18:09,250 --> 00:18:12,951
OpenGL作为完整的OpenGL >> [COUGH]

402
00:18:13,020 --> 00:18:14,786
>>还有一个很酷的小

403
00:18:14,854 --> 00:18:18,222
工具包可能会将其放在你最后的一些项目中

404
00:18:18,291 --> 00:18:22,026
spritekit，spritekit是一种典型的2.5 D动画

405
00:18:22,095 --> 00:18:25,763
动画，我们喜欢小字符运行和

406
00:18:25,832 --> 00:18:29,466
他跳过东西，拍摄的东西。

407
00:18:29,535 --> 00:18:31,902
这可能是用spritekit完成的，

408
00:18:31,971 --> 00:18:34,504
它知道如何做像火一样的事情。

409
00:18:34,573 --> 00:18:37,239
除了知道如何层层之外的事情

410
00:18:37,308 --> 00:18:39,408
彼此之间的图像，并让他们四处移动。

411
00:18:39,477 --> 00:18:42,344
所以这很有趣，不可以说这个。

412
00:18:42,413 --> 00:18:46,348
最后是基于物理的动画，我们是

413
00:18:46,416 --> 00:18:48,115
在这个讲座结束时，会讲一下这个

414
00:18:48,184 --> 00:18:49,917
那么我星期三就会演示。

415
00:18:49,986 --> 00:18:51,418
所以我要说的是第一个和第二个

416
00:18:51,487 --> 00:18:53,920
最后一个，UIView动画，和

417
00:18:53,989 --> 00:18:55,889
然后是基于物理的动画。

418
00:18:57,259 --> 00:18:59,626
好的，让我们来谈谈这个UIView动画。

419
00:18:59,694 --> 00:19:01,226
你能动画吗

420
00:19:01,295 --> 00:19:03,095
嗯，这些是你可以动画的东西。

421
00:19:03,164 --> 00:19:05,229
您可以对视图的位置进行动画处理。

422
00:19:05,298 --> 00:19:07,732
所以，你可以使它动画，移动，

423
00:19:07,801 --> 00:19:09,333
在屏幕上滑动。

424
00:19:09,402 --> 00:19:10,834
视图移动。

425
00:19:10,903 --> 00:19:13,204
你可以动画化它的变形，

426
00:19:13,272 --> 00:19:17,140
这主要是指它的大小或旋转。

427
00:19:17,209 --> 00:19:19,175
好的？ Cuz的翻译部分

428
00:19:19,243 --> 00:19:20,476
运输，改造，

429
00:19:20,544 --> 00:19:23,012
你几乎要用框架或中心，好吗？

430
00:19:23,081 --> 00:19:27,515
所以你可以旋转你的视图或上下缩放。

431
00:19:27,584 --> 00:19:29,117
有阿尔法，好吧。

432
00:19:29,186 --> 00:19:31,853
阿尔法你记得号码是我不记得是不透明度。

433
00:19:31,922 --> 00:19:36,124
又怎样

434
00:19:36,192 --> 00:19:41,662
太多了

435
00:19:41,731 --> 00:19:49,703
透明。

436
00:19:49,772 --> 00:19:52,505
所以，要闭包。

437
00:19:52,574 --> 00:19:53,573
而在这些闭包之内，

438
00:19:53,642 --> 00:19:56,008
你会改变这些值，好的。

439
00:19:56,077 --> 00:19:58,444
那个方法，方法怎么办，

440
00:19:58,513 --> 00:20:02,047
是你做出的这些变化的动画。

441
00:20:02,116 --> 00:20:03,448
好的，让我们来看看

442
00:20:03,517 --> 00:20:05,016
在这些类的方法之一。

443
00:20:05,085 --> 00:20:07,485
这个被称为动画与Duration。

444
00:20:07,553 --> 00:20:10,922
你可以看到这里需要这两个

445
00:20:10,990 --> 00:20:12,389
闭包在那里

446
00:20:12,458 --> 00:20:14,324
你看到两个绿色闭包？

447
00:20:14,392 --> 00:20:16,960
而那里的第一个绿色闭包，

448
00:20:17,028 --> 00:20:20,864
在那里，你改变那些特殊的vars，好吗？

449
00:20:20,932 --> 00:20:23,833
框架，中心，阿尔法等，你改变它们。

450
00:20:23,902 --> 00:20:25,367
顺便说一句，它会立即进行这些更改。

451
00:20:25,436 --> 00:20:27,635
改变它们不需要时间。

452
00:20:27,704 --> 00:20:28,937
即使需要时间

453
00:20:29,006 --> 00:20:31,205
它出现在屏幕上它立即发生。

454
00:20:31,274 --> 00:20:34,075
然后调用完成块

455
00:20:34,144 --> 00:20:36,309
动画完成后。

456
00:20:36,378 --> 00:20:38,645
所以，你知道，但是你所拍摄的动画

457
00:20:38,713 --> 00:20:40,212
完全完成

458
00:20:40,281 --> 00:20:43,149
然后这个被调用和完成

459
00:20:43,217 --> 00:20:45,651
变量，将完成的参数作为该闭包的参数

460
00:20:45,720 --> 00:20:48,787
动画是否一直到最后。

461
00:20:48,856 --> 00:20:50,688
为什么可能不会到最后？

462
00:20:50,757 --> 00:20:52,790
一些其他动画可能会在中间挑选

463
00:20:52,859 --> 00:20:55,826
开始动画到另一个地方。

464
00:20:55,895 --> 00:20:57,461
好的，所以，这就是它的样子。

465
00:20:57,530 --> 00:20:59,362
要说，这是一个例子。

466
00:20:59,431 --> 00:21:01,030
所以，这里我有一个名为myView的视图。

467
00:21:01,099 --> 00:21:04,835
[SOUND]我在这里的代码是什么，

468
00:21:04,903 --> 00:21:08,037
只要它完全不透明，我就会看到，

469
00:21:08,106 --> 00:21:11,640
屏幕上完全可见，我要等待两秒钟。

470
00:21:11,709 --> 00:21:15,210
然后，三点钟以后，我会淡出来。

471
00:21:15,279 --> 00:21:17,245
将其淡化为alpha，最低为零。

472
00:21:17,314 --> 00:21:18,613
然后，当它完全淡出时，

473
00:21:18,681 --> 00:21:21,616
我会从视图层次结构中删除它，好吗？

474
00:21:21,685 --> 00:21:22,917
这就是这个代码。

475
00:21:22,985 --> 00:21:26,553
所以，你可以看到，

476
00:21:26,622 --> 00:21:28,422
所以，如果它是全功率的

477
00:21:28,490 --> 00:21:31,457
如果是，那么我正在做动画片的持续时间。

478
00:21:31,526 --> 00:21:32,625
持续时间为三秒，

479
00:21:32,694 --> 00:21:34,660
这是多久它会采取这个，

480
00:21:34,729 --> 00:21:37,529
绿色代码在那里执行，不执行，

481
00:21:37,598 --> 00:21:39,030
但要显示在屏幕上。

482
00:21:39,099 --> 00:21:41,466
然后延迟是我要等待多久，直到我开始

483
00:21:41,534 --> 00:21:43,234
动画。

484
00:21:43,303 --> 00:21:44,552
我们将在几张幻灯片中谈论所有关于选项。

485
00:21:44,553 --> 00:21:45,802
选项，

486
00:21:45,872 --> 00:21:49,172
但是在这里，线性线性意味着它会从...开始

487
00:21:49,241 --> 00:21:52,976
线性，线性随时间变化的α1到1.0。

488
00:21:53,045 --> 00:21:55,478
所以一秒钟之后，它将会是三分之一。

489
00:21:55,546 --> 00:21:57,813
两秒钟后，这将是三分之二的方式。

490
00:21:57,882 --> 00:21:59,648
在全职之后，它会降到零。

491
00:22:01,252 --> 00:22:03,351
在动画中，您可以看到我是动画。

492
00:22:03,420 --> 00:22:06,387
我正在将alpha更改为零，好吗？

493
00:22:06,455 --> 00:22:09,356
这是我对这些特殊bar的变化。

494
00:22:09,425 --> 00:22:12,058
然后在完成你可以说，如果$ 0，这意味着如果我

495
00:22:12,127 --> 00:22:16,397
完成后，从Superview中删除此视图。

496
00:22:16,465 --> 00:22:18,298
并记住，完成的诀窍只是

497
00:22:18,366 --> 00:22:20,032
在动画完成后调用。

498
00:22:20,101 --> 00:22:21,934
换句话说，从现在开始五秒钟。

499
00:22:23,337 --> 00:22:24,502
好吧？

500
00:22:24,571 --> 00:22:26,605
现在真正有趣的是在我的下一行

501
00:22:26,673 --> 00:22:30,708
说print myView.alpha等于myView.alpha的值，

502
00:22:30,777 --> 00:22:35,880
那就是立即打印零，好吗？

503
00:22:35,948 --> 00:22:38,983
该方法与Duration一起动画，它只执行

504
00:22:39,051 --> 00:22:42,453
第一个绿色关闭在那里，myView.alpha = 0.0，

505
00:22:42,521 --> 00:22:45,988
之后立即返回。

506
00:22:46,057 --> 00:22:47,991
而在这一点上，myView.alpha是0.0。

507
00:22:48,059 --> 00:22:52,261
这个动画在未来排队等候。

508
00:22:52,330 --> 00:22:55,163
所以总是想想你用动画做的变化

509
00:22:55,232 --> 00:22:56,998
系统正在发生。

510
00:22:57,067 --> 00:22:59,300
你现在只是执行那个更近，但是

511
00:22:59,369 --> 00:23:01,703
把它放在这个动画的这个小包装里

512
00:23:01,771 --> 00:23:04,772
持续时间，你正在排队一个动画来显示

513
00:23:04,840 --> 00:23:09,109
用户更改您已经做了一段时间。

514
00:23:09,178 --> 00:23:11,711
现在看来有点奇怪，因为哇，

515
00:23:11,780 --> 00:23:15,114
我现在改变了，所以我的代码中的alpha是零，

516
00:23:15,183 --> 00:23:18,084
但用户仍然完全看到它。

517
00:23:18,153 --> 00:23:20,386
他们做的不透明，五秒钟。

518
00:23:20,454 --> 00:23:23,589
它仍然是不透明的，直到它完全淡出。

519
00:23:23,658 --> 00:23:24,823
但这只是这个方法。

520
00:23:24,892 --> 00:23:26,058
你只好习惯了

521
00:23:26,126 --> 00:23:28,593
动画总是发生在事后，

522
00:23:28,661 --> 00:23:29,927
随着时间的流逝，好吗？

523
00:23:29,995 --> 00:23:31,696
但是您所做的更改会立即发生。

524
00:23:33,532 --> 00:23:35,231
好吧？

525
00:23:35,300 --> 00:23:38,468
这里有一些我们可以做的选择，当我们动画，

526
00:23:38,537 --> 00:23:40,036
我谈到了曲线，

527
00:23:40,104 --> 00:23:41,671
在它的正下方，

528
00:23:41,739 --> 00:23:45,641
你看到curveEaseInEaseOut和curveEaseIn。

529
00:23:45,709 --> 00:23:48,509
这些基本上都是这样做的，而不是只是线性的

530
00:23:48,578 --> 00:23:51,412
从起始值到该var的最终值

531
00:23:51,481 --> 00:23:54,215
改变，慢慢开始，然后上升到正常速度，

532
00:23:54,283 --> 00:23:57,117
然后现在减慢，为什么要这样？

533
00:23:57,186 --> 00:23:58,452
这是特别好的

534
00:23:58,520 --> 00:24:00,520
移动，当你移动视图。

535
00:24:00,589 --> 00:24:03,623
你不想让一个视图在屏幕上，并且[声音]。

536
00:24:03,691 --> 00:24:06,659
你想要走，然后慢慢减速。

537
00:24:06,727 --> 00:24:08,660
只是觉得，如果你在现实生活中移动某物，

538
00:24:08,729 --> 00:24:11,563
如果你不在这里，你提起来，

539
00:24:11,631 --> 00:24:12,731
然后，你把它放下。

540
00:24:12,799 --> 00:24:13,597
同样的事情在这里

541
00:24:13,666 --> 00:24:15,499
你想把它举起来，把它移开，和

542
00:24:15,568 --> 00:24:16,567
然后把它放下，好吗？

543
00:24:16,636 --> 00:24:18,335
所以，这就是为什么曲线缓和，缓解。

544
00:24:18,404 --> 00:24:22,071
所以，你可以控制它是否在任何一端有所缓和。

545
00:24:22,140 --> 00:24:24,640
从顶部开始，从当前状态开始。

546
00:24:24,709 --> 00:24:27,310
记得我说完了，

547
00:24:27,379 --> 00:24:30,045
完成处理程序的参数

548
00:24:30,113 --> 00:24:32,180
只有在动画完成的情况下才是真实的。

549
00:24:32,249 --> 00:24:35,317
那么，如果你在这个时再发一个动画

550
00:24:35,385 --> 00:24:38,452
那些像以前那样的人还在飞行中

551
00:24:38,521 --> 00:24:39,770
如果你发出另一个改变其他的alpha

552
00:24:39,771 --> 00:24:41,020
五秒钟。

553
00:24:41,089 --> 00:24:43,723
方式，好吧，这个动画将从...开始

554
00:24:43,792 --> 00:24:47,293
α的新值为零。

555
00:24:47,362 --> 00:24:49,361
好的，尽管它还在飞行中

556
00:24:49,430 --> 00:24:52,498
没有向用户显示零，仍然为零。

557
00:24:52,567 --> 00:24:55,601
或者，无论是动画的alpha，新的动画

558
00:24:55,670 --> 00:24:57,636
要去另一个人的地方拿起来，好吗？

559
00:24:57,704 --> 00:25:00,739
换句话说，这将是中途飞行

560
00:25:00,807 --> 00:25:02,473
使阿尔法去别的地方。

561
00:25:02,542 --> 00:25:05,209
那就是从现在开始的那个说我该怎么办

562
00:25:05,278 --> 00:25:09,113
看看用户觉得或正在看到什么

563
00:25:09,181 --> 00:25:11,515
作为这个alpha，或者我应该使用真正的alpha，

564
00:25:11,584 --> 00:25:13,050
已经改为零？

565
00:25:14,052 --> 00:25:14,884
好的。

566
00:25:14,953 --> 00:25:17,186
所以你可以查看文档

567
00:25:17,255 --> 00:25:19,587
所有这些选择，我想有25个，

568
00:25:19,656 --> 00:25:21,923
所以有很多很酷的东西你可以在那里做。

569
00:25:21,992 --> 00:25:23,090
我们还会再谈一些

570
00:25:23,159 --> 00:25:25,726
其他一些UIView动画。

571
00:25:25,795 --> 00:25:27,394
好吧。那就是UIView动画

572
00:25:27,463 --> 00:25:31,999
你在那里动画这五个特别的bar之一。

573
00:25:32,067 --> 00:25:35,268
所以这是UIView动画的另一件事情，

574
00:25:35,336 --> 00:25:38,270
是如果我有一个看法，而且Imma改变了很多

575
00:25:38,339 --> 00:25:41,073
关于它的事情，不只是那些特殊的酒吧

576
00:25:41,142 --> 00:25:42,908
以不同的方式重绘，和

577
00:25:42,976 --> 00:25:46,177
我想在屏幕上动画化整个变化。

578
00:25:46,246 --> 00:25:47,946
还有一些方法可以让它动画化。

579
00:25:48,015 --> 00:25:51,215
一个，你可以通过翻转来动画化。

580
00:25:51,284 --> 00:25:52,750
那么像一张飞机卡，

581
00:25:52,818 --> 00:25:55,152
将从旧观念翻转。

582
00:25:55,220 --> 00:25:56,553
做所有的更改，翻转。

583
00:25:56,622 --> 00:25:58,054
显示新的。

584
00:25:58,123 --> 00:26:00,289
另一个是交叉溶解。

585
00:26:00,358 --> 00:26:01,591
好的老一个显示。

586
00:26:01,659 --> 00:26:06,562
然后新的一个溶解在另一个是卷曲。

587
00:26:06,631 --> 00:26:09,597
新的一种是在后面。

588
00:26:09,666 --> 00:26:11,233
老人坐在前面

589
00:26:11,301 --> 00:26:14,635
而老人像一张纸和表演一样卷曲起来

590
00:26:14,704 --> 00:26:17,671
一部分新的在后面，这是一种乐趣。

591
00:26:17,740 --> 00:26:19,839
如果你这样做，这个过渡真的很有意义

592
00:26:19,908 --> 00:26:21,575
覆盖整个屏幕。

593
00:26:21,644 --> 00:26:25,544
卷曲起来就好像没有意义

594
00:26:25,613 --> 00:26:27,080
查看另一个视图。

595
00:26:27,149 --> 00:26:29,148
整个屏幕是一个视图，

596
00:26:29,217 --> 00:26:31,851
你想要卷曲会有意义吗？

597
00:26:31,919 --> 00:26:36,121
所以，这是整个视图内容动画，

598
00:26:36,190 --> 00:26:38,657
不只是那些特别的事情。

599
00:26:39,926 --> 00:26:41,491
它是用类方法完成的。

600
00:26:41,560 --> 00:26:43,727
它被称为动画宽度。

601
00:26:43,795 --> 00:26:46,129
这是，抱歉，转换宽度。

602
00:26:46,198 --> 00:26:47,296
不是动画。

603
00:26:47,365 --> 00:26:50,132
而转换宽度则认为它具有所有的东西

604
00:26:50,201 --> 00:26:51,500
你想改变

605
00:26:51,569 --> 00:26:52,468
时间显然，

606
00:26:52,536 --> 00:26:54,202
一些选择，如你是否卷曲或

607
00:26:54,271 --> 00:26:57,038
交叉溶解或翻转和

608
00:26:57,106 --> 00:27:00,041
那么现在的动画在这种情况下是绿色的动画

609
00:27:00,110 --> 00:27:02,343
可以改变任何关于视图。

610
00:27:02,412 --> 00:27:03,743
不只是五个特殊的东西，但是

611
00:27:03,812 --> 00:27:05,412
绝对什么

612
00:27:05,480 --> 00:27:07,046
这就是这些动画在那里做的，

613
00:27:07,115 --> 00:27:09,382
然后完成是一样的。

614
00:27:09,451 --> 00:27:12,652
好的，当动画完成它告诉你。

615
00:27:12,720 --> 00:27:15,354
那么这就是我所说的一个例子

616
00:27:15,422 --> 00:27:16,154
一个扑克游戏和

617
00:27:16,223 --> 00:27:18,923
我想显示一张扑克牌的扑克牌。

618
00:27:18,992 --> 00:27:20,425
所以让我们有一张纸牌

619
00:27:20,493 --> 00:27:22,260
在那里查看myPlayingCardView。

620
00:27:22,328 --> 00:27:25,563
它有一些酒吧它的CardIsFaceUp和

621
00:27:25,631 --> 00:27:28,231
如果卡片面对这个真实的话，那我就看到了

622
00:27:28,300 --> 00:27:30,166
国王和王牌的心或其他。

623
00:27:30,235 --> 00:27:31,968
如果卡片正面朝下，那我就明白了

624
00:27:32,036 --> 00:27:32,968
卡的背面。

625
00:27:33,037 --> 00:27:34,103
所以我得到这个视图。

626
00:27:34,171 --> 00:27:36,438
我目前在一边和另一边

627
00:27:36,507 --> 00:27:39,174
我想要翻转并显示另一个状态。

628
00:27:39,242 --> 00:27:42,911
这里所有我做的是我做动画我做过渡宽度

629
00:27:42,979 --> 00:27:43,978
我的扑克牌视图

630
00:27:44,047 --> 00:27:46,212
我会在三分之一秒钟内完成。

631
00:27:46,281 --> 00:27:48,982
所以它会很快翻转过来。

632
00:27:49,051 --> 00:27:51,318
我使用从左边的过渡翻转选项，

633
00:27:51,386 --> 00:27:54,554
它将左边缘翻转过来。

634
00:27:54,623 --> 00:27:55,788
然后在动画里面

635
00:27:55,857 --> 00:27:58,657
我只是改变那个cardIsFaceUp吧，

636
00:27:58,726 --> 00:28:02,093
控制我的观点显示的是什么。

637
00:28:02,162 --> 00:28:03,828
所以这将要翻转

638
00:28:03,897 --> 00:28:07,766
显示卡在另一个方向，好吗？

639
00:28:07,834 --> 00:28:09,033
那么很酷，那就是你想改变的时候

640
00:28:09,101 --> 00:28:10,501
整个视图。

641
00:28:10,569 --> 00:28:12,869
但你甚至限制你知道什么，

642
00:28:12,938 --> 00:28:15,738
你可以做的动画，只是翻转，溶解和

643
00:28:15,807 --> 00:28:17,173
卷曲在全屏幕。

644
00:28:19,076 --> 00:28:20,375
还有另外一种想改变的视图

645
00:28:20,376 --> 00:28:21,675
好吧，

646
00:28:21,745 --> 00:28:23,044
是更改查看层次结构。

647
00:28:23,113 --> 00:28:26,080
所以，这意味着你想把意见或看法

648
00:28:26,149 --> 00:28:29,016
视图层次结构或将另一视图替换为另一视图。

649
00:28:29,085 --> 00:28:32,920
所以这个方法是从两个过渡。

650
00:28:32,988 --> 00:28:34,988
所以从这个角度来看，这个观点将会是

651
00:28:35,057 --> 00:28:37,524
离开视图层次结构，两个视图是

652
00:28:37,592 --> 00:28:39,892
这个观点将要进入层次结构。

653
00:28:39,961 --> 00:28:41,494
他们不必在同一个地方，顺便说一下，

654
00:28:41,563 --> 00:28:43,261
他们可以在屏幕上的不同地方，

655
00:28:43,330 --> 00:28:45,597
这是绝对好的。

656
00:28:45,666 --> 00:28:47,765
通常他们在同一个地方。

657
00:28:47,834 --> 00:28:52,503
而这个动画在这里你注意到没有

658
00:28:52,572 --> 00:28:56,073
动画块因为隐含的你在做什么

659
00:28:56,142 --> 00:28:58,742
在这个动画中替换另一个视图。

660
00:28:58,810 --> 00:29:02,011
我从一个角度来看待另一个观点，所以你得到了新的

661
00:29:02,080 --> 00:29:03,813
查看所有设置您想要的方式和

662
00:29:03,881 --> 00:29:06,515
你有旧视图，你只是过渡。

663
00:29:06,584 --> 00:29:09,552
现在，有时你不想实际删除这些

664
00:29:09,620 --> 00:29:11,787
从层次结构，你只是想显示和隐藏他们。

665
00:29:11,855 --> 00:29:15,724
所以在你放置的选项.showHideTransitionViews。

666
00:29:15,793 --> 00:29:18,660
然后，而不是从父视图中删除

667
00:29:18,729 --> 00:29:22,497
添加子视图，它只会设置.hidden。

668
00:29:22,565 --> 00:29:25,532
记住视图有一个隐藏的吧。

669
00:29:25,601 --> 00:29:29,170
它会设置一个隐藏，一个隐藏。

670
00:29:29,238 --> 00:29:30,937
好吧？

671
00:29:31,006 --> 00:29:33,439
我不知道也许这个属性被称为

672
00:29:33,508 --> 00:29:34,574
这些天，无论如何。

673
00:29:34,642 --> 00:29:37,710
好的，所以这些都是使动画视图的方法

674
00:29:37,778 --> 00:29:41,413
我们来看看在FaceIt里做几个这样的事情

675
00:29:41,482 --> 00:29:44,683
首先我会在那里做动画

676
00:29:47,120 --> 00:29:50,020
改变整个视图，并进行翻转或

677
00:29:50,089 --> 00:29:53,524
交叉溶解，使眨眼更加顺畅。

678
00:29:53,593 --> 00:29:55,693
我要做的是我要两只眼睛

679
00:29:55,761 --> 00:29:59,229
在我的脸上，用意见来代替它们，画出眼睛，

680
00:29:59,297 --> 00:30:01,531
然后我会改变视图

681
00:30:01,600 --> 00:30:04,700
打开关闭从顶部翻转。

682
00:30:04,769 --> 00:30:06,869
看看怎么会让眼睛眨了眨眼。

683
00:30:06,937 --> 00:30:07,869
它会翻转

684
00:30:07,938 --> 00:30:10,838
那个小圆圈会像这样翻转。

685
00:30:10,907 --> 00:30:12,207
然后，我们要摇头。

686
00:30:12,275 --> 00:30:13,407
这是一个2D头，所以

687
00:30:13,476 --> 00:30:16,510
它会一起摇摆而不是像这样。

688
00:30:16,579 --> 00:30:17,478
Cuz只是2D。

689
00:30:17,546 --> 00:30:19,178
我们会用我们所在的地方去做

690
00:30:19,247 --> 00:30:21,147
会改变一个特殊的bar。

691
00:30:21,216 --> 00:30:23,449
我们要改变的bar是因为我们要改变的

692
00:30:23,518 --> 00:30:25,584
旋转我们的整个脸。

693
00:30:25,653 --> 00:30:26,686
好的，我们来做这些。

694
00:30:28,422 --> 00:30:32,223
让我们回到Xcode这里。

695
00:30:32,292 --> 00:30:38,095
好的，所以，要眼睛眨眼，我们需要

696
00:30:38,164 --> 00:30:42,934
有眼睛不被画出来，所以现在，如果我们去，哎呀，

697
00:30:43,002 --> 00:30:46,437
如果我们在这里访问我们的FaceView，你可以看到我们

698
00:30:46,506 --> 00:30:50,074
通过这样做UIBezierPath来画我们的眼睛吗？

699
00:30:50,142 --> 00:30:52,441
然后在这里，如果你记得在画，

700
00:30:52,510 --> 00:30:54,010
我们得到了我的路径。

701
00:30:56,513 --> 00:30:58,280
而对于我而言，我们都是中风。

702
00:30:58,348 --> 00:31:00,181
所以我们不会这样做了。

703
00:31:00,250 --> 00:31:04,385
相反，我们将添加两个我的视图，我将要展示

704
00:31:04,454 --> 00:31:07,321
你在一秒钟，作为这个阶段视图的子视图。

705
00:31:07,390 --> 00:31:08,455
所以我们不会这样做

706
00:31:08,524 --> 00:31:09,489
我们不会需要这个。

707
00:31:09,558 --> 00:31:12,225
其实我要抢这个中心

708
00:31:12,294 --> 00:31:16,562
的眼睛，因为我还需要

709
00:31:16,631 --> 00:31:21,901
把我的新眼睛视图放在某个地方，知道如何做。

710
00:31:21,969 --> 00:31:23,770
所以其余的，虽然，我只是要评论。

711
00:31:24,706 --> 00:31:25,537
好的？

712
00:31:25,606 --> 00:31:27,638
所以我们没有使用这种机制

713
00:31:27,707 --> 00:31:29,040
绘画，相反，我们将会看到眼睛。

714
00:31:29,108 --> 00:31:33,610
现在为了兴趣的时间，我会拖动这个眼睛的视图。

715
00:31:33,679 --> 00:31:34,544
并显示给你。

716
00:31:34,613 --> 00:31:36,046
所以我们把它复制到这里。

717
00:31:36,115 --> 00:31:39,349
好的，那么这个EyeView是什么样的？

718
00:31:39,418 --> 00:31:42,518
超级简单，它也有线条，宽度和颜色，

719
00:31:42,587 --> 00:31:43,986
就像脸一样。

720
00:31:44,054 --> 00:31:45,654
有眼睛打开，

721
00:31:45,723 --> 00:31:47,556
这是Bool，无论是真的还是

722
00:31:47,624 --> 00:31:50,992
不是，而且如果眼睛是开放的，那么它就是拉直的

723
00:31:51,061 --> 00:31:55,396
使用一个实际上是圆的椭圆形贝塞尔路径，

724
00:31:55,465 --> 00:31:57,731
如果眼睛闭合，它只会移动到第二行。

725
00:31:57,800 --> 00:32:01,168
好的，这几乎是完全一样的代码

726
00:32:01,236 --> 00:32:04,271
The faceview，然后在这里设置它的一致

727
00:32:04,339 --> 00:32:07,673
设置它的颜色，抚摸颜色，然后抚摸它。

728
00:32:07,742 --> 00:32:09,308
这是什么？

729
00:32:09,377 --> 00:32:10,876
关于这段代码的任何问题？

730
00:32:10,945 --> 00:32:13,578
超级直截了当，好吗？

731
00:32:13,647 --> 00:32:19,084
所以我们需要在这里修改我们的面貌来使用那些眼睛，

732
00:32:19,153 --> 00:32:20,985
那些眼睛就是这样。

733
00:32:21,054 --> 00:32:23,254
那么我们该怎么办呢？

734
00:32:23,322 --> 00:32:26,056
这只是一个创建这些eyeViews的问题

735
00:32:26,125 --> 00:32:28,025
然后把它们放在正确的地方。

736
00:32:28,093 --> 00:32:29,259
好吧？所以

737
00:32:29,328 --> 00:32:30,727
我们先来创建它们。

738
00:32:30,796 --> 00:32:33,930
所以我会有一个私人的var，我会试图说，

739
00:32:35,566 --> 00:32:40,468
leftEye = createEye，然后调用私有func

740
00:32:40,537 --> 00:32:45,374
createEye返回一个EyeView让我们说好吧

741
00:32:47,044 --> 00:32:49,610
它会现在返回，我想做这个但是

742
00:32:49,679 --> 00:32:52,279
它不会工作，有人看到什么

743
00:32:52,348 --> 00:32:56,684
绝对不会这样工作的代码？

744
00:32:56,753 --> 00:32:58,285
好的，我在做什么

745
00:32:58,354 --> 00:33:01,721
我正在初始化leftEye吗？

746
00:33:01,789 --> 00:33:05,624
我允许我以前的自己的方法

747
00:33:05,693 --> 00:33:07,526
我完全初始化了

748
00:33:07,595 --> 00:33:12,297
不，好的，所以这就是为什么不会在那里工作。

749
00:33:12,366 --> 00:33:14,933
你可以看到错误是不能使用实例成员的

750
00:33:15,002 --> 00:33:17,802
'createEye'cuz属性初始化器在'self'之前运行

751
00:33:17,871 --> 00:33:18,503
是可用的

752
00:33:18,571 --> 00:33:20,404
这就是我们在这里的想法。

753
00:33:20,473 --> 00:33:25,141
所以修复这个是让这个lazy。

754
00:33:25,210 --> 00:33:29,612
因为如果你做这个lazy，它不会实际

755
00:33:29,681 --> 00:33:32,282
运行这个初始化，这个初始化是不会的

756
00:33:32,350 --> 00:33:34,651
运行，直到我们完全初始化。

757
00:33:34,719 --> 00:33:37,853
根据定义，因为没有人可以称之为LeftEye，

758
00:33:37,922 --> 00:33:39,822
没有人可以访问它，直到我们完全初始化为止。

759
00:33:39,890 --> 00:33:40,789
所以，那太棒了

760
00:33:40,858 --> 00:33:43,290
现在这还不行，好吗？

761
00:33:43,359 --> 00:33:45,560
为什么这不工作？

762
00:33:45,629 --> 00:33:46,627
这不工作，而且

763
00:33:46,696 --> 00:33:49,263
也许我们甚至会在这里看到一个错误，是的。

764
00:33:52,467 --> 00:33:53,633
好的，我们来看看

765
00:33:53,701 --> 00:33:55,935
所以你看到它说你不能使用成员createEye。

766
00:33:56,004 --> 00:34:00,939
当您做lazy变量时，您需要指定类型。

767
00:34:01,008 --> 00:34:01,907
好的，所以你需要说。

768
00:34:01,976 --> 00:34:03,908
你必须明确地键入。

769
00:34:03,977 --> 00:34:06,778
你不能，让它推断类型。

770
00:34:06,847 --> 00:34:07,478
那个东西

771
00:34:07,546 --> 00:34:08,713
现在，这里还有一个问题。

772
00:34:08,781 --> 00:34:09,813
另一个问题。

773
00:34:09,882 --> 00:34:13,049
这里说的就是用我的例子，

774
00:34:13,118 --> 00:34:15,318
成员在面视图上创建类型。

775
00:34:15,386 --> 00:34:16,285
键入面部视图。

776
00:34:16,354 --> 00:34:18,954
你是否意味着取而代之的是一个值。

777
00:34:19,023 --> 00:34:20,790
事实上，我们确实如此。

778
00:34:20,858 --> 00:34:23,792
它试图找到一个静态函数

779
00:34:23,861 --> 00:34:25,660
createEye吧？

780
00:34:25,729 --> 00:34:26,961
静态功能。

781
00:34:27,030 --> 00:34:27,795
但我们不想要这样。

782
00:34:27,864 --> 00:34:29,029
我们想要一个实例，

783
00:34:29,098 --> 00:34:31,832
我们指定的方式是与self。

784
00:34:31,901 --> 00:34:35,635
自我说我想要一个实例上的createEye

785
00:34:35,704 --> 00:34:37,671
这不是静态的。

786
00:34:39,673 --> 00:34:40,673
所以这可以有点复杂，就在那里。

787
00:34:40,674 --> 00:34:41,674
好的？

788
00:34:43,510 --> 00:34:48,446
让我们来看看，但只要知道这一点

789
00:34:48,514 --> 00:34:53,183
是绕过不得不写和的方式

790
00:34:53,252 --> 00:35:00,090
一个初始化器现在显然我没有提供一个框架，所以

791
00:35:00,159 --> 00:35:07,431
我必须在这里设置它的大小和位置。

792
00:35:07,500 --> 00:35:10,033
注意我的眼睛不会是不透明的。

793
00:35:11,169 --> 00:35:15,238
那是因为我，如果我的脸是蓝色的或

794
00:35:15,306 --> 00:35:17,540
有些东西，我想要那蓝色的表现。

795
00:35:17,608 --> 00:35:20,909
我不希望它是不透明的，所以这样

796
00:35:20,978 --> 00:35:23,811
除了以外，眼睛将是完全透明的

797
00:35:23,880 --> 00:35:27,749
我用非透明彩色墨水画的部分，

798
00:35:27,817 --> 00:35:28,616
基本上。

799
00:35:28,684 --> 00:35:32,118
我要把我的颜色设定为我脸上的颜色。

800
00:35:32,187 --> 00:35:35,889
我要把我的眼睛排列成相同的线条

801
00:35:35,957 --> 00:35:36,489
的脸。

802
00:35:36,558 --> 00:35:38,625
记住这里只是bar。

803
00:35:39,827 --> 00:35:42,494
和正面看法吗？

804
00:35:42,563 --> 00:35:43,896
颜色符合颜色。

805
00:35:45,132 --> 00:35:50,168
而且我也要加上

806
00:35:50,237 --> 00:35:55,439
subview，这个眼睛，因为我正在面对面我会

807
00:35:55,508 --> 00:35:59,009
将此子视图添加为我自己的子视图，我将返回

808
00:35:59,078 --> 00:36:02,713
眼睛因为这是createEye返回眼睛。

809
00:36:04,116 --> 00:36:06,583
好的，大家明白这个小方法？

810
00:36:06,651 --> 00:36:09,385
非常简单。我只是配置这个眼睛，

811
00:36:09,453 --> 00:36:12,053
并将其用于左眼和右眼。

812
00:36:12,122 --> 00:36:14,155
如何定位这只眼睛？

813
00:36:14,224 --> 00:36:17,391
在那里，我没有说这个眼睛在哪里。

814
00:36:17,460 --> 00:36:18,893
子视图在左上角大小为零，所以

815
00:36:18,894 --> 00:36:20,327
我加了它

816
00:36:20,396 --> 00:36:21,762
这不好

817
00:36:21,831 --> 00:36:24,264
让我们在这里创造私人空间。

818
00:36:24,333 --> 00:36:27,734
被称为positionEye，它是positionEye。

819
00:36:27,802 --> 00:36:29,902
你好。 PositionEye。

820
00:36:29,971 --> 00:36:34,239
而且会有一个眼睛，

821
00:36:34,308 --> 00:36:38,444
这将是一个眼睛。

822
00:36:38,512 --> 00:36:40,179
而且，它将要占据一席之地，

823
00:36:40,247 --> 00:36:43,448
在哪里把它的中心，将是一个CGPoint。

824
00:36:43,517 --> 00:36:46,217
我们需要获得眼睛的大小，以及大小

825
00:36:46,286 --> 00:36:48,786
眼睛的记忆取决于面部的大小，所以

826
00:36:48,855 --> 00:36:49,987
在大脸上，眼睛很大，

827
00:36:50,056 --> 00:36:52,956
在小脸上，眼睛很小，如果你记得

828
00:36:53,024 --> 00:36:57,293
我们有这些很好的小分数半径常数。

829
00:36:57,362 --> 00:36:58,894
所以，我有这个比例，

830
00:36:58,963 --> 00:37:03,466
分数半径到眼睛半径，记得吗？

831
00:37:03,535 --> 00:37:05,534
我要在这里说两个，我在说话

832
00:37:05,603 --> 00:37:09,605
关于我的观点的宽度和高度，和

833
00:37:09,674 --> 00:37:12,240
半径只有半径，而不是直径。

834
00:37:12,309 --> 00:37:14,209
所以我不得不在那里说两次。

835
00:37:14,277 --> 00:37:16,744
所以现在，我知道这个EyeView需要多大。

836
00:37:16,813 --> 00:37:20,481
所以我会说eye.frame = CGReft For

837
00:37:20,549 --> 00:37:25,151
现在我们要来的是CGPoint.zero，我会的，

838
00:37:25,220 --> 00:37:29,189
我会把它放在这个中心的第二个，但是

839
00:37:29,257 --> 00:37:32,691
现在我要把原点归零，和

840
00:37:32,760 --> 00:37:36,528
大小是一个CGSize，其中宽度是大小和

841
00:37:36,597 --> 00:37:43,002
高度是大小，它是正方形好现在

842
00:37:43,070 --> 00:37:49,073
我们只是将眼睛中心设置在那里的中心。

843
00:37:49,142 --> 00:37:50,542
好的，在那里有一个等号。

844
00:37:53,146 --> 00:37:54,345
这个小家伙就在这里，就要放眼了。

845
00:37:54,346 --> 00:37:55,545
可以，然后呢

846
00:37:55,615 --> 00:37:59,082
现在，我们什么时候想定位那个眼睛？

847
00:37:59,151 --> 00:38:01,284
好的，现在这很重要。

848
00:38:01,353 --> 00:38:03,652
当我们在视图控制器中时，我们知道我们什么时候

849
00:38:03,721 --> 00:38:06,155
我们顶级视图的界限变化，因为我们

850
00:38:06,224 --> 00:38:09,191
得到viewDidLayoutSubviews发送给我们，记住吗？

851
00:38:09,260 --> 00:38:12,060
如果我们看到这个faceView是一个视图，

852
00:38:12,129 --> 00:38:14,028
不是控制器，视图。

853
00:38:14,097 --> 00:38:16,998
它的边界随着发送变化而被告知

854
00:38:17,067 --> 00:38:19,300
消息，layoutSubviews。

855
00:38:20,470 --> 00:38:21,034
好的？

856
00:38:21,102 --> 00:38:22,435
所以，布局子视图，

857
00:38:22,504 --> 00:38:27,506
你说的发送到所有的意见，当它是有限的变化或

858
00:38:27,575 --> 00:38:30,843
任何时候，它的子视图需要被重新出现。

859
00:38:30,912 --> 00:38:32,110
这正是我们想要的，

860
00:38:32,179 --> 00:38:33,778
我们必须转出那些眼睛。

861
00:38:33,847 --> 00:38:37,481
我们必须把这些眼睛移到现在的位置。

862
00:38:37,550 --> 00:38:39,117
那么这个职位呢？

863
00:38:39,185 --> 00:38:43,020
我们只要说眼睛的位置，我们会这么做

864
00:38:43,089 --> 00:38:44,921
我们先做左眼。

865
00:38:44,990 --> 00:38:48,358
而为了得到眼睛的位置，我们有这个很好的方法，

866
00:38:48,427 --> 00:38:51,027
我们从我们的东西中抽出的眼睛的中心

867
00:38:51,096 --> 00:38:52,862
在这里评论道。

868
00:38:52,931 --> 00:38:56,532
它知道如何计算给定眼睛的位置。

869
00:38:56,601 --> 00:38:59,034
所以，我们只是说这里的位置是中心

870
00:38:59,103 --> 00:39:01,035
的眼睛。

871
00:39:01,104 --> 00:39:05,440
在这种情况下我们会说左眼。

872
00:39:05,509 --> 00:39:10,611
那没事，还有东西，对不起

873
00:39:10,680 --> 00:39:17,184
这是positionEye中心，好的，所以这是我们的左眼。

874
00:39:17,253 --> 00:39:18,519
现在我们来看看吧。

875
00:39:21,790 --> 00:39:23,857
好的，大家有这个

876
00:39:23,925 --> 00:39:25,992
所以每当我们的平衡发生变化，

877
00:39:26,060 --> 00:39:28,928
我们得到layoutSubviews，我们会移动这些眼睛

878
00:39:28,997 --> 00:39:30,429
到他们应该是哪里，

879
00:39:30,498 --> 00:39:34,700
centerOfEye的事情，好吗？

880
00:39:34,768 --> 00:39:36,300
我们得到了一个额外的参数，我想我没有，

881
00:39:36,369 --> 00:39:38,937
我做到了这一点。

882
00:39:40,273 --> 00:39:41,705
是的，这是有道理的。

883
00:39:41,774 --> 00:39:42,339
好的？

884
00:39:43,608 --> 00:39:44,607
好的，我们还需要做些什么？

885
00:39:44,676 --> 00:39:46,408
我们需要做的另外一件事就是，

886
00:39:46,477 --> 00:39:49,611
记住，眼睛想要具有相同的颜色

887
00:39:49,680 --> 00:39:50,879
是否与他们是否。

888
00:39:50,948 --> 00:39:52,847
打开面孔。

889
00:39:52,915 --> 00:39:56,617
好的，所有这些地方都在这里，我们睁开眼睛

890
00:39:56,686 --> 00:39:59,119
并且在那里设置颜色线，我们需要转发

891
00:39:59,188 --> 00:40:02,689
在我们的左眼和右眼，所以让我们在这里做

892
00:40:02,758 --> 00:40:04,057
颜色先。

893
00:40:04,126 --> 00:40:04,958
我们来这里吧

894
00:40:05,026 --> 00:40:08,027
现在，对于颜色，我们仍然需要setNeedDispaly，因为其他

895
00:40:08,096 --> 00:40:11,763
事物在视线之外除了眼睛是一定的颜色，

896
00:40:11,832 --> 00:40:12,932
嘴巴等等。

897
00:40:13,000 --> 00:40:13,965
但我们确实需要说，

898
00:40:14,034 --> 00:40:18,536
我们的左眼颜色等于这种新颜色。

899
00:40:18,605 --> 00:40:22,273
而且我们的右眼颜色也等于新的颜色

900
00:40:22,341 --> 00:40:24,241
完全一样。

901
00:40:24,310 --> 00:40:29,046
对于lineWidth，我们想说我们的左边

902
00:40:29,115 --> 00:40:33,383
eye的lineWidth等于我们的lineWidth和

903
00:40:33,452 --> 00:40:38,488
我们右眼的lineWidth等于我们的lineWidth。

904
00:40:38,557 --> 00:40:41,391
可能最重要的是，当眼睛被打开

905
00:40:41,459 --> 00:40:45,060
在我们的脸上闭上我们想要的那一套。

906
00:40:45,129 --> 00:40:49,298
在我们的观点中，现在，请注意，我们不需要setNeedsDisplay

907
00:40:49,367 --> 00:40:53,769
再次，因为我们不画我们的draw(_rect's.

908
00:40:53,837 --> 00:40:55,437
看到我们的 draw(_rect 在这里？

909
00:40:55,505 --> 00:40:56,404
我们评论过。

910
00:40:56,473 --> 00:40:57,305
我们不画眼睛。

911
00:40:57,373 --> 00:40:59,473
我们这两个视图吸引了眼睛

912
00:40:59,542 --> 00:41:01,241
添加了子视图。

913
00:41:01,310 --> 00:41:05,045
所以这里我们可以摆脱setNeedsDisplay。

914
00:41:05,113 --> 00:41:11,283
而我们只会说leftEye.eyesOpen =

915
00:41:11,352 --> 00:41:17,890
eyeOpen和rightEye.eyes打开=眼睛打开，好吗？

916
00:41:17,959 --> 00:41:21,494
看看我们如何将这些转发到这两个视图。

917
00:41:23,030 --> 00:41:24,595
对了，有什么问题吗？

918
00:41:24,664 --> 00:41:27,232
我们去确保我们没有破坏任何东西

919
00:41:27,300 --> 00:41:29,767
使我们的眼睛是分开的视图。

920
00:41:29,835 --> 00:41:31,935
我们的视图，整体我们的脸型应该看

921
00:41:32,004 --> 00:41:32,602
一模一样。

922
00:41:32,671 --> 00:41:35,272
只是使用子视图来绘制自己的一部分

923
00:41:35,340 --> 00:41:37,907
而不是绘制在DrawRec中。

924
00:41:37,975 --> 00:41:38,807
当然，它的工作正常。

925
00:41:38,876 --> 00:41:40,509
甚至连续眨眼也是如此

926
00:41:40,577 --> 00:41:42,077
闪烁由控制器完成。

927
00:41:42,145 --> 00:41:44,312
控制器设置睁开眼睛，闭上眼睛，

928
00:41:44,381 --> 00:41:46,781
眼睛闭上眼睛，正在转发。

929
00:41:46,850 --> 00:41:47,681
看到并正在闪烁。

930
00:41:47,750 --> 00:41:50,817
现在当然这个，我们还没有改变动画

931
00:41:50,886 --> 00:41:53,453
所以它仍然是这种instablink。

932
00:41:53,521 --> 00:41:56,356
所以现在我们要使用UI视图动画来做到这一点

933
00:41:56,425 --> 00:41:58,091
眨眼顺利。

934
00:41:58,160 --> 00:41:58,958
那么我们该怎么办呢？

935
00:41:59,027 --> 00:42:01,760
让我们来看看我们的眼睛。

936
00:42:01,829 --> 00:42:04,629
而每次眼睛开放都改变了，而不是只是

937
00:42:04,698 --> 00:42:07,865
改变它，我们将动画改变。

938
00:42:07,934 --> 00:42:09,667
所以我们要立即改变它。

939
00:42:09,735 --> 00:42:13,037
但是在屏幕上它将是动画，好吗？

940
00:42:13,105 --> 00:42:16,206
所以要这样做，我实际上会打开眼睛

941
00:42:16,275 --> 00:42:18,308
在那里和私人的var

942
00:42:18,377 --> 00:42:21,110
我要打开公众的眼睛。

943
00:42:21,179 --> 00:42:22,544
哪个是Bool和

944
00:42:22,613 --> 00:42:26,515
这件事情将是动画的事情。

945
00:42:26,584 --> 00:42:27,315
好的？

946
00:42:27,384 --> 00:42:29,851
而且，因为设置这个眼睛打开了

947
00:42:29,920 --> 00:42:31,653
需要显示，导致这一点，

948
00:42:31,722 --> 00:42:33,354
我还是想要所有的功能，

949
00:42:33,422 --> 00:42:36,724
只是当有人公开睁开眼睛时，

950
00:42:36,792 --> 00:42:40,060
我想动画，那里的变化，所以，

951
00:42:40,129 --> 00:42:41,060
我该怎么办？

952
00:42:41,129 --> 00:42:46,799
好的，当有人看到眼睛是否开放时，

953
00:42:46,868 --> 00:42:52,438
我要把私人的眼睛打开了吧。

954
00:42:52,507 --> 00:42:56,709
如果他们把这个眼睛打开的东西。

955
00:42:59,179 --> 00:43:02,581
他们会说，如果

956
00:43:02,650 --> 00:43:07,652
我会新的

957
00:43:07,721 --> 00:43:11,622
做这个UIView.transition与视图，好吗？

958
00:43:11,691 --> 00:43:13,424
不是这个。

959
00:43:13,493 --> 00:43:18,195
我想要视图的过渡动画，而不是从哪个

960
00:43:18,264 --> 00:43:20,296
记得从视图层次结构中删除东西。

961
00:43:20,365 --> 00:43:24,934
这一个正在过渡到视野内

962
00:43:25,003 --> 00:43:27,703
我会做自己的视图。

963
00:43:27,772 --> 00:43:29,304
这是EyeView。

964
00:43:29,373 --> 00:43:31,373
持续时间，我应该使它在这里不变，但是

965
00:43:31,442 --> 00:43:34,176
我会说点四点，使这个权宜之计。

966
00:43:34,245 --> 00:43:39,547
我想从上到下转换的选项

967
00:43:39,616 --> 00:43:43,317
因为眨眼眼睛来自顶部，所以

968
00:43:43,386 --> 00:43:44,451
我们会这样做和

969
00:43:44,520 --> 00:43:48,489
那么这里是我们要在这里做的动画。

970
00:43:48,557 --> 00:43:51,824
而且，我实际上并不需要这样的完成

971
00:43:51,893 --> 00:43:53,826
完成后不会做任何事情。

972
00:43:53,895 --> 00:43:56,329
请注意，这是一个可选的闭包。

973
00:43:56,398 --> 00:43:57,530
你看看它有没有问号

974
00:43:57,599 --> 00:43:58,530
结束了吗？

975
00:43:58,599 --> 00:44:01,166
所以，我只是不包括这一切。

976
00:44:02,436 --> 00:44:04,536
好的，那么我想在这里做什么？

977
00:44:04,604 --> 00:44:07,304
在这里，我想做出所有的改变

978
00:44:07,373 --> 00:44:08,705
我想要动画。

979
00:44:08,774 --> 00:44:10,173
那么这里超级简单。

980
00:44:10,242 --> 00:44:14,511
我只是把我的下巴设定为新的值。

981
00:44:14,580 --> 00:44:17,514
好的，我们在这里设置

982
00:44:17,582 --> 00:44:20,483
新值是任何一个眼睛等于的总和。

983
00:44:20,552 --> 00:44:21,917
所以在这里我要把它设置为新的值。

984
00:44:21,986 --> 00:44:26,922
这将改变我的视图，我的新眼睛开放状态。

985
00:44:26,991 --> 00:44:30,625
我要动画到那里，好吗？

986
00:44:30,693 --> 00:44:31,259
所以让我们来看看。

987
00:44:38,033 --> 00:44:39,333
这个家伙还是会眨眼。

988
00:44:39,401 --> 00:44:41,701
但是，你会看到吗？

989
00:44:41,770 --> 00:44:44,671
Cuz它是动画的眼睛关闭的实际动作。

990
00:44:47,041 --> 00:44:50,543
像这样，再一次工作。

991
00:44:53,915 --> 00:44:56,849
好的，现在下一件事我们要做

992
00:44:56,917 --> 00:44:59,418
有这个家伙摇头，所以

993
00:44:59,486 --> 00:45:01,952
我要旋转整个视图好吗？

994
00:45:02,021 --> 00:45:04,689
他左边小点头摇头。

995
00:45:04,757 --> 00:45:05,723
一路回到右边，

996
00:45:05,792 --> 00:45:07,257
然后回到中间。

997
00:45:07,326 --> 00:45:09,025
那会摇头，好吗？

998
00:45:09,094 --> 00:45:11,760
这是2D中最好的。

999
00:45:11,829 --> 00:45:12,862
那么，我们该怎么做呢？

1000
00:45:12,930 --> 00:45:15,197
我们会通过动画中的其中一个来做那个

1001
00:45:15,266 --> 00:45:18,700
在UI视图中，这是转换。

1002
00:45:18,769 --> 00:45:19,834
所以我们走吧

1003
00:45:19,903 --> 00:45:23,104
我们将在我们的FaceView控制器中执行此操作。

1004
00:45:23,173 --> 00:45:24,705
好的。所以，它会有一些事情

1005
00:45:24,773 --> 00:45:27,241
是各个阶段可以做的，所以我们把它放在那里。

1006
00:45:27,310 --> 00:45:30,243
让我们把它放在这里，我想这是一个很好的空间

1007
00:45:30,312 --> 00:45:32,345
它，一些房间，和

1008
00:45:32,414 --> 00:45:37,850
我有一些康斯坦茨，这是一个头痛的康斯坦茨。

1009
00:45:37,919 --> 00:45:41,086
所以，角度就是我要左转的角度

1010
00:45:41,155 --> 00:45:42,888
并回到右边和

1011
00:45:42,957 --> 00:45:44,890
记住我们在这里是弧度。

1012
00:45:44,958 --> 00:45:48,426
所以它是零两个pi一路围绕一圈

1013
00:45:48,495 --> 00:45:50,595
我要去六点以上，

1014
00:45:50,664 --> 00:45:52,262
这是围绕圈子的一点点。

1015
00:45:52,331 --> 00:45:56,066
然后段时间是我锣要花多长时间

1016
00:45:56,135 --> 00:45:59,236
每一回合，向左，向右，和

1017
00:45:59,305 --> 00:46:01,771
回到中间，好的，所以每个都要去

1018
00:46:01,840 --> 00:46:03,673
在这种情况下，采取半秒。

1019
00:46:04,909 --> 00:46:06,508
所以在我写动画代码之前，

1020
00:46:06,577 --> 00:46:08,977
我会在这里做一个很好的小私人功能

1021
00:46:09,046 --> 00:46:13,147
称为rotateFace（by :)。

1022
00:46:13,216 --> 00:46:15,749
它将要采取一个CGFloat是弧度，

1023
00:46:15,818 --> 00:46:18,185
旋转脸部的度数。

1024
00:46:18,254 --> 00:46:19,620
它会旋转它。

1025
00:46:19,689 --> 00:46:21,221
而我们这样做的方式是，

1026
00:46:21,290 --> 00:46:24,190
我们采取faceView.transform。

1027
00:46:24,259 --> 00:46:26,993
好的，记得我们在这里控制权

1028
00:46:27,061 --> 00:46:30,229
faceView一个vara vars，我们会让它等于

1029
00:46:30,298 --> 00:46:32,698
faceViews.transform.rotated by。

1030
00:46:35,636 --> 00:46:38,103
旋转这个数量。

1031
00:46:41,141 --> 00:46:45,609
好的，为了让这个更好一些，

1032
00:46:45,678 --> 00:46:49,313
我们会以角度来表示。

1033
00:46:49,382 --> 00:46:52,282
好的，这只是一个很好的小功能旋转

1034
00:46:52,351 --> 00:46:54,785
面对任何数量的度数，“我会用这个

1035
00:46:54,853 --> 00:46:58,287
里面我的动画代码来旋转脸。

1036
00:46:58,356 --> 00:47:00,522
任何人都会喜欢那段代码吗？

1037
00:47:00,591 --> 00:47:02,924
所以，在这里转变。

1038
00:47:02,993 --> 00:47:08,897
是高山变形

1039
00:47:08,966 --> 00:47:12,767
旋转，

1040
00:47:12,836 --> 00:47:18,038
只是一种方法

1041
00:47:18,107 --> 00:47:23,644
CGF转化。

1042
00:47:23,713 --> 00:47:27,514
ShakeHead cuz将来回摇晃头。

1043
00:47:27,583 --> 00:47:28,648
而且它会是动画，所以

1044
00:47:28,717 --> 00:47:32,752
我会直接对蝙蝠说，UIView.animate和

1045
00:47:32,821 --> 00:47:35,454
这个我想要的动画就是这个

1046
00:47:35,523 --> 00:47:37,856
这里因为我需要完成。

1047
00:47:37,925 --> 00:47:39,291
为什么我需要完成？

1048
00:47:39,360 --> 00:47:41,693
因为我会做这个轮换的方式是

1049
00:47:41,761 --> 00:47:44,496
我要旋转到左边，当它完成。

1050
00:47:44,564 --> 00:47:45,663
我向右旋转

1051
00:47:45,731 --> 00:47:48,933
当那个完成后，我回到中间。

1052
00:47:49,002 --> 00:47:51,601
那么，你明白为什么我需要知道每次旋转

1053
00:47:51,670 --> 00:47:52,602
完成了。

1054
00:47:52,671 --> 00:47:54,670
所以，这就是为什么我需要这个动画与持续时间

1055
00:47:54,739 --> 00:47:56,205
最后完成了。

1056
00:47:56,274 --> 00:47:59,074
现在，这个也有完成，但它有选项。

1057
00:47:59,143 --> 00:48:00,075
我们不需要任何选项。

1058
00:48:00,144 --> 00:48:03,044
我们只是使用标准的动画。

1059
00:48:03,113 --> 00:48:06,180
我们不会放松，放松或任何业务。

1060
00:48:06,249 --> 00:48:07,782
好的，所以这是我们想要的。

1061
00:48:07,851 --> 00:48:09,150
只是为了使这一点更可读，

1062
00:48:09,219 --> 00:48:11,886
我要做这个我经常做的这个小技巧。

1063
00:48:11,954 --> 00:48:14,721
这样你就可以一一看到每一个参数。

1064
00:48:14,790 --> 00:48:21,294
所以倾斜的持续时间是HeadShake.segmentDuration，

1065
00:48:21,363 --> 00:48:23,563
好的，那个常数我放在这里。

1066
00:48:23,632 --> 00:48:26,799
动画，好的，这是我们要做的

1067
00:48:26,867 --> 00:48:28,199
导致此动画发生。

1068
00:48:28,268 --> 00:48:30,401
嗯，我们要旋转脸。

1069
00:48:30,470 --> 00:48:34,672
现在这个ro，第一次旋转是向左旋转。

1070
00:48:34,741 --> 00:48:37,709
而在iOS中，与Mac OS不同。

1071
00:48:37,777 --> 00:48:43,814
在iOS中，角度的正值是逆时针。

1072
00:48:43,883 --> 00:48:45,282
所以我们想要一个积极的角度，

1073
00:48:45,350 --> 00:48:46,850
我们到这里左边。

1074
00:48:46,918 --> 00:48:49,952
所以我会让这成为我的HeadShake.angle。

1075
00:48:50,021 --> 00:48:52,955
好的，它会由HeadShake.angle旋转。

1076
00:48:53,024 --> 00:48:55,591
那将会在左边那边。

1077
00:48:55,659 --> 00:48:58,828
现在完成这个完成代码

1078
00:48:58,896 --> 00:49:02,031
已完成，无论是否完成，

1079
00:49:02,099 --> 00:49:04,132
我想等待它完成。

1080
00:49:05,768 --> 00:49:09,236
其实我要去，我想，是的，把它放在里面

1081
00:49:09,305 --> 00:49:12,373
这里只是为了让你更容易看到。

1082
00:49:12,441 --> 00:49:15,976
但这是完成，好的。

1083
00:49:16,045 --> 00:49:21,481
那家伙在那里，那个家伙在那里，好的。

1084
00:49:21,550 --> 00:49:24,317
所以这是完成后会发生的代码。

1085
00:49:24,386 --> 00:49:30,223
如果是的，抱歉， self.rotate.

1086
00:49:30,291 --> 00:49:34,826
顺便说一句，我们需要在这里记忆周期破裂等吗？

1087
00:49:34,895 --> 00:49:38,062
不，因为我们在动画的中间，好吗？

1088
00:49:38,131 --> 00:49:39,931
该视图控制器在屏幕上。

1089
00:49:40,000 --> 00:49:43,201
我们不用担心在这里创建内存循环。

1090
00:49:43,269 --> 00:49:44,969
因为我们知道这件事会在堆里。

1091
00:49:45,037 --> 00:49:45,869
因为它更好地在堆里，

1092
00:49:45,938 --> 00:49:47,871
我们现在正在动画！

1093
00:49:47,939 --> 00:49:49,472
所以这是我们真正需要的情况

1094
00:49:49,541 --> 00:49:50,907
做weak self和所有的东西。

1095
00:49:52,143 --> 00:49:54,042
好的，所以当它完成，

1096
00:49:54,111 --> 00:49:56,745
我们会说如果它完成了，它应该是什么。

1097
00:49:56,813 --> 00:49:59,781
因为我没有在这里发表任何其他的动画。

1098
00:49:59,850 --> 00:50:02,082
但有一天，也许我会添加一些新的动画。

1099
00:50:02,151 --> 00:50:04,152
在这种情况下，我可能会打断这个。

1100
00:50:04,220 --> 00:50:06,653
但是，检查完成总是很好，

1101
00:50:06,722 --> 00:50:09,355
即使你100％肯定这件事总是要完成。

1102
00:50:09,424 --> 00:50:12,292
在这种情况下，我们现在正在编写代码。

1103
00:50:12,360 --> 00:50:14,026
所以如果完成了，我现在要做的是

1104
00:50:14,095 --> 00:50:15,961
动画回到右边。

1105
00:50:16,030 --> 00:50:18,530
所以我只是要用UIView.animate withDuration

1106
00:50:18,599 --> 00:50:19,531
再次，好的

1107
00:50:19,600 --> 00:50:21,900
再次，我想在那里完成一个。

1108
00:50:26,072 --> 00:50:28,572
好的，这一次，我会做相同的时间

1109
00:50:28,641 --> 00:50:29,873
回到右边。

1110
00:50:29,942 --> 00:50:31,408
所以让我们的HeadShake。

1111
00:50:31,476 --> 00:50:33,610
你可以想象，也许这个持续时间是想要的

1112
00:50:33,678 --> 00:50:35,077
不同的，因为我走得更远。

1113
00:50:35,146 --> 00:50:37,613
但实际上，我觉得这可能是对的

1114
00:50:37,682 --> 00:50:39,281
这样，你会看到。

1115
00:50:39,350 --> 00:50:41,482
这些是你可以玩的一些概念，使你的

1116
00:50:41,551 --> 00:50:43,518
HeadShake看起来像你想要的方式。

1117
00:50:43,587 --> 00:50:44,686
而在动画中，

1118
00:50:44,754 --> 00:50:46,987
我会以另一种方式旋转我的脸。

1119
00:50:47,056 --> 00:50:49,222
所以它必须是一个负值。

1120
00:50:49,291 --> 00:50:51,090
我想要走两倍远，所以

1121
00:50:51,159 --> 00:50:53,460
我会做HeadShake.angl * 2。

1122
00:50:53,528 --> 00:50:55,728
好吧，我会一路走过，过去的中间，和

1123
00:50:55,797 --> 00:50:57,429
在右边。

1124
00:50:57,498 --> 00:51:02,434
然后在这里，为了完成这里，我要去

1125
00:51:02,503 --> 00:51:07,906
再次排队，所以你可以看到它更好一点，点击。

1126
00:51:07,975 --> 00:51:09,574
所以在这里完成，

1127
00:51:09,643 --> 00:51:12,009
我要旋转回到中间。

1128
00:51:12,078 --> 00:51:14,245
那么另一个呢，其实呢是看这个。

1129
00:51:14,314 --> 00:51:17,747
复制粘贴。

1130
00:51:17,816 --> 00:51:20,583
虽然这样，我不需要完成一个

1131
00:51:20,652 --> 00:51:22,619
因为我已经完成了。

1132
00:51:22,687 --> 00:51:24,586
显然，我不会倒退。

1133
00:51:24,655 --> 00:51:26,722
我要再次前进，

1134
00:51:26,791 --> 00:51:30,159
向前是逆时针方向。

1135
00:51:30,227 --> 00:51:33,962
好的，那就是那里的一切。

1136
00:51:34,031 --> 00:51:36,131
我们还有什么呢？

1137
00:51:36,200 --> 00:51:38,967
哎呀，忘了一个大括号在那里，逗号。

1138
00:51:41,837 --> 00:51:42,603
还有什么？

1139
00:51:42,671 --> 00:51:44,737
是的，我们错过了一些花括号或一些东西。

1140
00:51:44,806 --> 00:51:47,107
我们在这里有什么

1141
00:51:47,176 --> 00:51:52,311
这完成了，就这样。

1142
00:51:52,380 --> 00:51:55,147
不，等等，我们还有什么？

1143
00:51:55,216 --> 00:51:57,716
这不符合任何事情。

1144
00:51:57,785 --> 00:52:01,753
是的，它符合这一点。

1145
00:52:01,822 --> 00:52:02,721
好吧，坚持下去

1146
00:52:02,789 --> 00:52:08,660
任何人看到我错过动画的地方，

1147
00:52:08,729 --> 00:52:11,929
另一个大括号丢失在那里。

1148
00:52:11,998 --> 00:52:16,800
我确实认为我们将需要一个大括号。

1149
00:52:16,869 --> 00:52:18,601
好的，那里有很多大括号和括号。

1150
00:52:18,670 --> 00:52:19,736
我们在做，我们得到了。

1151
00:52:19,804 --> 00:52:21,637
好吧，大家明白这里发生了什么？

1152
00:52:21,706 --> 00:52:23,772
所以我们只是来回摇摆。

1153
00:52:23,841 --> 00:52:25,874
你知道，我知道这将要完成，因为我没有

1154
00:52:25,943 --> 00:52:28,042
任何其他动画可能会干扰它。

1155
00:52:28,111 --> 00:52:30,445
但是要正确，我应该总是这样说，

1156
00:52:30,514 --> 00:52:33,181
如果已经完成，那么如果这是我打算的话。

1157
00:52:33,249 --> 00:52:35,315
有时我会做一些事情，即使没有完成。

1158
00:52:35,384 --> 00:52:37,451
但在这种情况下，我确实想要。

1159
00:52:37,520 --> 00:52:38,752
好的，我们来看看这个。

1160
00:52:38,820 --> 00:52:41,354
这是一个非常有趣的动画组合

1161
00:52:41,422 --> 00:52:42,889
在这里，你会看到。

1162
00:52:44,024 --> 00:52:46,725
好吧，对不起。

1163
00:52:46,793 --> 00:52:49,694
让我们采取一些行动让它摇头。

1164
00:52:49,763 --> 00:52:50,996
好吧，让我们做点击。

1165
00:52:51,065 --> 00:52:53,398
现在，如果我们点击，它会眨眼睛。

1166
00:52:53,467 --> 00:52:55,365
但是现在我们已经眨眼了，所以

1167
00:52:55,434 --> 00:52:56,400
我们不再需要点了。

1168
00:52:56,469 --> 00:52:59,135
所以我要去这里点击这里，

1169
00:52:59,204 --> 00:53:00,203
这个tapRecognizer。

1170
00:53:00,272 --> 00:53:01,671
我会对此发表评论。

1171
00:53:01,739 --> 00:53:03,405
我会告诉你一种不同的做法

1172
00:53:03,474 --> 00:53:04,206
只是一个识别器。

1173
00:53:04,274 --> 00:53:04,840
我告诉你怎么了

1174
00:53:04,909 --> 00:53:08,009
直接在故事板中直接识别你的识别器？

1175
00:53:08,078 --> 00:53:09,043
我不认为我已经显示了，所以

1176
00:53:09,112 --> 00:53:10,444
让我告诉你如何做到这一点。

1177
00:53:10,513 --> 00:53:11,212
真的很容易，

1178
00:53:11,280 --> 00:53:13,147
我们将在这里去我们的故事板。

1179
00:53:14,349 --> 00:53:16,849
这实际上会显示另一件很酷的事情。

1180
00:53:16,918 --> 00:53:18,784
所以这里是我的MVC。

1181
00:53:18,853 --> 00:53:21,519
我将会提出我的助理编辑

1182
00:53:21,588 --> 00:53:23,688
我可以连接到它。

1183
00:53:23,757 --> 00:53:25,790
你会看到它带来了

1184
00:53:25,859 --> 00:53:27,858
BlinkingFaceViewController。

1185
00:53:27,927 --> 00:53:33,330
现在我想在这里连接一个手势识别器。

1186
00:53:33,399 --> 00:53:35,399
我不希望它在BlinkingFace控制器中，

1187
00:53:35,467 --> 00:53:37,768
我想要它在父类。

1188
00:53:37,836 --> 00:53:39,302
但它知道这一点

1189
00:53:39,370 --> 00:53:41,337
这里的MVC是一个BlinkingFacingViewController，

1190
00:53:41,406 --> 00:53:44,674
所以它试图自动显示给我。

1191
00:53:44,742 --> 00:53:47,709
那么我该如何在这里获得FaceViewController呢？

1192
00:53:47,778 --> 00:53:50,011
我允许挂上父类吗？

1193
00:53:50,080 --> 00:53:52,280
答案是，你被允许挂起来。

1194
00:53:52,349 --> 00:53:54,682
最简单的方法是按住Option，

1195
00:53:54,751 --> 00:53:57,651
选项键，然后点击它。

1196
00:53:57,720 --> 00:54:00,554
Cuz选项意味着在助理编辑器中打开它。

1197
00:54:00,623 --> 00:54:02,756
所以现在我在这里有FaceViewController。

1198
00:54:02,825 --> 00:54:07,160
所以现在我可以连线一个手势。

1199
00:54:07,229 --> 00:54:11,130
好的，那么如何从我的UI连线手势呢？

1200
00:54:11,199 --> 00:54:14,266
在这里输入所有这些东西的代码？

1201
00:54:14,335 --> 00:54:15,367
答案是，

1202
00:54:15,436 --> 00:54:19,704
我们进入实用程序窗口并搜索手势。

1203
00:54:19,773 --> 00:54:21,873
你会看到这里有很多手势，

1204
00:54:21,941 --> 00:54:24,141
你可以做点击手势，捏手势，旋转，

1205
00:54:24,210 --> 00:54:25,676
滑动手势等

1206
00:54:25,745 --> 00:54:28,778
而且你只是得到你想要的视图，

1207
00:54:28,847 --> 00:54:30,847
让我放大一下

1208
00:54:30,916 --> 00:54:33,116
所以你得到这个，这个FaceView就在这里。

1209
00:54:33,185 --> 00:54:35,552
而你只是拖动你想要的那种手势，

1210
00:54:35,620 --> 00:54:37,687
像一个水龙头手势，在它的顶部。

1211
00:54:37,755 --> 00:54:42,391
那就是让这个视图认识到一个轻拍手势。

1212
00:54:42,460 --> 00:54:43,492
现在哪里出现了？

1213
00:54:43,560 --> 00:54:45,427
它出现在这里顶部。

1214
00:54:45,495 --> 00:54:48,429
我可以点击它，并在这里检查。

1215
00:54:48,498 --> 00:54:50,764
我可以设置我们想要多少个水龙头，

1216
00:54:50,833 --> 00:54:52,365
我们想下去多少手指

1217
00:54:52,434 --> 00:54:54,701
所有我们在代码中做的东西，我们可以在这里做。

1218
00:54:54,769 --> 00:54:57,170
那么如何实现这个轻拍手势呢？

1219
00:54:57,239 --> 00:54:58,872
在我的代码中做某事

1220
00:54:58,940 --> 00:55:00,773
好吧，我只是Ctrl +拖动，当然。

1221
00:55:00,842 --> 00:55:02,408
我要按住Control和

1222
00:55:02,476 --> 00:55:04,609
从这个点击手势拖到这里。

1223
00:55:04,678 --> 00:55:06,344
我想要一个行动。

1224
00:55:06,412 --> 00:55:08,379
好的，这将是TapGesture的参数。

1225
00:55:08,448 --> 00:55:10,881
我也会调用shakeHead。

1226
00:55:10,950 --> 00:55:11,882
同名，但

1227
00:55:11,951 --> 00:55:15,619
这是一个tapGestureRecognizer的参数。

1228
00:55:15,688 --> 00:55:16,653
好的，大家看，

1229
00:55:16,722 --> 00:55:18,287
如何在故事板中勾起手势？

1230
00:55:18,356 --> 00:55:20,055
实际上很简单

1231
00:55:20,124 --> 00:55:23,092
我更喜欢在代码中做到这一点。

1232
00:55:23,161 --> 00:55:26,228
为什么我更喜欢做这些手势

1233
00:55:26,297 --> 00:55:28,162
在这样的代码？

1234
00:55:28,231 --> 00:55:29,964
我只是发现那些手势

1235
00:55:30,033 --> 00:55:31,966
在故事板上有一点隐藏。

1236
00:55:32,035 --> 00:55:33,700
他们在那里的小bar里

1237
00:55:33,769 --> 00:55:35,769
有时我并不会注意到它们。

1238
00:55:35,837 --> 00:55:37,270
所以，我喜欢这样做。

1239
00:55:37,339 --> 00:55:39,172
但真正的个人偏好。

1240
00:55:39,240 --> 00:55:40,906
在故事板中做任何事情都没有错。

1241
00:55:40,975 --> 00:55:42,307
有人会说更好

1242
00:55:42,376 --> 00:55:43,642
那么一切都在故事板上。

1243
00:55:43,711 --> 00:55:45,410
看到手势是很容易的。

1244
00:55:45,478 --> 00:55:46,911
呃，无论哪种方式。

1245
00:55:46,979 --> 00:55:48,913
好的，所以这里是我们的握手姿态。

1246
00:55:48,981 --> 00:55:49,613
我们要做什么？

1247
00:55:49,682 --> 00:55:52,282
嗯，我们要摇了，好吗？

1248
00:55:52,351 --> 00:55:54,785
我们在这里调用给这个动画。

1249
00:55:56,187 --> 00:55:58,020
每个人都得到了

1250
00:55:58,089 --> 00:56:01,323
我们在这里清理一下我们的空白。

1251
00:56:01,391 --> 00:56:02,857
好的，所以让我们一起运行吧。

1252
00:56:02,926 --> 00:56:06,894
现在我们可以点击我们的脸，它应该摇头

1253
00:56:06,963 --> 00:56:08,530
左，右，右，左。

1254
00:56:10,633 --> 00:56:13,534
对不起，然后，右后卫中间，好的。

1255
00:56:13,602 --> 00:56:15,369
所以，这里我们去，这家伙眨眼，好的，

1256
00:56:15,437 --> 00:56:17,837
它再次完成，无论什么样的人都是和

1257
00:56:17,906 --> 00:56:20,206
让我们点一下，他走了另一路。

1258
00:56:20,274 --> 00:56:21,173
所以我错了，

1259
00:56:21,242 --> 00:56:23,576
我在iOS中遇到这样的错误。

1260
00:56:23,644 --> 00:56:27,445
所以实际上，我猜肯定值是肯定的，

1261
00:56:27,514 --> 00:56:28,546
顺时针，我想。

1262
00:56:28,615 --> 00:56:30,581
我认为文件倒退了，

1263
00:56:30,650 --> 00:56:31,481
如果我记得正确，和

1264
00:56:31,550 --> 00:56:32,983
他们可能已经修复了，但无论如何。

1265
00:56:33,052 --> 00:56:34,918
所以我们前进后退。

1266
00:56:34,987 --> 00:56:37,554
现在，这里有一些有趣的事情要注意。

1267
00:56:37,623 --> 00:56:39,155
看看我们其他的动画。

1268
00:56:39,224 --> 00:56:41,056
它继续很开心

1269
00:56:41,125 --> 00:56:43,292
它不在乎我们旋转这个视图。

1270
00:56:43,361 --> 00:56:45,427
这完全是无关紧要的

1271
00:56:45,496 --> 00:56:46,894
这就是动画的工作方式。

1272
00:56:46,963 --> 00:56:49,430
只要他们没有触及相同的值，

1273
00:56:49,499 --> 00:56:51,265
他们可以完全独立工作。

1274
00:56:51,334 --> 00:56:55,068
这里另外要注意的是这是一个子视图

1275
00:56:55,137 --> 00:56:55,835
的视图。

1276
00:56:55,904 --> 00:56:58,572
当我改变它，它移动

1277
00:56:58,640 --> 00:57:01,675
所有的子视图与它，这是一个很酷，好的。

1278
00:57:01,743 --> 00:57:04,009
所以即使你从子视图中构建视图，

1279
00:57:04,078 --> 00:57:05,978
那么如果你动画，旋转它或

1280
00:57:06,046 --> 00:57:08,914
无论如何，子视图也将旋转。

1281
00:57:10,183 --> 00:57:11,449
好的，大家都得到了

1282
00:57:15,387 --> 00:57:16,453
好吧。

1283
00:57:16,522 --> 00:57:17,186
这就是我想给你看的。

1284
00:57:17,255 --> 00:57:20,123
那就是UIB动画的力量。

1285
00:57:20,192 --> 00:57:22,091
我甚至没有向你展示很多很酷的事情，你可以做

1286
00:57:22,160 --> 00:57:23,860
像移动视图。

1287
00:57:23,928 --> 00:57:25,827
好的，让屏幕上有视图。

1288
00:57:25,896 --> 00:57:27,996
我没有告诉你这个视图的动画原因

1289
00:57:28,065 --> 00:57:29,464
很明显你会怎么做，但是

1290
00:57:29,532 --> 00:57:32,233
也因为星期三，我会告诉你的

1291
00:57:32,302 --> 00:57:33,901
真正强大的方式让你跨越

1292
00:57:33,970 --> 00:57:35,769
这个物理阶段的屏幕是

1293
00:57:35,838 --> 00:57:37,504
接下来我们将要介绍幻灯片。

1294
00:57:39,274 --> 00:57:41,307
好吧，让我们回到幻灯片。

1295
00:57:45,279 --> 00:57:48,114
好的，所以动态动画。

1296
00:57:48,182 --> 00:57:51,483
现在，这是一个不同于基于UI的方法

1297
00:57:51,551 --> 00:57:53,585
刚刚说的动画

1298
00:57:53,653 --> 00:57:55,436
你所做的是设置所有这些物理学，如重力和

1299
00:57:55,437 --> 00:57:57,220
在这种情况下，

1300
00:57:57,289 --> 00:58:01,057
这样的东西，然后你只是把UIViews放在那里

1301
00:58:01,126 --> 00:58:05,896
他们受到这些物理学的影响，他们四处走动。

1302
00:58:05,964 --> 00:58:08,364
好的，这是现在做的最好的基础

1303
00:58:08,433 --> 00:58:09,232
你怎么做呢？

1304
00:58:09,300 --> 00:58:11,033
这样做的机制是什么？

1305
00:58:11,102 --> 00:58:12,968
首先，你会创造一个这样的例子

1306
00:58:13,037 --> 00:58:15,671
类叫UIDynamicAnimator，好吗？

1307
00:58:15,739 --> 00:58:18,372
一个UIDynamicAnimator是控制所有的东西

1308
00:58:18,441 --> 00:58:21,509
视图层次结构中基于物理的动画。

1309
00:58:21,578 --> 00:58:22,042
好的？我们会告诉你

1310
00:58:22,111 --> 00:58:23,277
如何在一秒钟内创建。

1311
00:58:23,346 --> 00:58:26,479
然后，你将添加所谓的UIDynamicBehaviors

1312
00:58:26,548 --> 00:58:27,847
那个动画师。

1313
00:58:27,916 --> 00:58:29,748
一旦你向动画师添加一个行为，

1314
00:58:29,817 --> 00:58:31,050
它将开始以这种方式行事。

1315
00:58:31,118 --> 00:58:35,187
然后最后你会添加UIDynamicItems，其中

1316
00:58:35,256 --> 00:58:39,457
通常UIViews，99％的时间，对这些行为。

1317
00:58:39,526 --> 00:58:41,659
然后，这些行为将开始对这些视图采取行动。

1318
00:58:41,728 --> 00:58:43,995
就这样，这是一个三级，三级的事情。

1319
00:58:44,064 --> 00:58:46,029
你有动画师，你添加行为，

1320
00:58:46,098 --> 00:58:47,464
那些行为开始发生。

1321
00:58:47,532 --> 00:58:49,900
你添加UIViews的行为，

1322
00:58:49,969 --> 00:58:51,935
现在他们开始受到行为的影响。

1323
00:58:52,004 --> 00:58:52,802
你可以按任何顺序进行。

1324
00:58:52,870 --> 00:58:54,736
您可以先将视图放在行为中

1325
00:58:54,805 --> 00:58:58,307
行为和动画师，无论你想做什么。

1326
00:58:58,376 --> 00:59:00,508
那么你如何创建一个UIDynamicAnimator？

1327
00:59:00,577 --> 00:59:04,446
所有它需要的是它将要工作的坐标系。

1328
00:59:04,515 --> 00:59:04,946
好的？

1329
00:59:05,014 --> 00:59:06,581
所以UIDynamicAnumator，

1330
00:59:06,649 --> 00:59:09,749
这里的构造函数将参考参考。

1331
00:59:09,818 --> 00:59:12,552
这只是其坐标系将要的UI视图

1332
00:59:12,621 --> 00:59:13,653
坐标系为

1333
00:59:13,722 --> 00:59:16,255
我们正在做的所有动画。

1334
00:59:16,324 --> 00:59:18,991
现在，意见没有，所有的绘图都没有

1335
00:59:19,060 --> 00:59:21,193
在一个视图中，它可以是一堆的意见，但是

1336
00:59:21,262 --> 00:59:23,361
它们必须处于相同的视图层次结构中

1337
00:59:23,430 --> 00:59:25,997
你会想要参考视图的顶部

1338
00:59:26,065 --> 00:59:26,765
查看层次结构，好吗？

1339
00:59:27,800 --> 00:59:29,766
那是唯一的限制。

1340
00:59:29,835 --> 00:59:32,036
所以现在，你开始添加行为。

1341
00:59:32,104 --> 00:59:34,905
所以你创建具体的实例

1342
00:59:34,973 --> 00:59:36,138
的UIDynamicBehavior，

1343
00:59:36,207 --> 00:59:38,507
换句话说，UIDynamicBehavior的子类，

1344
00:59:38,576 --> 00:59:39,241
做你想要的

1345
00:59:39,310 --> 00:59:40,642
所以，有一个重力行为，

1346
00:59:40,711 --> 00:59:44,279
这创造了似乎是重力，拉扯意见。

1347
00:59:45,815 --> 00:59:47,047
一个碰撞行为，其中的意见遇到类似的事情

1348
00:59:47,048 --> 00:59:48,280
或者

1349
00:59:48,350 --> 00:59:49,917
屏幕的边缘或另一个视图和

1350
00:59:49,985 --> 00:59:51,017
他们反弹。

1351
00:59:51,086 --> 00:59:52,451
好的？我们要谈谈

1352
00:59:52,520 --> 00:59:53,853
所有这些动态行为和

1353
00:59:53,921 --> 00:59:56,121
我们如何在一分钟内配置它们。

1354
00:59:56,190 --> 00:59:59,390
然后UIDynamicItems，有一件事要注意

1355
00:59:59,459 --> 01:00:03,294
UIDynamicItems是如果你添加，我们假设

1356
01:00:03,363 --> 01:00:05,830
你在这个例子中有item1和item2。

1357
01:00:05,899 --> 01:00:08,265
我已经添加了1和2的重力。

1358
01:00:08,334 --> 01:00:10,667
所以他们都受到重力行为的影响，但是

1359
01:00:10,736 --> 01:00:13,604
我只将项目1添加到对撞机。

1360
01:00:13,673 --> 01:00:15,205
我们来说，这是一个碰撞行为

1361
01:00:15,273 --> 01:00:17,407
让我们说底部有边界。

1362
01:00:17,475 --> 01:00:19,909
所以，我们来说，重力会下降，

1363
01:00:19,977 --> 01:00:22,211
碰撞机底部有一个边界。

1364
01:00:22,280 --> 01:00:24,846
项目1和2将加速下降

1365
01:00:24,915 --> 01:00:27,249
在重力拉扯的地方，但是

1366
01:00:27,317 --> 01:00:29,851
那么item2将继续下去。

1367
01:00:29,919 --> 01:00:33,420
而item1将从边界反弹，好的。

1368
01:00:33,489 --> 01:00:35,755
所以如果你不添加UIView到一定的行为，

1369
01:00:35,824 --> 01:00:37,291
它不会受到这种行为的影响。

1370
01:00:39,127 --> 01:00:41,828
现在，您添加到行为的这些项目

1371
01:00:41,897 --> 01:00:44,730
实现这个协议叫做UIDynamicItem，

1372
01:00:44,799 --> 01:00:47,465
UIView已经在实施。

1373
01:00:47,534 --> 01:00:48,934
好吧，在他们甚至发明这个之前，

1374
01:00:49,002 --> 01:00:51,803
因为UIDynamicItem协议中的所有这些都是

1375
01:00:51,872 --> 01:00:54,605
平衡，你刚刚得到，因为你的

1376
01:00:54,674 --> 01:00:58,242
平衡受到你的转变的影响

1377
01:00:58,311 --> 01:01:00,777
所以，你得到你的平衡，所以你知道在哪里画。

1378
01:01:00,846 --> 01:01:02,746
然后，安慰者，对不起，

1379
01:01:02,814 --> 01:01:05,748
中心和转换是可以设置的东西。

1380
01:01:05,817 --> 01:01:10,653
所以，动画师真的只能改变视图的位置

1381
01:01:10,722 --> 01:01:13,623
及其旋转和刻度。

1382
01:01:13,691 --> 01:01:15,824
好的，这就是动画师所做的一切，但是

1383
01:01:15,893 --> 01:01:16,692
非常多

1384
01:01:16,760 --> 01:01:20,896
好的，旋转刻度你可以看到，特别是中心在哪里

1385
01:01:20,964 --> 01:01:23,931
事情是，是很多动画师是什么，在做

1386
01:01:24,000 --> 01:01:27,201
现在，一个有趣的事情是一旦你添加一个动态项目

1387
01:01:27,270 --> 01:01:29,936
对于添加到动画师的行为，

1388
01:01:30,005 --> 01:01:33,773
那么动画师就控制着它的中心和转型。

1389
01:01:33,842 --> 01:01:35,375
如果你想改变中心，

1390
01:01:35,443 --> 01:01:38,611
转换而不从动态动画制作中删除它，

1391
01:01:38,680 --> 01:01:41,847
你必须告诉动态动画师，嘿，我改变这个。

1392
01:01:41,916 --> 01:01:43,515
否则，它会立即改变它

1393
01:01:43,584 --> 01:01:44,849
认为是。

1394
01:01:44,918 --> 01:01:45,951
对。所以不要打的

1395
01:01:46,019 --> 01:01:48,987
动态动画师，如果你想改变中心或

1396
01:01:49,055 --> 01:01:51,755
转换您已添加到动画制作器的视图。

1397
01:01:51,824 --> 01:01:53,957
你必须在这里告诉动画师使用这种方法。

1398
01:01:54,026 --> 01:01:55,759
使用当前状态更新项目。

1399
01:01:55,828 --> 01:01:59,228
你只是通过你改变中心的UIView

1400
01:01:59,297 --> 01:01:59,929
变换。

1401
01:01:59,998 --> 01:02:01,964
并且它会拾起你改变的东西，和

1402
01:02:02,033 --> 01:02:02,865
从那里继续

1403
01:02:05,335 --> 01:02:06,617
我们来谈一些具体的行为。

1404
01:02:06,618 --> 01:02:07,900
好吧？

1405
01:02:07,970 --> 01:02:09,437
有重力行为。

1406
01:02:09,506 --> 01:02:12,339
所以，重力行为，就像重力。

1407
01:02:12,407 --> 01:02:14,641
默认情况下，当您创建重力行为时，

1408
01:02:14,709 --> 01:02:18,945
重力下降，这意味着下降

1409
01:02:19,014 --> 01:02:24,383
朝向主页按钮，基本上是纵向模式。

1410
01:02:24,452 --> 01:02:27,386
而且，它的数量是1g。

1411
01:02:27,455 --> 01:02:29,921
[LAUGH]好吧，1.0。

1412
01:02:29,990 --> 01:02:34,659
而1.0则表示每秒钟每秒1000点。

1413
01:02:34,728 --> 01:02:38,063
记住重力是一种加速度。

1414
01:02:38,131 --> 01:02:40,631
好的，希望你们都有足够的物理学知道

1415
01:02:40,700 --> 01:02:41,799
重力是一种加速度。

1416
01:02:41,868 --> 01:02:44,535
任何人知道地球上的重力是什么？

1417
01:02:46,672 --> 01:02:48,671
每平方米9.8米，对吧？

1418
01:02:48,740 --> 01:02:52,508
所以在屏幕上是每秒千点

1419
01:02:52,577 --> 01:02:55,043
平方，真正有趣的一千个

1420
01:02:55,112 --> 01:02:57,413
每秒点数平方是一个非常圆的数字，但是

1421
01:02:57,481 --> 01:03:00,516
感觉很像9.8米/秒的平方。

1422
01:03:00,584 --> 01:03:02,751
现在，如果你有你的手机你把UI，

1423
01:03:02,819 --> 01:03:03,985
在顶部和

1424
01:03:04,054 --> 01:03:06,820
你应用这种重力行为，它会下降

1425
01:03:06,889 --> 01:03:09,389
几乎完全一样的现实生活中的物体会下降。

1426
01:03:09,458 --> 01:03:11,859
实际上真的很棒。

1427
01:03:11,927 --> 01:03:13,460
然而，像这样一个圆的数字。

1428
01:03:14,896 --> 01:03:16,195
所以你可以推送这些数字，

1429
01:03:16,264 --> 01:03:17,930
你可以重力起来。

1430
01:03:17,999 --> 01:03:20,365
例如，当我拉出我的手机和

1431
01:03:20,433 --> 01:03:23,001
我从底部向上滑动，好的。

1432
01:03:23,070 --> 01:03:24,235
如果你想要的话，随意做。

1433
01:03:24,303 --> 01:03:25,536
当你从底部向上滑动时，

1434
01:03:25,604 --> 01:03:27,804
小控制面板出现。

1435
01:03:27,873 --> 01:03:29,373
如果有种苍蝇，

1436
01:03:29,441 --> 01:03:32,942
这实际上是使用这种机制和它的重力。

1437
01:03:33,011 --> 01:03:35,345
所以，重力实际上是拉这个东西

1438
01:03:35,413 --> 01:03:36,412
当你滑动

1439
01:03:36,481 --> 01:03:38,313
而且，当它击中时，

1440
01:03:38,382 --> 01:03:39,447
你注意到它不只是出来

1441
01:03:39,516 --> 01:03:43,084
停止，有点反弹一点，结束了，好吗？

1442
01:03:43,153 --> 01:03:44,752
这是碰撞行为。

1443
01:03:44,821 --> 01:03:47,454
所以这个事情是一个重力的组合

1444
01:03:47,523 --> 01:03:50,023
行为和碰撞行为或可能正在使用

1445
01:03:50,092 --> 01:03:52,392
一个快速的行为，我们将在一秒钟内看到。

1446
01:03:52,461 --> 01:03:53,293
无论如何，这是重力，

1447
01:03:53,362 --> 01:03:54,994
你可以看到任何方向的重力，和

1448
01:03:55,063 --> 01:03:59,364
我们将在周三的演示中做到这一点。

1449
01:03:59,433 --> 01:04:01,100
另一个是附件行为。

1450
01:04:01,169 --> 01:04:03,935
这允许您采取两个动态项目，或

1451
01:04:04,004 --> 01:04:06,838
一个动态的动态项目和一个固定点

1452
01:04:06,907 --> 01:04:09,841
将它们隔开一段距离。

1453
01:04:09,910 --> 01:04:11,809
这怎么会发挥出来？

1454
01:04:11,877 --> 01:04:13,410
嗯，让我们说我有一个UIView和

1455
01:04:13,479 --> 01:04:16,547
我把它附在这个中心点上

1456
01:04:16,615 --> 01:04:20,049
让我们说UIView，除了受到影响

1457
01:04:20,118 --> 01:04:23,486
这种附着行为也受到重力的影响。

1458
01:04:23,554 --> 01:04:26,755
然后就会像摆钟一样摆动。

1459
01:04:26,824 --> 01:04:28,557
好的，因为附件行为会

1460
01:04:28,626 --> 01:04:30,659
不断附加到这一点上。

1461
01:04:30,728 --> 01:04:32,894
但重力将不断地试图拉动

1462
01:04:32,963 --> 01:04:34,629
下来，它会摆动。

1463
01:04:34,698 --> 01:04:36,264
你看到了吗?

1464
01:04:36,332 --> 01:04:37,631
这是一个附件行为。

1465
01:04:37,700 --> 01:04:38,998
附件行为，

1466
01:04:39,067 --> 01:04:41,034
有一件事非常酷，

1467
01:04:41,102 --> 01:04:44,103
您可以实时更改附件的长度。

1468
01:04:44,172 --> 01:04:45,437
所以事情是动画和

1469
01:04:45,506 --> 01:04:49,274
你可以改变所附的距离

1470
01:04:49,343 --> 01:04:52,578
你可以用这种方式创造各种疯狂的动作。

1471
01:04:53,980 --> 01:04:56,614
好吧，碰撞行动。

1472
01:04:56,682 --> 01:04:58,615
碰撞行为正是你的想法。

1473
01:04:58,684 --> 01:05:00,251
您可以设置

1474
01:05:00,319 --> 01:05:03,586
碰撞可以在所有项目之间

1475
01:05:03,655 --> 01:05:05,154
这是行为。

1476
01:05:05,223 --> 01:05:07,090
他们受到行为的影响。

1477
01:05:07,158 --> 01:05:08,991
和或任何数量的边界和

1478
01:05:09,059 --> 01:05:11,827
这些边界只是UIBezierPaths，所以你可以

1479
01:05:11,896 --> 01:05:15,296
将这些UIBezierPath与CollisionBehavior进行注册

1480
01:05:15,365 --> 01:05:17,932
所有受行为影响的物品都会

1481
01:05:18,001 --> 01:05:20,201
从那些边界反弹，好吗？

1482
01:05:20,270 --> 01:05:22,202
他们可以是圆的，他们可以弯曲，

1483
01:05:22,271 --> 01:05:24,871
他们可以是你想要的任何路径。

1484
01:05:24,940 --> 01:05:27,840
你想要放置的一个共同边界是一个边界

1485
01:05:27,909 --> 01:05:30,176
一路围绕参考区。

1486
01:05:30,245 --> 01:05:32,678
只是为了包含所有内容。

1487
01:05:32,747 --> 01:05:36,182
你可以用这个var translate参考范围来做到这一点

1488
01:05:36,251 --> 01:05:37,216
如果你设置碰撞行为，那么它会

1489
01:05:37,217 --> 01:05:38,182
进入边界。

1490
01:05:38,251 --> 01:05:40,919
一种自动地在边缘周围设置边界

1491
01:05:40,987 --> 01:05:43,954
保持一切内部的参考范围。

1492
01:05:44,023 --> 01:05:46,523
现在你注意到这些边界的参数

1493
01:05:46,592 --> 01:05:49,459
标识符，以便您可以判断哪些标识符

1494
01:05:49,528 --> 01:05:52,095
你打的时候打，我会告诉你你是怎么找到的

1495
01:05:52,164 --> 01:05:54,664
在一秒钟内出现，但您注意到标识符是

1496
01:05:54,733 --> 01:05:59,168
NSCopying你以前从未见过NSCopying，

1497
01:05:59,237 --> 01:06:02,838
NSCopying的目的基本上意味着NSString

1498
01:06:02,907 --> 01:06:05,808
或NSNumber好的，所以标识符可以是一个数字

1499
01:06:05,877 --> 01:06:08,043
或一个字符串，但有NS。

1500
01:06:08,112 --> 01:06:11,046
现在，这没有问题，因为你可以

1501
01:06:11,115 --> 01:06:15,516
作为一个字符串或一个Int，如果你想，

1502
01:06:15,585 --> 01:06:18,886
使用Int作为您的标识符，但您必须这样做。

1503
01:06:18,955 --> 01:06:23,323
所以，NSCopying基本上是NSString或NSNumber Number，

1504
01:06:23,392 --> 01:06:25,291
现在，为什么我们需要这个标识符？

1505
01:06:25,360 --> 01:06:28,094
因为当边界发生碰撞时，

1506
01:06:28,163 --> 01:06:32,131
碰撞，行为有一个代表，它会告诉你的。

1507
01:06:32,200 --> 01:06:34,767
所以，如果你把自己设为碰撞行为的代表，

1508
01:06:34,835 --> 01:06:38,070
那么，如果你在那里设置了任何边界，或者

1509
01:06:38,138 --> 01:06:40,672
如果两件物品相互碰撞，你会发生的

1510
01:06:40,740 --> 01:06:44,009
得到这个发送给你，这是一个collisionDelegate方法

1511
01:06:44,077 --> 01:06:47,378
碰撞行为开始或结束联系

1512
01:06:47,447 --> 01:06:51,548
一些UIDynamicItem，UI View，如果这个弹跳

1513
01:06:51,617 --> 01:06:54,551
在那里有边界标识符NSCopying。

1514
01:06:54,620 --> 01:06:57,287
所以，这个标识符告诉你这个边界

1515
01:06:57,356 --> 01:06:59,622
你发送的是这样做，离开

1516
01:06:59,691 --> 01:07:03,326
告诉你这两件事情相撞的一点

1517
01:07:03,394 --> 01:07:06,061
如果你是在两个UI中谈论碰撞

1518
01:07:06,130 --> 01:07:09,298
动态项目，然后它将与UIDynamicItem而不是

1519
01:07:09,367 --> 01:07:10,265
withBoundaryIdentifier。

1520
01:07:11,568 --> 01:07:12,566
好的？所以这真的很酷

1521
01:07:12,635 --> 01:07:13,667
碰撞发生时

1522
01:07:13,736 --> 01:07:15,035
你会发现他们发生了。

1523
01:07:15,104 --> 01:07:17,571
再次，我们将在演示中使用它。

1524
01:07:19,140 --> 01:07:19,638
好吧。

1525
01:07:19,707 --> 01:07:21,073
SnapBehavior。

1526
01:07:21,142 --> 01:07:23,709
所以一个SnapBehavior是基本上

1527
01:07:23,778 --> 01:07:27,012
将这个观点从这里转移到这里的行为。

1528
01:07:27,081 --> 01:07:28,913
为什么它被称为快照行为是，

1529
01:07:28,982 --> 01:07:31,882
它不会移动到那里真的很干燥

1530
01:07:31,951 --> 01:07:34,952
有点僵硬，它移动它，当它到达那里，

1531
01:07:35,021 --> 01:07:38,322
几乎就像四个弹簧都贴在角落上

1532
01:07:38,391 --> 01:07:41,190
它有点震动了。

1533
01:07:41,259 --> 01:07:44,527
它飞过那里，可能会缓解，然后缓解，和

1534
01:07:44,595 --> 01:07:47,330
那么当它到达那里时，它会有一点震动。

1535
01:07:47,399 --> 01:07:48,697
好的，就像角落里有弹簧。

1536
01:07:48,766 --> 01:07:51,667
并且您可以设置这些弹簧的刚度与阻尼。

1537
01:07:51,735 --> 01:07:54,402
所以，高度阻尼，他们会进来，只是[SOUND]停止。

1538
01:07:54,471 --> 01:07:57,472
真的是春天的春天，他们会进来

1539
01:07:57,541 --> 01:07:58,890
当它到达那里时，真的会弹起来。

1540
01:07:58,891 --> 01:08:00,240
去[SOUND]，

1541
01:08:00,309 --> 01:08:01,909
那么为什么我们这样做呢？

1542
01:08:01,977 --> 01:08:05,178
因为当我们将屏幕上的东西移动到一个新的地方

1543
01:08:05,247 --> 01:08:09,015
在现实生活中，我们不希望它感到如此突然。

1544
01:08:09,084 --> 01:08:09,916
对。当我们搬家的时候，

1545
01:08:09,985 --> 01:08:11,884
再次，我们希望事情顺利，和

1546
01:08:11,953 --> 01:08:14,519
这么快就到了绝对的方式

1547
01:08:14,588 --> 01:08:19,357
使用系统将某物移动到已知位置。

1548
01:08:19,426 --> 01:08:22,527
类似地，有一些叫做pushBehavior的东西，

1549
01:08:22,596 --> 01:08:25,196
一个pushBehavior为UIview提供了一个推动。

1550
01:08:25,265 --> 01:08:28,031
好的，所以我们已经知道如何加快UIview

1551
01:08:28,100 --> 01:08:30,667
朝向有重力的地方。

1552
01:08:30,736 --> 01:08:34,337
推动几乎就像给它一个速度。

1553
01:08:34,406 --> 01:08:35,605
现在有两种推。

1554
01:08:35,673 --> 01:08:39,275
有瞬间推动只是一次推，

1555
01:08:39,344 --> 01:08:44,580
好的部分有一定的能量。

1556
01:08:44,649 --> 01:08:47,649
在那里你可以看到大小1.0是一个100 x100视图，

1557
01:08:47,718 --> 01:08:50,518
将获得100点/秒/秒。

1558
01:08:50,587 --> 01:08:52,454
有点推吗？

1559
01:08:53,890 --> 01:08:56,190
但那时也是持续的推动

1560
01:08:56,259 --> 01:08:57,390
你只是推后面。

1561
01:08:57,459 --> 01:08:59,026
那就是速度。

1562
01:08:59,095 --> 01:09:00,961
好的，你给的东西的速度。

1563
01:09:01,029 --> 01:09:03,163
你只是不断地推动它。

1564
01:09:04,165 --> 01:09:06,798
所以你可以做这两件事。

1565
01:09:06,867 --> 01:09:09,233
有一件事对于推动行为真的很讨厌

1566
01:09:09,302 --> 01:09:11,035
是瞬间的。

1567
01:09:11,104 --> 01:09:14,539
您将行为添加到动画师。

1568
01:09:14,608 --> 01:09:15,205
对？

1569
01:09:15,274 --> 01:09:16,574
然后，它推动它和

1570
01:09:16,642 --> 01:09:18,541
那么只是坐在那里什么都不做，

1571
01:09:18,610 --> 01:09:21,778
好吧，它不喜欢消失后你自发推，

1572
01:09:21,847 --> 01:09:24,280
即使我的意思是我不会再推一次。

1573
01:09:24,349 --> 01:09:27,750
所以我们想清理干净，我会向你展示

1574
01:09:27,818 --> 01:09:31,386
这个谈话的结尾如何瞬间推动，但是

1575
01:09:31,455 --> 01:09:33,689
这是有点烦人的。

1576
01:09:33,757 --> 01:09:35,657
现在连续推动是不同的，因为它是

1577
01:09:35,725 --> 01:09:37,992
不断推动，所以你不希望它被清理

1578
01:09:38,061 --> 01:09:39,827
如果你想坐在那里推。

1579
01:09:42,397 --> 01:09:44,097
还有另一种行为就是这样

1580
01:09:44,165 --> 01:09:47,467
一个元行为，称为动态项目行为。

1581
01:09:47,535 --> 01:09:49,169
好的？动态项目行为，

1582
01:09:49,237 --> 01:09:51,570
不是动态行为，动态项目行为。

1583
01:09:51,639 --> 01:09:55,507
而且，我喜欢把它当作物理行为。

1584
01:09:55,576 --> 01:09:58,443
这本质上是描述物理学

1585
01:09:58,511 --> 01:10:02,580
当所有其他行为做事情时适用，好吗？

1586
01:10:02,649 --> 01:10:05,583
所以这就是事情，允许旋转。

1587
01:10:05,652 --> 01:10:06,483
这就是说，

1588
01:10:06,552 --> 01:10:10,554
如果两件事情发生冲突，是否应该被剥夺？

1589
01:10:10,623 --> 01:10:13,123
或者他们必须保持，你知道，不旋转，

1590
01:10:13,192 --> 01:10:15,291
弹跳非旋转。

1591
01:10:15,360 --> 01:10:18,061
事情反弹之后，或者如果是的话

1592
01:10:18,129 --> 01:10:21,831
只是移动，他们会因摩擦而减缓吗？

1593
01:10:21,899 --> 01:10:23,733
好的，所以如果你有重力和摩擦。

1594
01:10:23,801 --> 01:10:25,367
他们不会加快速度，因为

1595
01:10:25,436 --> 01:10:26,601
他们正在放缓。

1596
01:10:26,670 --> 01:10:30,105
当事情相互碰撞时，弹性就可以了

1597
01:10:30,173 --> 01:10:32,674
反弹与他们进来的能量相同？

1598
01:10:32,742 --> 01:10:35,075
这将是弹性1.0或它们获得

1599
01:10:35,144 --> 01:10:39,379
碰撞能量将超过1.0的弹性。

1600
01:10:39,448 --> 01:10:42,048
或者他们因为彼此碰撞而失去能量

1601
01:10:42,116 --> 01:10:43,850
将弹性小于1.0。

1602
01:10:44,852 --> 01:10:46,418
好的，所以你看这个怎么样，

1603
01:10:46,486 --> 01:10:48,286
是行为就像碰撞行为一样

1604
01:10:48,355 --> 01:10:50,054
可怕的行为或推动行为。

1605
01:10:50,123 --> 01:10:51,655
但这是一种行为，就像元，

1606
01:10:51,724 --> 01:10:53,757
这就像描述这些事情应该如何行事

1607
01:10:53,826 --> 01:10:55,959
所有其他行为。

1608
01:10:56,028 --> 01:10:59,329
这些行为也可以告诉你线速度

1609
01:10:59,398 --> 01:11:02,332
一个实际上很有趣的项目。

1610
01:11:02,400 --> 01:11:05,902
为什么我想知道一个物品的线速度？

1611
01:11:05,970 --> 01:11:09,539
很多次，如果我有一个看法，一个MBC和

1612
01:11:09,607 --> 01:11:10,506
这是动画。

1613
01:11:10,575 --> 01:11:13,542
然后，我点击它像一个Tabbar或我，

1614
01:11:13,610 --> 01:11:17,145
在导航控制器中，我推动别的东西。

1615
01:11:17,214 --> 01:11:19,948
我想暂停那个动画。

1616
01:11:20,016 --> 01:11:21,849
嗯，没有什么真正的方法来暂停。

1617
01:11:21,918 --> 01:11:24,318
好的，当你的看法离开屏幕时，你的看法

1618
01:11:24,387 --> 01:11:27,020
控制器消失，您将要删除

1619
01:11:27,088 --> 01:11:29,055
动画师的行为和停止动画。

1620
01:11:29,124 --> 01:11:32,124
你不想在屏幕上不要动画。

1621
01:11:32,193 --> 01:11:33,926
好的，这是浪费精力。

1622
01:11:33,994 --> 01:11:38,330
但是当你去看这个视图时，你想要所有的动画

1623
01:11:38,399 --> 01:11:40,498
事情要继续下去。

1624
01:11:40,567 --> 01:11:41,399
他们会除外

1625
01:11:41,468 --> 01:11:43,434
他们将失去所有的速度。

1626
01:11:43,503 --> 01:11:45,403
所以你必须把速度放回去。

1627
01:11:45,472 --> 01:11:47,504
所以你抓住所有的线性速度，

1628
01:11:47,573 --> 01:11:48,806
将他们存放在某个地方

1629
01:11:48,874 --> 01:11:51,374
当你回来时，再加回线速度。

1630
01:11:51,443 --> 01:11:54,343
您也可以使用这里的线速度来实现速度

1631
01:11:54,412 --> 01:11:55,978
限制对象

1632
01:11:56,047 --> 01:11:57,012
如果周三有时间，

1633
01:11:57,080 --> 01:11:58,680
我怀疑我们会有时间，但是。

1634
01:11:58,749 --> 01:12:00,815
如果我们可以达到限速功能。

1635
01:12:00,884 --> 01:12:02,883
顺便说一下，我们正在建造像太空游戏那样的地方

1636
01:12:02,952 --> 01:12:04,285
飞过小行星。

1637
01:12:04,353 --> 01:12:06,319
这就是我们要用这个东西来构建的。

1638
01:12:06,388 --> 01:12:08,522
也许我们希望小行星有一个速度限制在哪里

1639
01:12:08,591 --> 01:12:09,956
没有这么快，没有办法

1640
01:12:10,025 --> 01:12:12,058
我们的船可能会闪避他们或任何东西。

1641
01:12:13,461 --> 01:12:16,628
所以我们使用线速度。

1642
01:12:16,697 --> 01:12:20,632
所以您可以询问动态行为行为的任何项目

1643
01:12:20,701 --> 01:12:22,534
你可以要求它的线速度。

1644
01:12:24,203 --> 01:12:28,005
好的，现在这里是所有这些行为，重力行为，

1645
01:12:28,074 --> 01:12:29,039
推动行为，所有这些。

1646
01:12:29,108 --> 01:12:30,840
这些都是一个类的子类

1647
01:12:30,909 --> 01:12:32,642
UI动态行为。

1648
01:12:32,711 --> 01:12:33,709
不是动态项目行为。

1649
01:12:33,778 --> 01:12:34,710
那是上一张幻灯片。

1650
01:12:34,779 --> 01:12:36,779
这是UIDynamicBehavior。

1651
01:12:36,848 --> 01:12:39,748
现在，UIDynamicBehavior是你经常的东西

1652
01:12:39,817 --> 01:12:42,017
创建自己的子类。

1653
01:12:42,085 --> 01:12:44,419
现在怎么样，你可能是什么样的？

1654
01:12:44,488 --> 01:12:46,387
我会写我自己的重力的东西，或者

1655
01:12:46,456 --> 01:12:47,488
我自己碰撞的事情？

1656
01:12:47,556 --> 01:12:49,789
他们太复杂了，答案是你是对的，

1657
01:12:49,858 --> 01:12:51,190
这太复杂了。

1658
01:12:51,259 --> 01:12:53,859
所以你的子类UI动态行为，什么

1659
01:12:53,928 --> 01:12:57,830
他们将是其他动态行为的复合。

1660
01:12:57,898 --> 01:13:02,234
所以如果你有一些空间l，那里有边界和

1661
01:13:02,302 --> 01:13:04,003
重力正在应用于事物

1662
01:13:04,071 --> 01:13:06,137
他们有一定的摩擦和弹性。

1663
01:13:06,206 --> 01:13:07,806
你会结合我们的重力行为，

1664
01:13:07,874 --> 01:13:10,608
碰撞行为和UI动态项目行为。

1665
01:13:10,677 --> 01:13:13,777
进入UIDynamicBehavior的子类。

1666
01:13:13,845 --> 01:13:16,213
而且结合它们的方式是非常重要的

1667
01:13:16,282 --> 01:13:19,549
方法在UIDynamicBehavior中调用addChildBehavior。

1668
01:13:19,618 --> 01:13:23,686
这意味着将这种行为复合到我的行为中。

1669
01:13:23,755 --> 01:13:26,656
而且，我们几乎总是这样做，好吗？

1670
01:13:26,724 --> 01:13:29,324
创建我们自己的UIDynamicBehavior的子类，和

1671
01:13:29,393 --> 01:13:32,327
把我们所有其他与之相关的行为，

1672
01:13:32,396 --> 01:13:33,295
作为孩子的行为。

1673
01:13:33,363 --> 01:13:37,599
这只是收集ff总计的好方法

1674
01:13:37,667 --> 01:13:40,401
正在将事物传递到一个地方的行为。

1675
01:13:40,470 --> 01:13:42,803
我们也将在演示中做到这一点。

1676
01:13:42,872 --> 01:13:47,941
我们星期三将要写的大部分代码

1677
01:13:48,010 --> 01:13:53,079
将在一个大的UIDynamicBehavior子类中

1678
01:13:53,148 --> 01:13:59,151
“我们会对我们的小行星施加很多的行为

1679
01:13:59,220 --> 01:14:05,190
正在移动，他们必须从船上反弹

1680
01:14:05,259 --> 01:14:11,097
他们必须受到船舶加速度的影响

1681
01:14:11,165 --> 01:14:15,867
我们必须把所有的东西都放在一边

1682
01:14:15,936 --> 01:14:20,772
我们自己的子类UIDynamicBehaviour好吗？

1683
01:14:20,841 --> 01:14:23,274
记住我说这个UID动态动画师在顶部，

1684
01:14:23,343 --> 01:14:24,942
你添加所有的行为。

1685
01:14:25,011 --> 01:14:27,044
那个事情，所有的行为？

1686
01:14:27,113 --> 01:14:28,278
不，他们在。

1687
01:14:28,346 --> 01:14:31,014
他们有一个var称为dynamicAnimator，可以

1688
01:14:31,083 --> 01:14:33,783
为零，因为它们可能不会被动画化，

1689
01:14:34,818 --> 01:14:36,619
告诉他们。

1690
01:14:36,687 --> 01:14:40,188
他们还发现用这种方法会动到动态

1691
01:14:40,257 --> 01:14:43,891
动画师每当他们从动态中移除时

1692
01:14:43,960 --> 01:14:45,826
动画师或添加到不同的。

1693
01:14:45,895 --> 01:14:47,828
他们只能被一个动画。

1694
01:14:47,896 --> 01:14:49,764
所以我认为它永远不会被多重动态重现

1695
01:14:49,832 --> 01:14:51,197
动画师，根本就没有任何意义。

1696
01:14:51,266 --> 01:14:52,865
会相互战斗

1697
01:14:52,934 --> 01:14:55,468
所以这只是他们搬到的时候了。

1698
01:14:55,537 --> 01:14:57,069
所以你可以知道他们什么时候移动。

1699
01:14:57,138 --> 01:14:58,237
为什么你想知道这个，顺便问一下？

1700
01:14:58,305 --> 01:15:00,806
有时候很有趣的是知道什么时候

1701
01:15:00,874 --> 01:15:03,842
你留下一个DynamicAnimator，好的，

1702
01:15:03,911 --> 01:15:06,277
因为也许你有其他的事情，

1703
01:15:06,346 --> 01:15:08,546
像我们的演示一样，如果我们在星期三得到它，

1704
01:15:08,614 --> 01:15:11,715
我们会有一个定时器，一直在进行中。

1705
01:15:11,784 --> 01:15:13,449
但如果我们不动画，

1706
01:15:13,518 --> 01:15:14,517
我们不想让那个计时器去。

1707
01:15:14,586 --> 01:15:15,251
所以我们开始吧

1708
01:15:15,319 --> 01:15:17,253
停止该计时器，我们将转到Animator。

1709
01:15:19,824 --> 01:15:21,589
好的？

1710
01:15:21,658 --> 01:15:24,025
UI动态行为也有一个非常酷的吧，叫做action。

1711
01:15:24,026 --> 01:15:26,393
好的。

1712
01:15:26,463 --> 01:15:29,163
action只是一个闭包，没有任何参数，

1713
01:15:29,231 --> 01:15:30,497
不返回参数。

1714
01:15:30,566 --> 01:15:34,835
这种action闭包，每次这种行为都被称作。

1715
01:15:36,472 --> 01:15:38,304
好的，所以碰撞行为，

1716
01:15:38,373 --> 01:15:40,606
当它碰撞时，它会被称为这个动作的东西。

1717
01:15:40,674 --> 01:15:42,407
重力一直在调用这个东西。

1718
01:15:42,476 --> 01:15:43,175
因为重力是

1719
01:15:43,243 --> 01:15:45,243
总是加速物品越来越多。

1720
01:15:45,312 --> 01:15:48,145
推动行为，它被称为，如果它是即时的，

1721
01:15:48,214 --> 01:15:49,847
它是一个推动它。

1722
01:15:49,916 --> 01:15:52,148
如果它是连续的，它将一直被称为

1723
01:15:52,217 --> 01:15:54,184
因为它推动了事情。

1724
01:15:54,253 --> 01:15:57,420
所以这个，这些小闭包被称为很多。

1725
01:15:57,489 --> 01:16:00,823
所以不要做任何昂贵的行动更接近。

1726
01:16:00,891 --> 01:16:01,690
好的？你想要

1727
01:16:01,759 --> 01:16:04,693
真的做这个代码，如果你进入仪器和

1728
01:16:04,762 --> 01:16:06,895
你看看你的代码，如果你在这里做一些昂贵的东西

1729
01:16:06,963 --> 01:16:09,798
将会很快地来到顶端，因为它被调用

1730
01:16:09,867 --> 01:16:12,366
很多，你可能会想像。

1731
01:16:12,435 --> 01:16:16,203
而且你可以在这里做很多很酷的事情。

1732
01:16:16,272 --> 01:16:17,338
这是您实现速度限制的地方，

1733
01:16:17,339 --> 01:16:18,405
例如，

1734
01:16:18,474 --> 01:16:21,307
好的检查线速度，如果它太快了

1735
01:16:21,376 --> 01:16:25,311
会增加一些负线性速度来减缓它。

1736
01:16:25,380 --> 01:16:26,945
好的？

1737
01:16:27,014 --> 01:16:29,181
这个东西很容易得到内存周期，

1738
01:16:29,250 --> 01:16:32,250
因为当然这个动作var是一个var的行为

1739
01:16:32,319 --> 01:16:34,419
和很多次内闭包，

1740
01:16:34,487 --> 01:16:36,620
你将会引用这个行为。

1741
01:16:36,689 --> 01:16:38,722
做一些行为，对吧？

1742
01:16:38,791 --> 01:16:40,624
所以他们要对对方说，

1743
01:16:40,692 --> 01:16:41,792
相当直接在那里

1744
01:16:43,328 --> 01:16:46,362
现在，另一件有趣的动态

1745
01:16:46,431 --> 01:16:49,765
动画师通常是大多数时候，

1746
01:16:49,834 --> 01:16:52,267
跑到停滞，凯？

1747
01:16:52,336 --> 01:16:53,468
所以事情正在发生，再次，

1748
01:16:53,537 --> 01:16:54,936
从手机底部向上滑动，

1749
01:16:55,005 --> 01:16:57,739
事情，重力把它拉出来，

1750
01:16:57,807 --> 01:17:00,240
它从顶部反弹一次，然后停止。

1751
01:17:00,309 --> 01:17:03,544
而当它停止时，动画仍然可以，但是

1752
01:17:03,613 --> 01:17:04,945
无事可做？

1753
01:17:05,013 --> 01:17:07,213
你会得到这个委托方法发送给你，

1754
01:17:07,282 --> 01:17:08,648
动画师暂停了。

1755
01:17:08,716 --> 01:17:10,849
所以现在你现在，动画师，它还在跑，

1756
01:17:10,918 --> 01:17:12,350
它仍在寻找改变的东西，

1757
01:17:12,419 --> 01:17:15,019
但目前没有任何变化，所以暂停了。

1758
01:17:15,088 --> 01:17:16,187
那么如果有什么改变，

1759
01:17:16,256 --> 01:17:17,489
像你做一个推动行为

1760
01:17:17,557 --> 01:17:20,123
事情开始再次移动，它会说恢复，

1761
01:17:20,192 --> 01:17:22,092
直到一切再次达到停滞。

1762
01:17:22,161 --> 01:17:25,762
现在，你们并不总是在我们的小型小行星中遇到淤滞

1763
01:17:25,831 --> 01:17:27,931
太空游戏，它永远不会达到停滞，

1764
01:17:27,999 --> 01:17:30,900
小行星总是飞行，恒星小行星

1765
01:17:30,969 --> 01:17:34,103
活动，但是从底部翻起来，好的，

1766
01:17:34,172 --> 01:17:36,104
那么它确实达到了停滞

1767
01:17:36,173 --> 01:17:38,173
如果你想知道什么时候到达瘀点，

1768
01:17:38,242 --> 01:17:41,509
你只是将自己设置为UIDynamicAnimatorDelegate，

1769
01:17:41,578 --> 01:17:44,012
那顶级动画控制器的东西，和

1770
01:17:44,080 --> 01:17:46,947
它会告诉你

1771
01:17:47,016 --> 01:17:49,016
现在，我们结合在一起。

1772
01:17:49,085 --> 01:17:49,816
那我们回去吧

1773
01:17:49,885 --> 01:17:51,317
解决我们推出的问题。

1774
01:17:51,386 --> 01:17:53,852
好的，所以我们有这个瞬间推动

1775
01:17:53,921 --> 01:17:55,121
我们这样做。

1776
01:17:55,189 --> 01:17:57,556
首先，我们创造推动行为。

1777
01:17:57,625 --> 01:18:01,259
我们添加我们想推的项目，只是说，

1778
01:18:01,328 --> 01:18:04,863
在那里，UIPushBehavior项目放置一个UI数组

1779
01:18:04,932 --> 01:18:07,331
看到我们想推，然后我们设置模式。

1780
01:18:07,400 --> 01:18:08,632
如果我们将模式设置为Inten-，

1781
01:18:08,701 --> 01:18:10,334
瞬间就在这里

1782
01:18:10,403 --> 01:18:14,304
然后，当我们将这个行为添加到动画制作好的时候，

1783
01:18:14,373 --> 01:18:16,205
我们必须把它添加到一个动画师

1784
01:18:16,274 --> 01:18:18,241
当我们把它添加到一个动画师，它会推这些项目。

1785
01:18:18,242 --> 01:18:20,209
任何事情发生。

1786
01:18:20,278 --> 01:18:22,911
然后，动画师将继续坚强

1787
01:18:22,980 --> 01:18:23,811
指向它。

1788
01:18:23,880 --> 01:18:25,346
所以浪费了内存。

1789
01:18:25,415 --> 01:18:26,548
推动行为只是坐在那里没有使用。

1790
01:18:26,549 --> 01:18:27,682
只是坐着，

1791
01:18:27,750 --> 01:18:28,582
这是瞬间的，

1792
01:18:28,651 --> 01:18:31,484
它已经推了，没什么可做的。

1793
01:18:31,553 --> 01:18:34,587
所以，很多时候我们会做的是我们会用这个动作

1794
01:18:34,656 --> 01:18:37,857
事情有一个关闭，删除pushBehavior

1795
01:18:37,926 --> 01:18:38,757
从动画师。

1796
01:18:38,826 --> 01:18:40,125
[LAUGH]好吗？

1797
01:18:40,194 --> 01:18:42,494
而且，因为我们知道行动得到调用

1798
01:18:42,562 --> 01:18:45,529
瞬间推动，这是一个完美的时间去除它。

1799
01:18:45,598 --> 01:18:47,365
但是，您可以看到这创建

1800
01:18:47,434 --> 01:18:48,999
一个可怕的内存循环。

1801
01:18:49,068 --> 01:18:50,868
看看那闭包，我们做的第一件事，

1802
01:18:50,936 --> 01:18:54,338
说将要捕捉推动行为的pushBehavior。

1803
01:18:54,407 --> 01:18:55,472
当然pushBehavior，

1804
01:18:55,540 --> 01:18:57,540
动作栏在pushBehavior上。

1805
01:18:57,609 --> 01:18:59,041
所以这一点就是回到对方，

1806
01:18:59,110 --> 01:19:01,576
直接相互对峙，保持彼此的内存。

1807
01:19:01,645 --> 01:19:02,811
那么我们如何打破这个循环呢？

1808
01:19:02,879 --> 01:19:05,379
所以我把这个例子拿出来，因为它显示出来

1809
01:19:05,448 --> 01:19:08,215
打破一个循环，我们还没有真正展现出例子

1810
01:19:08,284 --> 01:19:11,552
这是使用未知的，好吗？

1811
01:19:11,621 --> 01:19:13,486
我们不需要在这里做weak self

1812
01:19:13,555 --> 01:19:16,690
其实我们不会weak self，因为我们知道

1813
01:19:16,758 --> 01:19:20,360
里面这个闭包推动行为永远不会是nil，

1814
01:19:20,429 --> 01:19:22,294
它永远不会在堆外，

1815
01:19:22,363 --> 01:19:25,197
因为我们在推动行为的行动方法。

1816
01:19:25,266 --> 01:19:27,733
我们来这里的唯一原因是因为我们刚刚推出

1817
01:19:27,801 --> 01:19:28,600
那个推动行为，所以

1818
01:19:28,669 --> 01:19:30,535
它不可能在堆中。

1819
01:19:30,603 --> 01:19:32,670
所以保证在那里，所以

1820
01:19:32,739 --> 01:19:34,605
我们不需要在这个星期或任何事情，

1821
01:19:34,674 --> 01:19:38,141
我们可以说不知道，不知道的手段不会保持

1822
01:19:38,210 --> 01:19:40,944
强指针内闭包pushBehavior，

1823
01:19:41,013 --> 01:19:43,347
因为我知道它会在堆里。

1824
01:19:44,682 --> 01:19:47,649
你看到那里有多么无名的作品？

1825
01:19:47,718 --> 01:19:50,352
所以没有人是更有力量的 -

1826
01:19:50,421 --> 01:19:52,487
打破内存循环的方式。

1827
01:19:52,556 --> 01:19:54,322
你必须真的确定你那件事

1828
01:19:54,391 --> 01:19:57,358
事实上将会在那里，

1829
01:19:57,426 --> 01:19:58,959
否则会崩溃你的应用程序。

1830
01:19:59,028 --> 01:20:00,261
但是在这里我们知道一个事实。

1831
01:20:01,997 --> 01:20:04,364
好的，就是这样。

1832
01:20:04,432 --> 01:20:07,633
星期三我会做一个巨大的空间演示。

1833
01:20:07,702 --> 01:20:11,403
为了告诉你这些东西如何工作，如果我有时间，

1834
01:20:11,472 --> 01:20:14,439
我几乎肯定我不会尝试一些工作

1835
01:20:14,508 --> 01:20:17,543
核心运动在那里是陀螺仪的加速度计

1836
01:20:17,611 --> 01:20:19,310
那东西我们如何做这个工作。

1837
01:20:19,379 --> 01:20:21,913
本周没有星期五，下周我们要去

1838
01:20:21,981 --> 01:20:25,516
做了很多东西，一般的东西

1839
01:20:25,585 --> 01:20:28,485
我们没有机会在IOS中工作的方式

1840
01:20:28,553 --> 01:20:31,154
覆盖像应用程序的生命周期，你知道什么

1841
01:20:31,223 --> 01:20:33,923
当您的应用程序启动，运行，退出等时发生

1842
01:20:33,992 --> 01:20:37,160
然后就像警报，提出警报

1843
01:20:37,229 --> 01:20:38,527
您将需要的屏幕

1844
01:20:38,596 --> 01:20:41,162
你的最后的项目，还有更多的几个。

1845
01:20:41,231 --> 01:20:43,832
比一点点更稀有的一些

1846
01:20:43,901 --> 01:20:46,234
这个节目让你知道

1847
01:20:46,303 --> 01:20:48,136
下周我也要去盖

1848
01:20:48,204 --> 01:20:50,938
你可能想要所有这些东西，因为你在做你的

1849
01:20:51,007 --> 01:20:52,073
最终项目。

1850
01:20:52,141 --> 01:20:53,540
我会的，所以这就是为什么我要去尝试

1851
01:20:53,609 --> 01:20:55,842
在下周覆盖它，所以你有时间。

1852
01:20:55,911 --> 01:20:59,346
要在结束之前得到它，就这样吧。

1853
01:21:00,815 --> 01:21:11,123
>>更多请访问stanford.edu。

